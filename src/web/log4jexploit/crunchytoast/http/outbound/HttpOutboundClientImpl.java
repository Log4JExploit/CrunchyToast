/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 */

package web.log4jexploit.crunchytoast.http.outbound;

import web.log4jexploit.crunchytoast.exceptions.ConnectionClosedException;
import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.general.HttpCallback;
import web.log4jexploit.crunchytoast.general.HttpSendProcess;
import web.log4jexploit.crunchytoast.general.Pair;
import web.log4jexploit.crunchytoast.http.request.content.ContentCoder;
import web.log4jexploit.crunchytoast.logger.impl.SimpleTimeLoggerImpl;
import web.log4jexploit.crunchytoast.logger.inf.Logger;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.inf.HttpEventHandler;
import web.log4jexploit.crunchytoast.http.request.inf.HttpRequest;
import web.log4jexploit.crunchytoast.http.request.inf.HttpResponse;

import javax.net.SocketFactory;
import java.io.*;
import java.net.*;
import java.util.ArrayDeque;

// Coded by Zadex at 23/10/2022
public final class HttpOutboundClientImpl implements HttpOutboundClient {

    private final ArrayDeque<Pair<HttpRequest, HttpCallback>> packetQueue;
    private final Logger logger;
    private final String ip;
    private final int port;

    private InputStream in;
    private OutputStream out;

    private HttpEventHandler eventHandler;
    private boolean alive, initialized;
    private boolean enableLogger;
    private Thread listener, connector;
    private Socket socket;
    private String bindingIP;


    public HttpOutboundClientImpl(String ip, int port) {
        this.ip = ip;
        this.port = port;
        this.logger = new SimpleTimeLoggerImpl(System.out, this.getClass());
        this.packetQueue = new ArrayDeque<>();
        this.bindingIP = "127.0.0.1";
    }

    private void createSocket() throws IOException {
        this.socket = SocketFactory.getDefault().createSocket();
        this.socket.bind(new InetSocketAddress(0));
    }

    private void init() {
        try {
            this.createSocket();
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        if(this.eventHandler == null) {
            this.eventHandler = new HttpEventHandler() {};
        }

        this.connector = new Thread(() -> {
            try {
                this.logger.info("Connecting...");
                this.socket.connect(new InetSocketAddress(this.ip, this.port));
                this.in = this.socket.getInputStream();
                this.out = this.socket.getOutputStream();
                this.alive = true;
                this.logger.info("Connection established!");

                new Thread(() -> this.eventHandler.onConnect(HttpOutboundClientImpl.this)).start();
                this.listener.start();
            } catch (Exception e) {
                new Thread(() -> this.eventHandler.onDisconnect(HttpOutboundClientImpl.this)).start();
            }
        });

        this.listener = new Thread(() -> {
            try {
                HttpResponse response;
                BufferedReader reader = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));

                while (this.alive) {
                    while (this.packetQueue.isEmpty())
                        Thread.sleep(0, 1024);

                    if(!this.alive || this.socket.isClosed())
                        break;

                    response = HttpResponse.createDefault();
                    ContentCoder contentCoder = response.receive(this, this.in);

                    Pair<HttpRequest, HttpCallback> request;
                    synchronized (this.packetQueue) {
                        request = this.packetQueue.poll();
                    }

                    if (request == null)
                        throw new Exception("Queue contains null value!");

                    HttpResponse finalResponse = response;

                    try {
                        Thread callback = new Thread(() -> request.getValueB().onCallback(finalResponse, contentCoder));
                        callback.start();
                        callback.join();

                        if(!contentCoder.isReadingFinished()) {
                            contentCoder.readAll();
                        }
                    } catch (Exception ignored) {
                        break;
                    }

                    if(!response.getHeaders().containsKey(HttpHeaderType.CONNECTION))
                        break;

                    if(!response.getHeader(HttpHeaderType.CONNECTION).equalsIgnoreCase("keep-alive"))
                        break;
                }
                this.alive = false;
                reader.close();
            } catch (HttpProtocolException e) {
                this.logger.alert("Http protocol violated: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                this.logger.alert("Connection timed to "+this.ip+":"+this.port+" timed out!");
            } catch (SocketException e) {
                this.logger.alert("Unable to connect to "+this.ip+":"+this.port+": "+e.getMessage());
            } catch (IOException e) {
                this.logger.alert("Connection terminated!");
            } catch (Exception e) {
                this.logger.alert("An error occurred: "+e.getMessage());
                e.printStackTrace();
            } finally {
                try {
                    this.logger.alert("Shutting down...");
                    this.alive = false;
                    this.socket.close();
                    this.initialized = false;
                    this.packetQueue.clear();
                    new Thread(() -> this.eventHandler.onDisconnect(HttpOutboundClientImpl.this)).start();
                } catch (Exception | Error e) {
                    e.printStackTrace();
                }
            }
        });

        this.initialized = true;
    }

    @Override
    public void startAndJoin() throws InterruptedException {
        start();

        if(!this.connector.isAlive())
            return;

        this.connector.join();
    }

    @Override
    public void start() {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.init();

        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        this.connector.start();
    }

    @Override
    public void close() throws InterruptedException, IOException {
        if(alive) {
            alive = false;
            socket.close();
            listener.join();
        }
    }

    @Override
    public void send(HttpRequest request, HttpSendProcess sendProcess, HttpCallback callback) throws HttpProtocolException, ConnectionClosedException {
        try {
            if (!this.alive || this.socket.isClosed())
                throw new HttpProtocolException("Client is not connected!");
            synchronized (this.packetQueue) {
                this.packetQueue.add(new Pair<>(request, callback));
                ContentCoder contentCoder = request.send(this, this.out);
                if(sendProcess != null)
                    sendProcess.sendRequest(contentCoder);
                contentCoder.writeAll();
            }
        } catch (Exception e) {
            throw new HttpProtocolException("Request couldn't be converted: " + e.getMessage());
        }
    }

    @Override
    public void setEnabledLogger(boolean enable) {
        this.enableLogger = enable;
    }

    @Override
    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setBindingIP(String ip) {
        this.bindingIP = ip;
    }

    @Override
    public boolean isEnabledLogger() {
        return this.enableLogger;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public boolean isConnected() {
        return this.alive && this.socket != null && !this.socket.isClosed();
    }

    @Override
    public String getIP() {
        return this.socket.getRemoteSocketAddress().toString();
    }

    @Override
    public String getBindingIP() {
        return this.bindingIP;
    }

    @Override
    public int getPort() {
        return this.port;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }
}
