package web.log4jexploit.crunchytoast.http.impl;

import web.log4jexploit.crunchytoast.exceptions.ShutdownException;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.http.request.RequestHandler;
import web.log4jexploit.crunchytoast.logger.impl.LoggerDisabledImpl;
import web.log4jexploit.crunchytoast.logger.impl.SimpleTimeLoggerImpl;
import web.log4jexploit.crunchytoast.logger.inf.Logger;
import web.log4jexploit.crunchytoast.http.inf.HttpClient;
import web.log4jexploit.crunchytoast.http.inf.HttpEventHandler;
import web.log4jexploit.crunchytoast.http.inf.HttpServer;

import javax.net.ServerSocketFactory;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.net.*;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;

// Coded by Zadex at 14/10/2022
public final class HttpServerImpl implements HttpServer {

    private final CopyOnWriteArrayList<HttpClient> activeConnections;
    private final ResourceManager resourceManager;
    private final int port;

    private HttpEventHandler internalEventHandler;
    private HttpEventHandler eventHandler;

    private ServerSocket serverSocket;
    private RequestHandler requestHandler;
    private String bindingIP;
    private Thread listener;
    private Logger logger;

    private boolean enableBlackList;
    private boolean enableKeepAlive;
    private boolean enableLogger;

    private int maxConnections;
    private int maxContentLength;
    private boolean initialized;
    private boolean alive;



    public HttpServerImpl(int port) {
        this.port = port;
        this.activeConnections = new CopyOnWriteArrayList<>();

        String path = Path.of("").toAbsolutePath().toString();
        this.resourceManager = new ResourceManagerImpl(new File(path+File.separator+"resources"));
        this.logger = new SimpleTimeLoggerImpl(System.out, this.getClass());
        this.bindingIP = null;

        this.maxConnections = 0;
        this.maxContentLength = -1;
        this.initialized = false;
        this.enableBlackList = false;
        this.enableKeepAlive = true;
        this.enableLogger = true;
    }

    /**
     * Initializes and generates a {@link ServerSocket}
     * @return the newly created {@link ServerSocket}
     * @throws IOException Is thrown when binding to a specific port or address fails
     */
    private ServerSocket createServerSocket() throws IOException {
        if(this.bindingIP == null) {
            this.serverSocket = new ServerSocket(this.port);
        } else {
            InetSocketAddress address = new InetSocketAddress(this.bindingIP, this.port);
            this.serverSocket = ServerSocketFactory.getDefault().createServerSocket(this.port,-1, address.getAddress());
        }

        return this.serverSocket;
    }

    /**
     * Prepare the server for startup
     */
    private void initialize() {
        if(this.eventHandler == null) {
            this.eventHandler = new HttpEventHandler() {};
        }

        if(this.requestHandler == null) {
            this.requestHandler = new RequestHandler() {};
        }

        this.internalEventHandler = new HttpEventHandler() {
            @Override
            public void onConnect(Client client) {
                getLogger().info(client.getIP()+" connected");
                HttpServerImpl.this.activeConnections.add((HttpClient) client);
                new Thread(() -> HttpServerImpl.this.eventHandler.onConnect(client)).start();
            }

            @Override
            public void onDisconnect(Client client) {
                getLogger().info(client.getIP()+" disconnected");
                HttpServerImpl.this.activeConnections.remove((HttpClient)client);
                new Thread(() -> HttpServerImpl.this.eventHandler.onDisconnect(client)).start();
            }
        };

        listener = new Thread(this::run);
        this.initialized = true;
        this.alive = false;
    }

    private void run() {
        try (ServerSocket currentServerSocket = this.createServerSocket()) {
            alive = true;
            logger.info("Waiting for connections...");

            while (this.alive) {
                // Remove all inactive clients
                this.activeConnections.removeIf(client -> !client.isAlive());

                // If the connection limit has been reached, do not accept new connections
                while(maxConnections > 0 && this.activeConnections.size() >= maxConnections) {
                    Thread.onSpinWait();
                }

                Socket socket = currentServerSocket.accept();
                HttpClient connection = new HttpClientImpl(socket, this, this.internalEventHandler);
                connection.start();
            }
        } catch (BindException e) {
            logger.alert( "Port "+port+" is already in use!");
        } catch (Exception e) {
            logger.alert("An error occurred: "+e.getClass().getSimpleName());
            e.printStackTrace();
        } finally {
            this.initialized = false;
            this.alive = false;
            logger.warn("Shutting down...");
        }

        try {
            // Close all remaining connections after shutdown
            int remaining = activeConnections.size();
            for(HttpClient c : new LinkedList<>(activeConnections))
                c.close();

            logger.warn("Closed "+remaining+" remaining connections!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Starts the server
     */
    @Override
    public void start() {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.initialize();

        if(!initialized) {
            logger.alert("Server startup failed!");
            return;
        }

        logger.info("Starting HTTP server...");
        listener.start();
    }

    @Override
    public void close() throws InterruptedException {
        if(alive) {
            alive = false;
            try {
                serverSocket.close();
                listener.join();
            } catch (IOException e) {
                throw new ShutdownException("Shutdown failed unexpectedly: "+e.getMessage(), e);
            }
        }
    }

    @Override
    public void setRequestHandler(RequestHandler handler) {
        this.requestHandler = handler;
    }

    @Override
    public void setResourceFolder(String path) {
        this.resourceManager.setResourceFolder(path);
    }

    @Override
    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setBindingIP(String ip) {
        this.bindingIP = ip;
    }

    @Override
    public void setMaxContentLength(int maxContentLength) {
        this.maxContentLength = maxContentLength;
    }

    @Override
    public void setEnableKeepAlive(boolean enableKeepAlive) {
        this.enableKeepAlive = enableKeepAlive;
    }

    @Override
    public void setEnableLogger(boolean enable) {
        this.enableLogger = enable;
        this.logger = enable ? new SimpleTimeLoggerImpl(System.out, this.getClass()) : new LoggerDisabledImpl();
    }

    @Override
    public void setEnableBlackList(boolean enable) {
        this.enableBlackList = enable;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public boolean isEnabledKeepAlive() {
        return enableKeepAlive;
    }

    @Override
    public boolean isEnabledBlacklist() {
        return enableBlackList;
    }

    @Override
    public boolean isEnabledLogger() {
        return enableLogger;
    }

    @Override
    public int getPort() {
        return port;
    }

    @Override
    public String getBindingIP() {
        return this.bindingIP;
    }

    @Override
    public ResourceManager getResourceManager() {
        return resourceManager;
    }

    @Override
    public ArrayList<HttpClient> getActiveConnections() {
        return new ArrayList<>(activeConnections);
    }

    @Override
    public void setMaxConnections(int amount) {
        this.maxConnections = amount;
    }

    @Override
    public RequestHandler getRequestHandler() {
        return requestHandler;
    }

    @Override
    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public int getMaxContentLength() {
        return maxContentLength;
    }
}
