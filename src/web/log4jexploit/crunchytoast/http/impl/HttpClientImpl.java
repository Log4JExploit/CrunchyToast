/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.impl;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.general.Pair;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.request.RequestHandler;
import web.log4jexploit.crunchytoast.http.request.content.ContentCoder;
import web.log4jexploit.crunchytoast.http.request.inf.HttpRequest;
import web.log4jexploit.crunchytoast.http.request.inf.HttpResponse;
import web.log4jexploit.crunchytoast.http.util.Http;
import web.log4jexploit.crunchytoast.http.inf.HttpClient;
import web.log4jexploit.crunchytoast.http.inf.HttpEventHandler;
import web.log4jexploit.crunchytoast.http.inf.HttpServer;

import java.io.*;
import java.net.Socket;
import java.util.Objects;

// Coded by Zadex at 14/10/2022
public final class HttpClientImpl implements HttpClient {

    private final Socket socket;
    private final HttpEventHandler eventHandler;
    private final HttpServer server;

    private InputStream in;
    private OutputStream out;

    private Thread handler;
    private boolean alive;
    private boolean free;

    public HttpClientImpl(Socket socket, HttpServer server, HttpEventHandler eventHandler) {
        this.socket = socket;
        this.server = server;
        this.eventHandler = eventHandler;
        this.free = false;
    }


    @Override
    public void initialize() {
        this.handler = new Thread(() -> {
            try {
                in = socket.getInputStream();
                out = socket.getOutputStream();

                this.alive = true;

                eventHandler.onConnect(this);

                do {
                    HttpRequest request = HttpRequest.createDefault();
                    ContentCoder coder = request.receive(this, this.in);

                    server.getLogger().info(this.getIP()+" "+request.getRequestType().toString());

                    RequestHandler requestHandler = this.getServer().getRequestHandler();
                    Pair<HttpResponse, ContentCoder> response = requestHandler.handleRequest(this, request, coder);

                    if(!coder.isReadingFinished()) {
                        coder.readAll();
                    }

                    if(Objects.isNull(response) || Objects.isNull(response.getValueA())) {
                        response = new Pair<>(HttpResponse.createDefault(), null);
                        response.getValueA().setResponseCode(Http.ResponseCode.UNPROCESSABLE_ENTITY);
                    }

                    if(Objects.isNull(response.getValueB())) {
                        response.setValueB(response.getValueA().send(this));
                    }

                    if(!response.getValueB().isWritingFinished()) {
                        response.getValueB().writeAll();
                    }

                    boolean keepAlive = response.getValueA().getHeader(HttpHeaderType.CONNECTION).equalsIgnoreCase("keep-alive");

                    if (!server.isKeepAlive() || !keepAlive)
                        break;
                } while (this.alive);
            } catch (HttpProtocolException e) {
                server.getLogger().info("Http protocol violation: "+getIP()+": "+e.getMessage());
            } catch (IOException ignored) {
                server.getLogger().info("Connection terminated: "+getIP());
            } catch (Exception e) {
                server.getLogger().info("An error occurred: "+e.getClass().getSimpleName()+": "+getIP());
                e.printStackTrace();
            } finally {
                eventHandler.onDisconnect(this);
            }

            try {
                if(!free)
                    socket.close();
            } catch (Exception e) {
                ByteArrayOutputStream stream = new ByteArrayOutputStream();
                e.printStackTrace(new PrintWriter(stream));
                server.getLogger().warn("Couldn't close socket for "+getIP()+": "+stream);
            }
        });
    }

    @Override
    public void start() {
        if(handler != null && handler.isAlive() && !handler.isInterrupted()) {
            return;
        }
        this.initialize();
        this.handler.start();
    }

    @Override
    public void waitForClose() throws InterruptedException {
        this.handler.join();
    }

    @Override
    public Socket free() {
        this.free = true;
        this.alive = false;
        return this.socket;
    }

    @Override
    public void close() {
        if(!this.isAlive() && !this.handler.isAlive())
            return;
        try {
            this.alive = false;
            this.socket.close();
            this.handler.interrupt();
        } catch (Exception ignored) {}
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public HttpServer getServer() {
        return server;
    }

    @Override
    public ResourceManager getResourceManager() {
        return server.getResourceManager();
    }

    @Override
    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    public String getIP() {
        return socket.getInetAddress().getHostAddress();
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }
}
