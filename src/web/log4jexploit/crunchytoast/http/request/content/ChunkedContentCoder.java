/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.request.content;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.general.CommonText;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.util.*;

import java.io.*;
import java.util.*;

// Coded by Zadex at 29/10/2022
public class ChunkedContentCoder implements ContentCoder {

    private final HashMap<HttpHeaderType, String> trailers;
    private final ByteArrayOutputStream encoded;
    private final ByteArrayOutputStream decoded;
    private final Http.Encoding[] encodings;

    private final OutputStream out;
    private final InputStream in;

    private final boolean readMode;

    private boolean decodingFinished;
    private boolean encodingFinished;

    private boolean writingFinished;
    private boolean readingFinished;

    private int chunkSize = 1024;

    // FOR WRITING ONLY
    private ArrayDeque<byte[]> chunks = null;

    // FOR READING ONLY
    private final String[] trailerList;


    public ChunkedContentCoder(InputStream in, String trailers, Http.Encoding[] encodings) {
        this.in = in;
        this.encoded = new ByteArrayOutputStream();
        this.decoded = new ByteArrayOutputStream();
        this.trailers = new HashMap<>();

        if(trailers == null || trailers.isBlank()) {
            this.trailerList = new String[0];
        } else {
            this.trailerList = trailers.split(",");
        }

        this.encodings = encodings;
        this.out = null;
        this.readMode = true;
    }

    public ChunkedContentCoder(OutputStream out, byte[] data, HashMap<HttpHeaderType, String> trailers, Http.Encoding[] encodings) {
        this.out = out;
        this.trailers = trailers;
        this.encodings = encodings;
        this.readMode = false;
        this.trailerList = null;
        this.in = null;
        this.encoded = new ByteArrayOutputStream();
        this.decoded = new ByteArrayOutputStream();
        this.decoded.writeBytes(data);
    }

    private void initChunks() {
        if(!this.encodingFinished)
            this.encodeAll();

        int CHUNK_SIZE = this.chunkSize;

        ByteArrayInputStream in = new ByteArrayInputStream(this.encoded.toByteArray());
        ByteArrayOutputStream chunk = new ByteArrayOutputStream();

        UncheckedIOReader reader = new UncheckedIOReader(in);
        UncheckedIOWriter writer = new UncheckedIOWriter(chunk);

        int read = 0;
        while(read != -1) {
            ByteArrayOutputStream chunkPayload = new ByteArrayOutputStream();
            UncheckedIOWriter chunkPayloadWriter = new UncheckedIOWriter(chunkPayload);

            if(in.available() >= CHUNK_SIZE) {
                chunkPayloadWriter.write(reader.readNBytes(CHUNK_SIZE));
            } else {
                int count = 0;
                while(count < CHUNK_SIZE && (read = reader.read()) != -1) {
                    chunkPayload.write(read);
                    count++;
                }
            }

            writer.write((Integer.toHexString(chunkPayload.size()) + "\n").getBytes());
            writer.write(chunkPayload.toByteArray());
            writer.write("\n".getBytes());
            writer.flush();

            this.chunks.addLast(chunk.toByteArray());
            chunk.reset();
        }

        // TRANSMISSION ENDED
        chunk.writeBytes((Integer.toHexString(0) + "\n\n").getBytes());

        this.chunks.addLast(chunk.toByteArray());
    }

    @Override
    public byte[] read() {
        if(!this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in write mode!");

        UncheckedIOReader reader = new UncheckedIOReader(this.in);
        UncheckedIOWriter writer = new UncheckedIOWriter(this.encoded);

        String hexLength = reader.nextLine().toUpperCase();
        int length = hexLength.length();
        int chunkSize = 0;

        for(int i = 0; i < length; i++) {
            char c = Character.toUpperCase(hexLength.charAt(i));
            int v = c >= '0' && c <= '9' ? c - '0' : c - 'A' + 10;
            chunkSize += (int) (Math.pow(16, length - i - 1) * v);
        }

        byte[] chunk = new byte[chunkSize];

        for(int i = 0; i < chunkSize; i++)
            chunk[i] = reader.read();

        reader.read();

        if(chunkSize > 0) {
            writer.write(chunk);
            writer.flush();
            return chunk;
        }

        reader.read();

        for(int i = 0; i < trailerList.length; i++) {
            String line = reader.nextLine();
            StringBuilder builder = new StringBuilder(line);

            String key = builder.substring(0, builder.indexOf(":")).trim();
            String value = builder.substring(builder.indexOf(":")+1, builder.length()).trim();

            HttpHeaderType type = HttpHeaderType.byString(key);

            if(type == null)
                throw new HttpProtocolException(CommonText.HTTP_UNKNOWN_TRAILER);

            if(!isTrailerRegistered(type))
                throw new HttpProtocolException(CommonText.HTTP_ILLEGAL_TRAILER);

            this.trailers.put(type, value);
        }

        this.readingFinished = true;
        return chunk;
    }

    @Override
    public byte[] readAll() {
        if(!this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in write mode!");

        while(!this.readingFinished) {
            read();
        }

        this.decodeAll();
        return this.getDecoded();
    }

    public void writeSingleChunk(byte[] payload) {
        try {
            ByteArrayOutputStream stream = new ByteArrayOutputStream();
            stream.writeBytes((Integer.toHexString(payload.length) + "\n").getBytes());
            stream.writeBytes(payload);
            stream.write("\n".getBytes());

            byte[] chunk = stream.toByteArray();
            stream.reset();

            for(byte b : chunk)
                out.write(b);
            out.flush();

            if(payload.length == 0)
                this.writingFinished = true;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void write() {
        if(this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in read mode!");

        if(!this.encodingFinished)
            this.encodeAll();

        if(chunks == null) {
            this.chunks = new ArrayDeque<>();
            initChunks();
        }

        if(chunks.isEmpty()) {
            this.writingFinished = true;
            PrintWriter printWriter = new PrintWriter(this.out);
            for(HttpHeaderType headerType : this.trailers.keySet()) {
                String parsed = headerType.toString().toLowerCase().replaceAll("_", "-");
                printWriter.println(parsed+": "+this.trailers.get(headerType));
            }
            printWriter.flush();
            return;
        }

        byte[] chunk = chunks.pollFirst();
        assert chunk != null;

        UncheckedIOWriter writer = new UncheckedIOWriter(this.out);
        writer.write(chunk);
        writer.flush();
    }

    @Override
    public void writeAll() {
        if(this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in read mode!");

        while(!this.writingFinished) {
            write();
        }
    }

    @Override
    public void decodeAll() {
        if(this.decodingFinished)
            return;

        if(!this.readingFinished)
            this.readAll();

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++) {
            encodings[i] = this.encodings[i].toString().toLowerCase().trim();
        }

        try {
            DecodingInputStream stream = new DecodingInputStream(encodings, this.encoded.toByteArray());
            this.decoded.reset();
            this.decoded.writeBytes(stream.readAllBytes());
            stream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        this.decodingFinished = true;
    }

    @Override
    public void encodeAll() {
        if(this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in read mode!");

        if(this.encodingFinished)
            return;

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++)
            encodings[i] = this.encodings[i].toString().toLowerCase();

        try {
            EncodingInputStream inputStream = new EncodingInputStream(encodings, decoded.toByteArray());
            this.encoded.reset();
            this.encoded.writeBytes(inputStream.getBytes());
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        this.encodingFinished = true;
    }

    public void setChunkSize(int chunkSize) {
        this.chunkSize = chunkSize;
    }

    private boolean isTrailerRegistered(HttpHeaderType headerType) {
        for(String trailer : trailerList) {
            if(trailer.equalsIgnoreCase(headerType.toString().replaceAll("_", "-"))) {
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean isDecodingFinished() {
        return decodingFinished;
    }

    @Override
    public boolean isEncodingFinished() {
        return encodingFinished;
    }

    @Override
    public byte[] getDecoded() {
        return this.decoded.toByteArray();
    }

    @Override
    public byte[] getEncoded() {
        return this.encoded.toByteArray();
    }

    @Override
    public boolean isWritingFinished() {
        return false;
    }

    @Override
    public boolean isReadingFinished() {
        return false;
    }

    public int getChunkSize() {
        return chunkSize;
    }
}
