/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.request.content;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.exceptions.PendingInputException;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.util.DecodingInputStream;
import web.log4jexploit.crunchytoast.http.util.EncodingInputStream;
import web.log4jexploit.crunchytoast.http.util.Http;
import web.log4jexploit.crunchytoast.http.util.Utils;

import java.io.*;
import java.util.*;

// Coded by Zadex at 29/10/2022
public class ChunkedContentCoder implements ContentCoder {

    private final HashMap<HttpHeaderType, String> trailers;
    private final ByteArrayOutputStream encoded;
    private final ByteArrayOutputStream decoded;
    private final Http.Encoding[] encodings;

    private final OutputStream out;
    private final InputStream in;

    private final boolean readMode;

    private boolean decodingFinished;
    private boolean encodingFinished;

    private boolean writingFinished;
    private boolean readingFinished;

    private int chunkSize = 1024;

    // FOR WRITING ONLY
    private ArrayDeque<byte[]> chunks = null;

    // FOR READING ONLY
    private final String[] trailerList;


    public ChunkedContentCoder(InputStream in, String trailers, Http.Encoding[] encodings) {
        this.in = in;
        this.encoded = new ByteArrayOutputStream();
        this.decoded = new ByteArrayOutputStream();
        this.trailers = new HashMap<>();

        if(trailers == null || trailers.isBlank()) {
            this.trailerList = new String[0];
        } else {
            this.trailerList = trailers.split(",");
        }

        this.encodings = encodings;
        this.out = null;
        this.readMode = true;
    }

    public ChunkedContentCoder(OutputStream out, byte[] data, HashMap<HttpHeaderType, String> trailers, Http.Encoding[] encodings) {
        this.out = out;
        this.trailers = trailers;
        this.encodings = encodings;
        this.readMode = false;
        this.trailerList = null;
        this.in = null;
        this.encoded = new ByteArrayOutputStream();
        this.decoded = new ByteArrayOutputStream();
        this.decoded.writeBytes(data);
    }

    private void initChunks() throws IOException {
        if(!this.encodingFinished)
            this.encodeAll();

        int CHUNK_SIZE = this.chunkSize;

        ByteArrayInputStream in = new ByteArrayInputStream(this.encoded.toByteArray());
        ByteArrayOutputStream chunk = new ByteArrayOutputStream();

        int read = 0;
        while(read != -1) {
            ByteArrayOutputStream chunkPayload = new ByteArrayOutputStream();

            if(in.available() >= CHUNK_SIZE) {
                chunkPayload.write(in.readNBytes(CHUNK_SIZE));
            } else {
                int count = 0;
                while(count < CHUNK_SIZE && (read = in.read()) != -1) {
                    chunkPayload.write(read);
                    count++;
                }
            }

            chunk.writeBytes((Integer.toHexString(chunkPayload.size()) + "\n").getBytes());
            chunk.writeBytes(chunkPayload.toByteArray());
            chunk.write("\n".getBytes());

            this.chunks.addLast(chunk.toByteArray());
            chunk.reset();
        }

        // TRANSMISSION ENDED
        ByteArrayOutputStream chunkPayload = new ByteArrayOutputStream();
        chunk.writeBytes((Integer.toHexString(chunkPayload.size()) + "\n").getBytes());
        chunk.writeBytes(chunkPayload.toByteArray());
        chunk.write("\n".getBytes());

        this.chunks.addLast(chunk.toByteArray());
    }

    @Override
    public byte[] read() throws IOException, HttpProtocolException {
        if(!this.readMode)
            throw new IOException("This ContentCoder instance is in write mode!");

        Utils reader = new Utils();

        String hexLength = reader.nextLine(this.in).toUpperCase();
        int length = hexLength.length();
        int chunkSize = 0;

        for(int i = 0; i < length; i++) {
            char c = hexLength.charAt(i);
            int v = c >= '0' && c <= '9' ? c - '0' : c - 'A' + 10;
            chunkSize += Math.pow(16, length - i - 1) * v;
        }

        byte[] chunk = new byte[chunkSize];

        for(int i = 0; i < chunkSize; i++)
            chunk[i] = (byte) in.read();

        in.read();

        if(chunkSize < 1) {
            in.read();
            for(int i = 0; i < trailerList.length; i++) {
                StringBuilder builder = new StringBuilder(reader.nextLine(this.in));
                String key = builder.substring(0, builder.indexOf(":")).trim();
                String value = builder.substring(builder.indexOf(":")+1, builder.length()).trim();
                HttpHeaderType type = HttpHeaderType.byName(key);
                if(type == null) {
                    throw new IOException("A trailer has been received, which is not a regular header type!");
                }
                if(!isTrailerRegistered(type)) {
                    throw new HttpProtocolException("A trailer has been received, which wasn't previously declared!");
                }
                this.trailers.put(type, value);
            }
            this.readingFinished = true;
        } else {
            this.encoded.write(chunk);
            this.encoded.flush();
        }

        return chunk;
    }

    @Override
    public byte[] readAll() throws IOException, HttpProtocolException {
        if(!this.readMode)
            throw new IOException("This ContentCoder instance is in write mode!");

        while(!this.readingFinished) {
            read();
        }

        try {
            this.decodeAll();
        } catch (PendingInputException ignored) {}

        return this.getDecoded();
    }

    public void writeSingleChunk(byte[] payload) {
        try {
            ByteArrayOutputStream stream = new ByteArrayOutputStream();
            stream.writeBytes((Integer.toHexString(payload.length) + "\n").getBytes());
            stream.writeBytes(payload);
            stream.write("\n".getBytes());

            byte[] chunk = stream.toByteArray();
            stream.reset();

            for(byte b : chunk)
                out.write(b);
            out.flush();

            if(payload.length == 0)
                this.writingFinished = true;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void write() throws IOException {
        if(this.readMode)
            throw new IOException("This ContentCoder instance is in read mode!");

        if(!this.encodingFinished)
            this.encodeAll();

        if(chunks == null) {
            this.chunks = new ArrayDeque<>();
            initChunks();
        }

        if(chunks.isEmpty()) {
            this.writingFinished = true;
            PrintWriter writer = new PrintWriter(this.out);
            for(HttpHeaderType headerType : this.trailers.keySet()) {
                String parsed = headerType.toString().toLowerCase().replaceAll("_", "-");
                writer.println(parsed+": "+this.trailers.get(headerType));
            }
            writer.flush();
            return;
        }

        byte[] chunk = chunks.pollFirst();
        assert chunk != null;
        this.out.write(chunk);
        this.out.flush();
    }

    @Override
    public void writeAll() throws IOException {
        if(this.readMode)
            throw new IOException("This ContentCoder instance is in read mode!");

        while(!this.writingFinished) {
            write();
        }
    }

    @Override
    public void decodeAll() throws PendingInputException, IOException {
        if(this.decodingFinished)
            return;

        if(!this.readingFinished)
            throw new PendingInputException("Not all data has yet been read from the stream!");

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++) {
            encodings[i] = this.encodings[i].toString().toLowerCase().trim();
        }

        try {
            DecodingInputStream stream = new DecodingInputStream(encodings,this.encoded.toByteArray());
            this.decoded.writeBytes(stream.readAllBytes());
            stream.close();
            this.decodingFinished = true;
        } catch (Exception e) {
            e.printStackTrace();
            throw new IOException("Decoding failed: "+e.getMessage());
        }
    }

    @Override
    public void encodeAll() throws IOException {
        if(this.encodingFinished)
            return;

        if(this.readMode)
            throw new IOException("This ContentCoder instance is in read mode!");

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++)
            encodings[i] = this.encodings[i].toString().toLowerCase();

        EncodingInputStream inputStream = new EncodingInputStream(encodings, decoded.toByteArray());
        this.encoded.reset();
        this.encoded.writeBytes(inputStream.getBytes());
        inputStream.close();
        this.encodingFinished = true;
    }

    public void setChunkSize(int chunkSize) {
        this.chunkSize = chunkSize;
    }

    private boolean isTrailerRegistered(HttpHeaderType headerType) {
        for(String trailer : trailerList) {
            if(trailer.equalsIgnoreCase(headerType.toString().replaceAll("_", "-"))) {
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean isDecodingFinished() {
        return decodingFinished;
    }

    @Override
    public boolean isEncodingFinished() {
        return encodingFinished;
    }

    @Override
    public byte[] getDecoded() {
        return this.decoded.toByteArray();
    }

    @Override
    public byte[] getEncoded() {
        return this.encoded.toByteArray();
    }

    @Override
    public boolean isWritingFinished() {
        return false;
    }

    @Override
    public boolean isReadingFinished() {
        return false;
    }

    public int getChunkSize() {
        return chunkSize;
    }
}
