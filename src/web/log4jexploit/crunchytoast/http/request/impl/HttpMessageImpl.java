/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.request.impl;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.general.Parseable;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.request.content.inf.IBodyContentHandler;
import web.log4jexploit.crunchytoast.http.request.inf.HttpMessage;
import web.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import web.log4jexploit.crunchytoast.http.request.inf.Strategy;
import web.log4jexploit.crunchytoast.http.util.Http;

import java.lang.reflect.Array;
import java.util.*;

public class HttpMessageImpl implements HttpMessage {

    private static final String PROTOCOL = "HTTP/1.1";

    protected Map<HttpHeaderType, String> headers;
    protected Map<String, String> customHeaders;

    protected Map<HttpHeaderType, String> trailers;
    protected Map<String, String> customTrailers;

    protected Strategy.Connection connectionStrategy;
    protected HttpSecurityPolicy securityPolicy;
    protected IBodyContentHandler contentCoder;
    protected byte[] content;
    protected Client client;


    public HttpMessageImpl() {
        this.customHeaders = new HashMap<>();
        this.headers = new HashMap<>();

        this.customTrailers = new HashMap<>();
        this.trailers = new HashMap<>();
    }


    @Override
    public void send(Client client) {
        this.client = client;
        this.securityPolicy = this.securityPolicy != null ? this.securityPolicy : HttpSecurityPolicy.createDefault();
        this.connectionStrategy = new HttpStrategySendImpl();
        execute();
    }

    @Override
    public void receive(Client client) {
        reset();
        this.client = client;
        this.connectionStrategy = new HttpStrategyReceiveImpl();
        this.connectionStrategy.initialize(this.client, this);
        execute();
    }

    @Override
    public void sendTrailers() {
        this.connectionStrategy.executeTrailers();
    }

    @Override
    public void receiveTrailers() {
        this.connectionStrategy.executeTrailers();
    }


    @Override
    public void setKeepAlive(boolean keepAlive) {
        this.headers.put(HttpHeaderType.CONNECTION, keepAlive ? "keep-alive" : "close");
    }

    @Override
    public boolean isKeepAlive() {
        return "keep-alive".equalsIgnoreCase(this.headers.get(HttpHeaderType.CONNECTION));
    }

    @Override
    public void setServer(String server) {
        this.headers.put(HttpHeaderType.SERVER, server);
    }

    @Override
    public String getServer() {
        return this.headers.get(HttpHeaderType.SERVER);
    }

    @Override
    public void setContentLength(int length) {
        this.headers.put(HttpHeaderType.CONTENT_LENGTH, String.valueOf(length));
    }

    @Override
    public int getContentLength() {
        return this.headers.containsKey(HttpHeaderType.CONTENT_LENGTH) ?
                Integer.parseInt(this.getHeader(HttpHeaderType.CONTENT_LENGTH)) : 0;
    }

    @Override
    public void setContentTransferEncoding(Http.Encoding[] encodings) {
        setParseableList(HttpHeaderType.CONTENT_TRANSFER_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getContentTransferEncoding() {
        return getParseableList(HttpHeaderType.CONTENT_TRANSFER_ENCODING, Http.Encoding.BASE64);
    }

    @Override
    public void setContentEncodings(Http.Encoding[] encodings) {
        setParseableList(HttpHeaderType.CONTENT_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getContentEncodings() {
        return getParseableList(HttpHeaderType.CONTENT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public void setTrailerFields(HttpHeaderType[] headerTypes) {
        setParseableList(HttpHeaderType.TRAILER, headerTypes);
    }

    @Override
    public HttpHeaderType[] getTrailerFields() {
        return getParseableList(HttpHeaderType.TRAILER, HttpHeaderType.values()[0]);
    }

    @Override
    public void setAcceptEncodings(Http.Encoding[] encodings) {
        setParseableList(HttpHeaderType.ACCEPT_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getAcceptEncodings() {
        return getParseableList(HttpHeaderType.ACCEPT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public void setAcceptLanguages(Http.Language[] languages) {
        setParseableList(HttpHeaderType.ACCEPT_LANGUAGE, languages);
    }

    @Override
    public Http.Language[] getAcceptLanguages() {
        return getParseableList(HttpHeaderType.ACCEPT_LANGUAGE, Http.Language.values()[0]);
    }

    @Override
    public void setAcceptCharsets(Http.Charset[] charsets) {
        setParseableList(HttpHeaderType.ACCEPT_CHARSET, charsets);
    }

    @Override
    public Http.Charset[] getAcceptCharsets() {
        return getParseableList(HttpHeaderType.ACCEPT_CHARSET, Http.Charset.values()[0]);
    }

    @Override
    public void setContentType(Http.ContentType contentType) {
        this.headers.put(HttpHeaderType.CONTENT_TYPE, contentType.toString());
    }

    @Override
    public Http.ContentType getContentType() {
        return Http.ContentType.values()[0].byString(this.headers.get(HttpHeaderType.CONTENT_TYPE));
    }

    @Override
    public void setChunkedTransfer(boolean chunked) {
        if(chunked) {
            this.headers.put(HttpHeaderType.TRANSFER_ENCODING, "chunked");
            this.headers.remove(HttpHeaderType.CONTENT_LENGTH);
        } else {
            this.headers.remove(HttpHeaderType.TRANSFER_ENCODING);
            this.headers.put(HttpHeaderType.CONTENT_LENGTH, "0");
            this.content = new byte[0];
        }
    }

    @Override
    public boolean isChunkedTransfer() {
        return "chunked".equalsIgnoreCase(this.headers.get(HttpHeaderType.TRANSFER_ENCODING));
    }

    @Override
    public void setCacheControl(String cacheControl) {
        this.headers.put(HttpHeaderType.CACHE_CONTROL, cacheControl);
    }

    @Override
    public String getCacheControl() {
        return this.headers.get(HttpHeaderType.CACHE_CONTROL);
    }

    @Override
    public void setCookie(String cookie) {
        this.headers.put(HttpHeaderType.COOKIE, cookie);
    }

    @Override
    public String getCookie() {
        return this.headers.get(HttpHeaderType.COOKIE);
    }

    @Override
    public void setSetCookie(String cookie) {
        this.headers.put(HttpHeaderType.SET_COOKIE, cookie);
    }

    @Override
    public String getSetCookie() {
        return this.headers.get(HttpHeaderType.SET_COOKIE);
    }

    @Override
    public void setDate(String date) {
        this.headers.put(HttpHeaderType.DATE, date);
    }

    @Override
    public String getDate() {
        return this.headers.get(HttpHeaderType.DATE);
    }

    @Override
    public void setHost(String host) {
        this.headers.put(HttpHeaderType.HOST, host);
    }

    @Override
    public String getHost() {
        return this.headers.get(HttpHeaderType.HOST);
    }

    @Override
    public void setLocation(String location) {
        this.headers.put(HttpHeaderType.LOCATION, location);
    }

    @Override
    public String getLocation() {
        return this.headers.get(HttpHeaderType.LOCATION);
    }

    @Override
    public void setUserAgent(String userAgent) {
        this.headers.put(HttpHeaderType.USER_AGENT, userAgent);
    }

    @Override
    public String getUserAgent() {
        return this.headers.get(HttpHeaderType.USER_AGENT);
    }

    @Override
    public void setVia(String via) {
        this.headers.put(HttpHeaderType.VIA, via);
    }

    @Override
    public String getVia() {
        return this.headers.get(HttpHeaderType.VIA);
    }

    @Override
    public void setProxyAuthorization(String username, String password) {
        this.setAuthFor(HttpHeaderType.PROXY_AUTHORIZATION, username, password);
    }

    @Override
    public String[] getProxyAuthorization() {
        return getAuthFor(HttpHeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public boolean hasProxyAuth() {
        return this.headers.containsKey(HttpHeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public void setReferer(String referer) {
        this.headers.put(HttpHeaderType.REFERER, referer);
    }

    @Override
    public String getReferer() {
        return this.headers.get(HttpHeaderType.REFERER);
    }

    @Override
    public void addTrailer(HttpHeaderType headerType, String value) {
        this.trailers.put(headerType, value);
    }

    @Override
    public void removeTrailer(HttpHeaderType headerType) {
        this.trailers.remove(headerType);
    }

    @Override
    public void setTrailer(HttpHeaderType headerType, String value) {
        this.trailers.put(headerType, value);
    }

    @Override
    public String getTrailer(HttpHeaderType headerType) {
        return trailers.get(headerType);
    }

    @Override
    public void setCustomTrailer(String key, String value) {
        HttpHeaderType headerType;
        if((headerType = HttpHeaderType.values()[0].byString(key)) != HttpHeaderType.CUSTOM)
            this.trailers.put(headerType, value);
        else
            this.customTrailers.put(key, value);
    }

    @Override
    public String getCustomTrailer(String key) {
        HttpHeaderType headerType;
        if((headerType = HttpHeaderType.values()[0].byString(key)) != HttpHeaderType.CUSTOM)
            return this.trailers.get(headerType);
        else
            return this.customTrailers.get(key);
    }

    @Override
    public void setAuthorization(String username, String password) {
        this.setAuthFor(HttpHeaderType.AUTHORIZATION, username, password);
    }

    @Override
    public String[] getAuthorization() {
        return getAuthFor(HttpHeaderType.AUTHORIZATION);
    }

    @Override
    public void setWWWAuthenticate(boolean value) {
        if(value)
            this.headers.put(HttpHeaderType.WWW_AUTHENTICATE, "Basic");
        else
            this.headers.remove(HttpHeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public boolean isWWWAuthenticate() {
        return this.headers.containsKey(HttpHeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public void setWarning(String warning) {
        this.headers.put(HttpHeaderType.WARNING, warning);
    }

    @Override
    public String getWarning() {
        return this.headers.get(HttpHeaderType.WARNING);
    }

    @Override
    public void setUpgradeInsecureRequests(boolean enabled) {
        if(enabled)
            this.headers.put(HttpHeaderType.UPGRADE_INSECURE_REQUESTS, "1");
        else
            this.headers.remove(HttpHeaderType.UPGRADE_INSECURE_REQUESTS);
    }

    @Override
    public boolean isUpgradeInsecureRequests() {
        return this.headers.containsKey(HttpHeaderType.UPGRADE_INSECURE_REQUESTS) &&
                "1".equalsIgnoreCase(this.headers.get(HttpHeaderType.UPGRADE_INSECURE_REQUESTS));
    }

    @Override
    public void setHeader(HttpHeaderType headerType, String value) {
        this.headers.put(headerType, value);
    }

    @Override
    public String getHeader(HttpHeaderType headerType) {
        return this.headers.get(headerType);
    }

    @Override
    public void setHeader(String key, String value) {
        HttpHeaderType headerType;
        if((headerType = HttpHeaderType.values()[0].byString(key)) != HttpHeaderType.CUSTOM)
            this.headers.put(headerType, value);
        else
            this.customHeaders.put(key.toLowerCase(), value);
    }

    @Override
    public void removeHeader(String key) {
        if(key == null)
            return;
        HttpHeaderType headerType;
        if((headerType = HttpHeaderType.values()[0].byString(key)) != HttpHeaderType.CUSTOM)
            this.removeHeader(headerType);
        else
            this.customHeaders.remove(key.toLowerCase());
    }

    @Override
    public void removeHeader(HttpHeaderType headerType) {
        if(headerType == null)
            return;
        this.headers.remove(headerType);
    }

    @Override
    public String getHeader(String key) {
        if(key == null)
            return null;
        HttpHeaderType headerType;
        if((headerType = HttpHeaderType.CONTENT_TYPE.byString(key)) != HttpHeaderType.CUSTOM) {
            return this.headers.get(headerType);
        }
        return this.customHeaders.get(key);
    }

    @Override
    public Map<HttpHeaderType, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, String> getCustomHeaders() {
        return this.customHeaders;
    }

    @Override
    public Map<HttpHeaderType, String> getTrailers() {
        return this.trailers;
    }

    @Override
    public Map<String, String> getCustomTrailers() {
        return this.customTrailers;
    }

    @Override
    public void setContent(byte[] content) {
        this.content = content.clone();
        this.headers.remove(HttpHeaderType.CONTENT_LENGTH);
        this.headers.remove(HttpHeaderType.CONTENT_MD5);
        this.headers.remove(HttpHeaderType.TRANSFER_ENCODING);
    }

    @Override
    public byte[] getContent() {
        return this.content;
    }

    @Override
    public void setContent(byte[] content, Http.ContentType contentType) {
        setContent(content);
        setContentType(contentType);
    }

    @Override
    public String getProtocol() {
        return PROTOCOL;
    }

    @Override
    public Client getClient() {
        return this.client;
    }

    @Override
            public void setSecurityPolicy(HttpSecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy.clone();
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.securityPolicy.clone();
    }

    @SuppressWarnings("unchecked")
    private <T> T[] getParseableList(HttpHeaderType headerType, T typeObject) {
        if(!List.of(typeObject.getClass().getInterfaces()).contains(Parseable.class))
            throw new RuntimeException("Class is not implementing Parseable interface!");

        if(!this.headers.containsKey(headerType) || this.headers.get(headerType) == null)
            return (T[]) Array.newInstance(typeObject.getClass(), 0);

        String listString = this.headers.get(headerType);
        String[] split = listString.split(",");
        List<Parseable> list = new ArrayList<>();

        for (String s : split) {
            list.add(((Parseable) typeObject).byString(s.trim()));
        }

        T[] array = (T[]) Array.newInstance(typeObject.getClass(), list.size());
        for(int i = 0; i < list.size(); i++) {
            array[i] = (T) list.get(i);
        }

        return array;
    }

    private void setParseableList(HttpHeaderType headerType, Parseable... elements) {
        StringBuilder builder = new StringBuilder();
        for(Parseable element : elements) {
            builder.append(element.toString()).append(", ");
        }
        builder.delete(builder.length()-2, builder.length());
        this.headers.put(headerType, builder.toString());
    }

    private String[] getAuthFor(HttpHeaderType headerType) {
        if(!this.headers.containsKey(headerType) || this.headers.get(headerType) == null)
            return new String[0];

        String auth = this.headers.get(headerType).split(" ")[1];
        auth = new String(Base64.getDecoder().decode(auth));

        if(!auth.contains(":"))
            throw new HttpProtocolException("Invalid "+headerType.toString()+" value!");

        return auth.split(":");
    }

    private void setAuthFor(HttpHeaderType headerType, String username, String password) {
        String decoded = username + ":" + password;
        String encoded = Base64.getEncoder().encodeToString(decoded.getBytes());
        headers.put(headerType, "Basic "+encoded);
    }

    private void reset() {
        this.headers.clear();
        this.customHeaders.clear();
        this.trailers.clear();
        this.customTrailers.clear();
        this.content = new byte[0];
        this.client = null;
        this.contentCoder = null;
        this.connectionStrategy = null;
    }

    private void execute() {
        if(this.securityPolicy == null)
            this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.connectionStrategy.execute();
    }
}
