/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.request.impl;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.exceptions.PendingInputException;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.http.inf.HttpClient;
import web.log4jexploit.crunchytoast.http.request.content.ChunkedContentCoder;
import web.log4jexploit.crunchytoast.http.request.content.ContentCoder;
import web.log4jexploit.crunchytoast.http.request.content.EmptyContentCoder;
import web.log4jexploit.crunchytoast.http.request.content.SimpleContentCoder;
import web.log4jexploit.crunchytoast.http.util.Http;
import web.log4jexploit.crunchytoast.http.request.inf.HttpResponse;
import web.log4jexploit.crunchytoast.http.header.HeaderValue;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.util.Utils;

import java.io.*;
import java.util.HashMap;
import java.util.HashSet;


// Coded by Zadex at 21/10/2022
public final class HttpResponseImpl implements HttpResponse {

    private HashMap<String, String> customHeaders;
    private HashMap<HttpHeaderType, String> headers;
    private HashMap<HttpHeaderType, String> trailers;

    private Http.ResponseCode responseCode;
    private String responseProtocol;
    private byte[] content;
    private ContentCoder contentCoder;


    public HttpResponseImpl() {
        this.headers = new HashMap<>();
        this.customHeaders = new HashMap<>();
        this.content = new byte[0];
        this.contentCoder = new EmptyContentCoder();
    }


    @Override
    public ContentCoder receive(Client client, InputStream in) throws IOException, HttpProtocolException {
        try {
            Utils reader = new Utils();

            String[] statusLine = reader.nextLine(in).split(" ");
            this.responseProtocol = statusLine[0];
            this.responseCode = Http.ResponseCode.byCode(Integer.parseInt(statusLine[1]));

            String line;
            while (!(line = reader.nextLine(in)).isEmpty()) {
                int index = line.indexOf(":");
                String key = line.substring(0, index).trim();
                String value = line.substring(index + 1).trim();

                HttpHeaderType headerType = HttpHeaderType.byName(key);

                if (headerType != null) {
                    this.headers.put(headerType, value);
                } else {
                    this.customHeaders.put(key, value);
                }
            }

            // ENCODINGS
            Http.Encoding[] encodings;

            if (headers.containsKey(HttpHeaderType.CONTENT_ENCODING)) {
                String[] split = this.headers.get(HttpHeaderType.CONTENT_ENCODING).split(",");
                encodings = new Http.Encoding[split.length];
                for (int i = 0; i < split.length; i++) {
                    encodings[i] = Http.Encoding.byString(split[i]);
                }
            } else {
                encodings = new Http.Encoding[0];
            }

            boolean chunked = headers.containsKey(HttpHeaderType.TRANSFER_ENCODING) && headers.get(HttpHeaderType.TRANSFER_ENCODING).contains("chunked");
            boolean content = chunked || this.headers.containsKey(HttpHeaderType.CONTENT_LENGTH);

            if (content) {
                if (chunked) {
                    this.headers.remove(HttpHeaderType.CONTENT_LENGTH);
                    this.contentCoder = new ChunkedContentCoder(in, this.headers.get(HttpHeaderType.TRAILER), encodings);
                } else {
                    int length = Integer.parseInt(this.headers.get(HttpHeaderType.CONTENT_LENGTH));
                    this.contentCoder = new SimpleContentCoder(in, length, encodings);
                    this.contentCoder.readAll();
                    this.contentCoder.decodeAll();
                    this.headers.put(HttpHeaderType.CONTENT_LENGTH, Integer.toString(this.contentCoder.getEncoded().length));
                }
            }
        } catch (IOException | HttpProtocolException e) {
            throw e;
        } catch (NullPointerException | IndexOutOfBoundsException | NumberFormatException e) {
            throw new HttpProtocolException("");
        } catch (Exception e) {
            throw new IOException(e);
        }

        return this.contentCoder;
    }

    @Override
    public ContentCoder send(Client client) throws IOException {

        PrintWriter w = new PrintWriter(client.getOutputStream());

        // PREPARATION
        if(this.responseProtocol == null || this.responseProtocol.isEmpty()) {
            this.responseProtocol = "HTTP/1.1";
        }

        if(this.responseCode == null) {
            this.responseCode = Http.ResponseCode.OK;
        }

        this.headers.putIfAbsent(HttpHeaderType.CONNECTION, ((HttpClient)client).getServer().isKeepAlive() ? "Keep-Alive" : "Close");

        // ENCODINGS
        Http.Encoding[] encodings = prepareContentEncodings();

        // TRAILERS
        this.trailers = prepareTrailers();

        // CONTENT CODER DECLARATION
        boolean chunked = headers.containsKey(HttpHeaderType.TRANSFER_ENCODING) && headers.get(HttpHeaderType.TRANSFER_ENCODING).contains("chunked");
        boolean content = this.content != null && this.content.length > 0;

        this.headers.put(HttpHeaderType.CONTENT_LENGTH, "0");

        if(content) {
            if(chunked) {
                this.headers.remove(HttpHeaderType.CONTENT_LENGTH);
                this.contentCoder = new ChunkedContentCoder(client.getOutputStream(), this.content, trailers, encodings);
            } else {
                this.contentCoder = new SimpleContentCoder(client.getOutputStream(), this.content, encodings);
                this.contentCoder.encodeAll();
                this.headers.put(HttpHeaderType.CONTENT_LENGTH, Integer.toString(this.contentCoder.getEncoded().length));
            }
        }

        // INSERT MISSING CONTENT_TYPE
        if(!this.headers.containsKey(HttpHeaderType.CONTENT_TYPE) && content) {
            HeaderValue contentType = new HeaderValue();
            contentType.create(Http.ContentType.BIN.toString());

            this.headers.putIfAbsent(HttpHeaderType.CONTENT_TYPE, contentType.toString());
        }

        // STATUS LINE
        w.println(this.responseProtocol+" "+this.responseCode.toString()) ;

        // HEADERS
        for(HttpHeaderType anyHeaderType : headers.keySet()) {
            String parsed = anyHeaderType.toString().toLowerCase().replaceAll("_", "-");
            w.println(parsed+": "+this.headers.get(anyHeaderType).toLowerCase());
        }

        // CUSTOM HEADERS
        for(String identifier : customHeaders.keySet()) {
            w.println(identifier+": "+this.customHeaders.get(identifier));
        }

        w.println();
        w.flush();

        return this.contentCoder;
    }

    private Http.Encoding[] prepareContentEncodings() {
        Http.Encoding[] encodings = new Http.Encoding[0];

        if(headers.containsKey(HttpHeaderType.CONTENT_ENCODING)) {
            String[] split = this.headers.get(HttpHeaderType.CONTENT_ENCODING).split(",");
            encodings = new Http.Encoding[split.length];
            for(int i = 0; i < split.length; i++) {
                encodings[i] = Http.Encoding.byString(split[i]);
            }
        }
        return encodings;
    }

    private HashMap<HttpHeaderType, String> prepareTrailers() {
        this.trailers = new HashMap<>();

        if(this.headers.containsKey(HttpHeaderType.TRAILER)) {
            String trailer = this.headers.get(HttpHeaderType.TRAILER);
            for(HttpHeaderType anyHeaderType : new HashSet<>(this.headers.keySet())) {
                String parsed = anyHeaderType.toString().toLowerCase().replaceAll("_", "-");
                if(trailer.contains(parsed)) {
                    this.trailers.put(anyHeaderType, this.headers.get(anyHeaderType));
                }
                this.headers.remove(anyHeaderType);
            }
        }

        return this.trailers;
    }

    @Override
    public void setResponseCode(Http.ResponseCode responseCode) {
        this.responseCode = responseCode;
    }

    @Override
    public void setResponseProtocol(String responseProtocol) {
        this.responseProtocol = responseProtocol;
    }

    @Override
    public void setHeader(HttpHeaderType headerType, String headerValue) {
        this.headers.put(headerType, headerValue);
    }

    @Override
    public void setCustomHeader(String identifier, String headerValue) {
        this.customHeaders.put(identifier,headerValue);
    }

    @Override
    public void setContent(byte[] content) {
        this.content = content;
    }

    @Override
    public byte[] getContent() {
        return this.content;
    }

    @Override
    public Http.ResponseCode getResponseCode() {
        return responseCode;
    }

    @Override
    public String getResponseProtocol() {
        return responseProtocol;
    }

    @Override
    public String getHeader(HttpHeaderType headerType) {
        return this.headers.get(headerType);
    }

    @Override
    public String getCustomHeader(String identifier) {
        return this.customHeaders.get(identifier);
    }

    @Override
    public HashMap<HttpHeaderType, String> getHeaders() {
        return new HashMap<>(headers);
    }

    @Override
    public HashMap<String, String> getCustomHeaders() {
        return new HashMap<>(this.customHeaders);
    }

    @Override
    public HttpResponseImpl clone() {
        HttpResponseImpl clone = new HttpResponseImpl();
        clone.headers = new HashMap<>(this.headers);
        clone.content = this.content.clone();
        clone.trailers = this.trailers != null ? new HashMap<>(this.trailers) : new HashMap<>();
        clone.responseCode = this.responseCode;
        clone.responseProtocol = this.responseProtocol;
        clone.customHeaders = new HashMap<>(this.customHeaders);

        return clone;
    }
}
