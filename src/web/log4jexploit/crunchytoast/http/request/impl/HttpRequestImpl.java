/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.request.impl;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.general.NotSanitized;
import web.log4jexploit.crunchytoast.http.request.content.ChunkedContentCoder;
import web.log4jexploit.crunchytoast.http.request.content.ContentCoder;
import web.log4jexploit.crunchytoast.http.request.content.EmptyContentCoder;
import web.log4jexploit.crunchytoast.http.request.content.SimpleContentCoder;
import web.log4jexploit.crunchytoast.http.util.Http;
import web.log4jexploit.crunchytoast.http.header.ArgumentPair;
import web.log4jexploit.crunchytoast.http.request.inf.HttpRequest;
import web.log4jexploit.crunchytoast.http.util.HttpCommunication;
import web.log4jexploit.crunchytoast.http.header.HeaderValue;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.util.Utils;

import java.io.*;
import java.util.HashMap;

// Coded by Zadex at 17/10/2022
public final class HttpRequestImpl extends HttpCommunication implements HttpRequest {

    private HashMap<HttpHeaderType, String> headers;
    private HashMap<String, String> customHeaders;

    private Http.RequestType requestType;
    private String requestProtocol;
    private String requestURI;
    private Client client;
    private ContentCoder contentCoder;
    private byte[] content;


    public HttpRequestImpl() {
        this.headers = new HashMap<>();
        this.customHeaders = new HashMap<>();
        this.requestProtocol = "HTTP/1.1";
        this.requestType = Http.RequestType.GET;
        this.requestURI = "/";
        this.contentCoder = new EmptyContentCoder();
        this.content = new byte[0];
    }




    @NotSanitized(information = "be careful")
    @Override
    public ContentCoder receive(Client client, InputStream in) throws IOException, HttpProtocolException {
        Utils utils = new Utils();
        this.client = client;

        String header = utils.nextLine(in);

        try {
            String[] headerArguments = header.split(" ");
            this.requestType = Http.RequestType.byString(headerArguments[0]);
            this.requestURI = headerArguments[1];
            this.requestProtocol = headerArguments[2];

            if (requestType == null) {
                throw new HttpProtocolException("Invalid Request Type!");
            }

            String line;
            while (!(line = utils.nextLine(in)).isEmpty()) {
                try {
                    int splitIndex = line.indexOf(":");
                    String key = line.substring(0, splitIndex);
                    String value = line.substring(splitIndex + 1).trim();
                    HttpHeaderType type = HttpHeaderType.byName(key);

                    if (type != HttpHeaderType.CUSTOM) {
                        this.headers.put(type, value);
                    } else {
                        this.customHeaders.put(key, value);
                    }
                } catch (Exception e) {
                    break;
                }
            }

            Http.Encoding[] encodings;

            if(headers.containsKey(HttpHeaderType.CONTENT_ENCODING)) {
                String[] split = this.headers.get(HttpHeaderType.CONTENT_ENCODING).split(",");
                encodings = new Http.Encoding[split.length];
                for(int i = 0; i < split.length; i++) {
                    encodings[i] = Http.Encoding.byString(split[i]);
                }
            } else {
                encodings = new Http.Encoding[0];
            }

            boolean chunked = headers.containsKey(HttpHeaderType.TRANSFER_ENCODING) && headers.get(HttpHeaderType.TRANSFER_ENCODING).contains("chunked");
            boolean content = chunked || this.headers.containsKey(HttpHeaderType.CONTENT_LENGTH);

            if(content) {
                if(chunked) {
                    this.headers.remove(HttpHeaderType.CONTENT_LENGTH);
                    return this.contentCoder = new ChunkedContentCoder(in, headers.get(HttpHeaderType.TRAILER), encodings);
                } else {
                    int length = Integer.parseInt(this.headers.get(HttpHeaderType.CONTENT_LENGTH).trim());
                    return this.contentCoder = new SimpleContentCoder(in, length, encodings);
                }
            } else {
                return this.contentCoder = new EmptyContentCoder();
            }
        } catch (HttpProtocolException | NullPointerException e) {
            throw e;
        } catch (Exception e) {
            e.printStackTrace();
            throw new HttpProtocolException("Couldn't parse the incoming data!");
        }
    }

    @Override
    public ContentCoder send(Client client, OutputStream out) {
        this.client = client;
        PrintWriter w = new PrintWriter(out);

        if(this.content.length > 0) {
            HeaderValue contentType = new HeaderValue();
            contentType.create(Http.ContentType.BIN.toString());
            contentType.create(new ArgumentPair("Charset", "UTF-8").toString());

            headers.putIfAbsent(HttpHeaderType.CONTENT_TYPE, contentType.toString());
        }

        this.headers.putIfAbsent(HttpHeaderType.USER_AGENT, "none");
        this.headers.putIfAbsent(HttpHeaderType.CONNECTION, "close");

        w.print(this.requestType.toString()+" "+this.requestURI+" HTTP/1.1");
        w.print("\n");

        this.headers.remove(null);
        this.customHeaders.remove(null);

        for(HttpHeaderType anyHeader : this.headers.keySet())
            w.print(modHeader(anyHeader.toString()) + ": " + this.headers.get(anyHeader) + "\n");

        for(String anyHeader : this.customHeaders.keySet())
            w.print(modHeader(anyHeader) + ": " + this.customHeaders.get(anyHeader) + "\n");

        w.print("\n");
        w.flush();

        Http.Encoding[] encodings;

        if(headers.containsKey(HttpHeaderType.CONTENT_ENCODING)) {
            String[] split = this.headers.get(HttpHeaderType.CONTENT_ENCODING).split(",");
            encodings = new Http.Encoding[split.length];
            for(int i = 0; i < split.length; i++) {
                encodings[i] = Http.Encoding.byString(split[i]);
            }
        } else {
            encodings = new Http.Encoding[0];
        }

        boolean chunked = headers.containsKey(HttpHeaderType.TRANSFER_ENCODING) && headers.get(HttpHeaderType.TRANSFER_ENCODING).contains("chunked");
        boolean content = chunked || this.headers.containsKey(HttpHeaderType.CONTENT_LENGTH);

        if(content) {
            if(chunked) {
                this.headers.remove(HttpHeaderType.CONTENT_LENGTH);
                return this.contentCoder = new ChunkedContentCoder(out, this.content,new HashMap<>(),encodings);
            } else {
                return this.contentCoder = new SimpleContentCoder(out, this.content, encodings);
            }
        } else {
            return this.contentCoder = new EmptyContentCoder();
        }
    }

    @Override
    public void setRequestType(Http.RequestType requestType) {
        this.requestType = requestType;
    }

    @Override
    public void setRequestURI(String requestURI) {
        this.requestURI = requestURI;
    }

    @Override
    public void setRequestProtocol(String requestProtocol) {
        this.requestProtocol = requestProtocol;
    }

    @Override
    public void setHeader(HttpHeaderType headerType, String headerValue) {
        this.headers.put(headerType, headerValue);
    }

    @Override
    public void setContent(byte[] content) {
        this.content = content;
    }

    @Override
    public Http.RequestType getRequestType() {
        return this.requestType;
    }

    @Override
    public String getRequestURI() {
        return this.requestURI;
    }

    @Override
    public String getRequestProtocol() {
        return this.requestProtocol;
    }

    @Override
    public String getHeader(HttpHeaderType headerType) {
        return this.headers.get(headerType);
    }

    @Override
    public String getCustomHeader(String identifier) {
        return this.customHeaders.get(identifier);
    }

    @Override
    public HashMap<HttpHeaderType, String> getHeaders() {
        return this.headers;
    }

    @Override
    public HashMap<String, String> getCustomHeaders() {
        return this.customHeaders;
    }

    @Override
    public Client getClient() {
        return this.client;
    }

    @Override
    public HttpRequestImpl clone() {
        HttpRequestImpl clone = new HttpRequestImpl();
        clone.headers = new HashMap<>(this.headers);
        clone.content = this.content;
        clone.contentCoder = null;
        clone.client = this.client;
        clone.requestType = this.requestType;
        clone.requestProtocol = this.requestProtocol;
        clone.customHeaders = new HashMap<>(this.customHeaders);
        clone.requestURI = this.requestURI;

        return clone;
    }
}
