/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.http.request.impl;

import web.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.http.header.HttpHeaderType;
import web.log4jexploit.crunchytoast.http.request.content.impl.BodyContentReaderChunked;
import web.log4jexploit.crunchytoast.http.request.content.impl.BodyContentReaderDirect;
import web.log4jexploit.crunchytoast.http.request.content.inf.IBodyContentReader;
import web.log4jexploit.crunchytoast.http.request.inf.HttpMessage;
import web.log4jexploit.crunchytoast.http.request.inf.Strategy;
import web.log4jexploit.crunchytoast.http.util.UncheckedIOReader;

import java.util.ArrayList;
import java.util.List;

public class HttpStrategyReceiveImpl implements Strategy.Connection {

    // Syntax here: https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages

    private Client client;
    private HttpMessage message;
    private UncheckedIOReader reader;
    private IBodyContentReader contentReader;


    @Override
    public void initialize(Client client, HttpMessage message) {
        this.client = client;
        this.message = message;
        this.reader = new UncheckedIOReader(client.getInputStream());
    }


    @Override
    public void execute() {
        receiveHeaders();
        performChecks();
        createContentHandler();
    }

    @Override
    public void executeTrailers() {
        receiveTrailers();
    }


    private void receiveHeaders() {
        do {
            String line = this.reader.nextLine(this.message.getSecurityPolicy().getMaxLineLength());

            if(line.isBlank())
                break;

            String[] split = line.split(":");
            HttpHeaderType headerType = HttpHeaderType.TE.byString(split[0].trim());
            if(headerType == HttpHeaderType.CUSTOM) {
                this.message.setHeader(split[0].trim().toLowerCase(), split[1].trim().toLowerCase());
            } else {
                this.message.setHeader(headerType, split[1].trim().toLowerCase());
            }
        } while (this.message.getHeaders().size() +
                this.message.getCustomHeaders().size() < this.message.getSecurityPolicy().getMaxHeaderCount()
        );
    }

    private void performChecks() {
        if(message.isChunkedTransfer() && message.getContentLength() > 0) {
            if(this.message.getSecurityPolicy().isDiscardWhenInvalid())
                throw new HttpProtocolException("ContentLength and TransferEncoding are both set!");
            this.message.removeHeader(HttpHeaderType.CONTENT_LENGTH);
        }

        if(!this.message.getHeaders().containsKey(HttpHeaderType.TRANSFER_ENCODING) && !this.message.getHeaders().containsKey(HttpHeaderType.CONTENT_TYPE)) {
            this.message.removeHeader(HttpHeaderType.TRAILER);
            this.message.getTrailers().clear();
            this.message.getCustomTrailers().clear();
        }

        if(this.message.getTrailerFields().length > this.message.getSecurityPolicy().getMaxHeaderCount())
            throw new HttpProtocolException("Maximum trailer count exceeded!");
    }

    private void createContentHandler() {
        if(this.message.isChunkedTransfer())
            this.contentReader = new BodyContentReaderChunked();

        else if(this.message.getContentLength() > 0)
            this.contentReader = new BodyContentReaderDirect(
                    this.message
            );
        else
            this.contentReader = null;
    }

    private void receiveTrailers() {
        int size = this.message.getTrailers().size() + this.message.getCustomTrailers().size();

        if(size <= 0)
            return;

        ArrayList<HttpHeaderType> expectedTrailers = new ArrayList<>(
                List.of(this.message.getTrailerFields())
        );

        ArrayList<String> expectedCustomTrailers = new ArrayList<>(
                this.message.getCustomTrailers().keySet()
        );

        if(this.contentReader != null)
            this.contentReader.onFlushRemaining();

        for(int i = 0; i < size; i++) {
            String line = reader.nextLine(this.message.getSecurityPolicy().getMaxLineLength());

            if(line.isBlank() || !line.contains(":"))
                throw new HttpProtocolException("Expected a trailer field but found nothing!");

            String[] split = line.split(":");
            split[0] = split[0].toLowerCase().trim();
            split[1] = split[1].trim();

            HttpHeaderType headerType = HttpHeaderType.TE.byString(split[0]);

            if(!expectedTrailers.contains(headerType) && !expectedCustomTrailers.contains(split[0])) {
                throw new HttpProtocolException("Unexpected header in trailer section!");
            }

            if(headerType == HttpHeaderType.CUSTOM)
                this.message.setTrailer(headerType, split[1]);
            else
                this.message.setCustomTrailer(split[0], split[1]);
        }
    }

    @Override
    public IBodyContentReader getContentHandler() {
        return this.contentReader;
    }
}
