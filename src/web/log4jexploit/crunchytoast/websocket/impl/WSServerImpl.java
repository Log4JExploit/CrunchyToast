/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.websocket.impl;

import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import web.log4jexploit.crunchytoast.logger.inf.Logger;
import web.log4jexploit.crunchytoast.websocket.inf.WSClient;
import web.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import web.log4jexploit.crunchytoast.websocket.inf.WSServer;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.UncheckedIOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public final class WSServerImpl implements WSServer {

    private final List<WSClient> activeConnections;
    private final int port;

    private WSEventHandler eventHandler;
    private ServerSocket serverSocket;
    private Thread listener;
    private Logger logger;

    private int maxConnections;

    private boolean initialized;
    private boolean masked;
    private boolean alive;



    public WSServerImpl(int port) {
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.logger = new LoggerTimeImpl(System.out, WSSServerImpl.class);
        this.port = port;

        this.maxConnections = 0;
        this.initialized = false;
        this.alive = false;
    }

    @Override
    public void createServerSocket() throws IOException {
        this.serverSocket = new ServerSocket(this.port);
    }

    private void init() throws IOException {
        this.initialized = false;

        createServerSocket();

        WSEventHandler innerEventHandler = new WSEventHandler() {
            @Override
            public void onConnect(Client client) {
                getLogger().info(client.getIP()+" connected");
                WSServerImpl.this.activeConnections.add((WSClient) client);
                new Thread(() -> WSServerImpl.this.eventHandler.onConnect(client)).start();
            }

            @Override
            public void onClose(Client client) {
                getLogger().info(client.getIP()+" disconnected");
                WSServerImpl.this.activeConnections.remove((WSClient)client);
                new Thread(() -> WSServerImpl.this.eventHandler.onClose(client)).start();
            }

            @Override
            public void onPacketReceive(Client client, byte[] packet) {
                new Thread(() -> WSServerImpl.this.eventHandler.onPacketReceive(client, packet)).start();
            }
        };

        this.listener = new Thread(() -> {
            try {
                this.alive = true;

                while (this.alive && !this.serverSocket.isClosed()) {

                    this.activeConnections.removeIf(client -> !client.isAlive());

                    while(maxConnections > 0 && this.activeConnections.size() >= maxConnections) {
                        Thread.onSpinWait();
                    }

                    Socket socket = this.serverSocket.accept();

                    WSClient client = new WSClientImpl(socket, WSServerImpl.this, innerEventHandler);
                    client.setMasked(this.masked);
                    client.start();
                }
            } catch (SocketException ignored) {
            } catch (Exception e) {
                logger.alert("WebSocket listener threw an exception:");
                e.printStackTrace(new PrintWriter(logger.getOutputStream()));
            }

            try {
                int remaining = activeConnections.size();
                for(Client c : new LinkedList<>(activeConnections))
                    c.close();

                logger.warn("Closed "+remaining+" remaining connections");
            } catch (IOException | InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        this.initialized = true;
        this.alive = false;
    }

    @Override
    public void start() throws UncheckedIOException {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        try {
            this.init();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        this.listener.start();
    }

    @Override
    public void close() throws InterruptedException, UncheckedIOException {
        if(alive) {
            alive = false;
            try {
                serverSocket.close();
                listener.join();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }


    @Override
    public void setEventListener(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isMasked() {
        return this.masked;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public Logger getLogger() {
        return this.logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public ArrayList<WSClient> getActiveConnections() {
        return new ArrayList<>(this.activeConnections);
    }

    @Override
    public void setMaxConnections(int amount) {
        this.maxConnections = amount;
    }

    @Override
    public int getPort() {
        return this.port;
    }
}
