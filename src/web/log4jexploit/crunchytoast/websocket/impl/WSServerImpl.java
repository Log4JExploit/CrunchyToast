/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.websocket.impl;

import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import web.log4jexploit.crunchytoast.logger.inf.Logger;
import web.log4jexploit.crunchytoast.websocket.inf.WSClient;
import web.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import web.log4jexploit.crunchytoast.websocket.inf.WSServer;
import web.log4jexploit.crunchytoast.http.util.Blacklist;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;

public final class WSServerImpl implements WSServer {

    private final CopyOnWriteArrayList<WSClient> activeConnections;
    private final Blacklist blacklist;
    private final Logger logger;
    private final int port;

    private WSEventHandler eventHandler;
    private ServerSocket serverSocket;
    private Thread listener;

    private boolean enableBlackList, enableLogger;
    private boolean alive, initialized, masked;
    private int maxConnections;


    public WSServerImpl(int port) {
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.port = port;
        this.logger = new LoggerTimeImpl(System.out, WSSServerImpl.class);
        this.blacklist = new Blacklist(Paths.get("").toAbsolutePath()+File.separator+"blacklist.txt");

        this.maxConnections = 0;
        this.enableLogger = true;
        this.enableBlackList = false;
        this.alive = false;
        this.initialized = false;
    }

    @Override
    public void createServerSocket() throws IOException {
        this.serverSocket = new ServerSocket(this.port);
    }

    private void init() throws IOException {
        this.initialized = false;

        createServerSocket();
        if(this.enableBlackList)
            this.blacklist.load();

        WSEventHandler innerEventHandler = new WSEventHandler() {
            @Override
            public void onConnect(Client client) {
                getLogger().info(client.getIP()+" connected");
                WSServerImpl.this.activeConnections.add((WSClient) client);
                new Thread(() -> WSServerImpl.this.eventHandler.onConnect(client)).start();
            }

            @Override
            public void onClose(Client client) {
                getLogger().info(client.getIP()+" disconnected");
                WSServerImpl.this.activeConnections.remove(client);
                new Thread(() -> WSServerImpl.this.eventHandler.onClose(client)).start();
            }

            @Override
            public void onPacketReceive(Client client, byte[] packet) {
                new Thread(() -> WSServerImpl.this.eventHandler.onPacketReceive(client, packet)).start();
            }
        };

        this.listener = new Thread(() -> {
            try {
                this.alive = true;

                while (this.alive && !this.serverSocket.isClosed()) {

                    this.activeConnections.removeIf(client -> !client.isAlive());

                    while(maxConnections > 0 && this.activeConnections.size() >= maxConnections) {
                        Thread.onSpinWait();
                    }

                    Socket socket = this.serverSocket.accept();

                    if(this.enableBlackList && this.blacklist.getBlacklisted().contains(socket.getInetAddress().getHostAddress())) {
                        socket.close();
                        continue;
                    }

                    WSClient client = new WSClientImpl(socket, WSServerImpl.this, innerEventHandler);
                    client.setMasked(this.masked);
                    client.start();
                }
            } catch (SocketException ignored) {
            } catch (Exception e) {
                logger.alert("WebSocket listener threw an exception:");
                e.printStackTrace(new PrintWriter(logger.getOutputStream()));
            }

            try {
                int remaining = activeConnections.size();
                for(Client c : new LinkedList<>(activeConnections))
                    c.close();

                logger.warn("Closed "+remaining+" remaining connections");
            } catch (IOException | InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        this.initialized = true;
        this.alive = false;
    }

    @Override
    public void start() throws IOException {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.init();
        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        this.listener.start();
    }

    @Override
    public void close() throws InterruptedException, IOException {
        if(alive) {
            alive = false;
            serverSocket.close();
            listener.join();
        }
    }

    @Override
    public void setEnabledBlacklist(boolean enable) {
        this.enableBlackList = enable;
    }

    @Override
    public void setEnabledLogger(boolean enable) {
        this.enableLogger = enable;
    }

    @Override
    public void setEventListener(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isMasked() {
        return this.masked;
    }

    @Override
    public boolean isEnabledBlacklist() {
        return this.enableBlackList;
    }

    @Override
    public boolean isEnabledLogger() {
        return this.enableLogger;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public Logger getLogger() {
        return this.logger;
    }

    @Override
    public Blacklist getBlacklist() {
        return this.blacklist;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public ArrayList<WSClient> getActiveConnections() {
        return new ArrayList<>(this.activeConnections);
    }

    @Override
    public void setMaxConnections(int amount) {
        this.maxConnections = amount;
    }

    @Override
    public int getPort() {
        return this.port;
    }
}
