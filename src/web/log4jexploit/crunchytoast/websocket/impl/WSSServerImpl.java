/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.websocket.impl;

import web.log4jexploit.crunchytoast.cert.CertManager;
import web.log4jexploit.crunchytoast.cert.CertManagerImpl;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.http.util.Blacklist;
import web.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import web.log4jexploit.crunchytoast.logger.inf.Logger;
import web.log4jexploit.crunchytoast.websocket.inf.WSClient;
import web.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import web.log4jexploit.crunchytoast.websocket.inf.WSServer;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;

// Coded by Zadex at 17/10/2022
public final class WSSServerImpl implements WSServer {

    private final CopyOnWriteArrayList<WSClient> activeConnections;
    private final CertManager certManager;
    private final Blacklist blacklist;
    private final Logger logger;
    private final int port;

    private WSEventHandler eventHandler;
    private ServerSocket serverSocket;
    private Thread listener;

    private int maxConnections;
    private boolean alive;
    private boolean initialized;
    private boolean masked;
    private boolean enableBlackList;
    private boolean enableLogger;


    public WSSServerImpl(int port) {
        this.port = port;

        this.blacklist = new Blacklist(Paths.get("").toAbsolutePath() + File.separator + "blacklist.txt");
        this.logger = new LoggerTimeImpl(System.out, WSSServerImpl.class);
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.certManager = new CertManagerImpl();

        this.maxConnections = 0;
        this.enableBlackList = false;
        this.enableLogger = true;
        this.initialized = false;
        this.alive = false;
        this.masked = true;
    }


    @Override
    public void createServerSocket() throws IOException {
        logger.debug("--- SECURITY INFO ---");
        logger.debug("TLS:");
        logger.debug("TLS Version: TLSv1.3, TLSv1.2");
        logger.debug("Supported Ciphers: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_128_CBC_SHA256");
        logger.debug("Supported Application Protocols: http/1.1");
        logger.debug("Endpoint Identification Algorithm: HTTPS");
        logger.debug("");
        logger.debug("Certificates: ");
        logger.debug("The 'certificates' folder has to contain two files: 'cert.pem' and 'key.pem'");
        logger.debug("The 'key.pem' file has to be formatted as PKCS8");
        logger.debug("The 'cert.pem' file has to be a X509 certificate and needs to be formatted as PEM");
        logger.debug("");
        logger.debug("Credit:");
        logger.debug("SimpleSSL Library by Steven Jenkins De Haro");
        logger.debug("Stevens Github page: https://github.com/StevenJDH");
        logger.debug("SimpleSSL Github repo: https://github.com/StevenJDH/simple-ssl");
        logger.debug("");
        logger.debug("--- SECURITY INFO ---");
        logger.debug("");

        this.certManager.createFactory();
        this.serverSocket = this.certManager.getServerSocketFactory().createServerSocket(this.port);
    }

    private void init() throws IOException {
        this.initialized = false;

        createServerSocket();
        if(this.enableBlackList)
            this.blacklist.load();

        WSEventHandler innerEventHandler = new WSEventHandler() {
            @Override
            public void onConnect(Client client) {
                getLogger().info(client.getIP()+" connected");
                WSSServerImpl.this.activeConnections.add((WSClient) client);
                if(WSSServerImpl.this.eventHandler == null)
                    return;
                new Thread(() -> WSSServerImpl.this.eventHandler.onConnect(client)).start();
            }

            @Override
            public void onClose(Client client) {
                getLogger().info(client.getIP()+" disconnected");
                WSSServerImpl.this.activeConnections.remove(client);
                if(WSSServerImpl.this.eventHandler == null)
                    return;
                new Thread(() -> WSSServerImpl.this.eventHandler.onClose(client)).start();
            }

            @Override
            public void onPacketReceive(Client client, byte[] packet) {
                if(WSSServerImpl.this.eventHandler == null)
                    return;
                new Thread(() -> WSSServerImpl.this.eventHandler.onPacketReceive(client, packet)).start();
            }
        };

        this.listener = new Thread(() -> {
            try {
                this.alive = true;
                logger.info("Waiting for connections...");

                while (this.alive && !this.serverSocket.isClosed()) {

                    this.activeConnections.removeIf(client -> !client.isAlive());

                    while(maxConnections > 0 && this.activeConnections.size() >= maxConnections) {
                        Thread.sleep(1);
                    }

                    Socket socket = this.serverSocket.accept();

                    if(this.enableBlackList) {
                        if(this.blacklist.getBlacklisted().contains(socket.getInetAddress().getHostAddress())) {
                            socket.close();
                            continue;
                        }
                    }

                    WSClient client = new WSClientImpl(socket, WSSServerImpl.this, innerEventHandler);
                    client.start();
                }
            } catch (SocketException ignored) {
            } catch (Exception e) {
                logger.alert("WebSocket listener threw an exception:");
                e.printStackTrace(new PrintWriter(logger.getOutputStream()));
            }

            logger.warn("Shutting down...");

            try {
                int remaining = activeConnections.size();
                for(Client c : new LinkedList<>(activeConnections))
                    c.close();

                logger.warn("Closed "+remaining+" remaining connections");
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

        this.initialized = true;
        this.alive = false;
    }

    @Override
    public void start() throws IOException {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.init();
        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        logger.info("Starting wss server...");
        this.listener.start();
    }

    @Override
    public void close() throws InterruptedException, IOException {
        if(alive) {
            alive = false;
            serverSocket.close();
            listener.join();
        }
    }

    @Override
    public void setEnabledBlacklist(boolean enable) {
        this.enableBlackList = enable;
    }

    @Override
    public void setEnabledLogger(boolean enable) {
        this.enableLogger = enable;
    }

    @Override
    public void setEventListener(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isMasked() {
        return this.masked;
    }

    @Override
    public boolean isEnabledBlacklist() {
        return this.enableBlackList;
    }

    @Override
    public boolean isEnabledLogger() {
        return this.enableLogger;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public Logger getLogger() {
        return this.logger;
    }

    @Override
    public Blacklist getBlacklist() {
        return this.blacklist;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public ArrayList<WSClient> getActiveConnections() {
        return new ArrayList<>(this.activeConnections);
    }

    @Override
    public void setMaxConnections(int amount) {
        this.maxConnections = amount;
    }

    @Override
    public int getPort() {
        return this.port;
    }
}
