/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package web.log4jexploit.crunchytoast.websocket.impl;

import web.log4jexploit.crunchytoast.cert.CertManager;
import web.log4jexploit.crunchytoast.cert.CertManagerImpl;
import web.log4jexploit.crunchytoast.general.Client;
import web.log4jexploit.crunchytoast.logger.inf.Logger;
import web.log4jexploit.crunchytoast.websocket.inf.WSClient;
import web.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import web.log4jexploit.crunchytoast.websocket.inf.WSServer;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;

// Coded by Zadex at 17/10/2022
public final class WSSServerImpl implements WSServer {

    private final CopyOnWriteArrayList<WSClient> activeConnections;
    private final CertManager certManager;
    private final int port;

    private WSEventHandler eventHandler;
    private ServerSocket serverSocket;
    private Thread listener;
    private Logger logger;

    private int maxConnections;

    private boolean initialized;
    private boolean masked;
    private boolean alive;


    public WSSServerImpl(int port) {
        this.port = port;

        this.logger = Logger.createDefault(WSSServerImpl.class);
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.certManager = new CertManagerImpl();

        this.maxConnections = 0;
        this.initialized = false;
        this.masked = true;
        this.alive = false;
    }


    @Override
    public void createServerSocket() throws IOException {
        logger.debug("--- SECURITY INFO ---");
        logger.debug("TLS:");
        logger.debug("TLS Version: TLSv1.3");
        logger.debug("Supported Ciphers: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_128_CBC_SHA256");
        logger.debug("Supported Application Protocols: Http/1.1");
        logger.debug("Endpoint Identification Algorithm: HTTPS");
        logger.debug("");
        logger.debug("Certificates: ");
        logger.debug("The 'certificates' folder has to contain two files: 'cert.pem' and 'key.pem'");
        logger.debug("The 'key.pem' file has to be formatted as PKCS8, unencrypted, containing the private key");
        logger.debug("The 'cert.pem' file has to be a X509 certificate and needs to be formatted as PEM");
        logger.debug("");
        logger.debug("Credit:");
        logger.debug("Author: Log4JExploit");
        logger.debug("Github Repository: https://github.com/Log4JExploit/CrunchyToast/");
        logger.debug("");
        logger.debug("--- SECURITY INFO ---");

        this.certManager.createFactory();
        this.serverSocket = this.certManager.getServerSocketFactory().createServerSocket(this.port);
    }

    private void init() throws IOException {
        this.initialized = false;

        createServerSocket();

        WSEventHandler innerEventHandler = new WSEventHandler() {
            @Override
            public void onConnect(Client client) {
                getLogger().info(client.getIP()+" connected");
                WSSServerImpl.this.activeConnections.add((WSClient) client);
                if(WSSServerImpl.this.eventHandler == null)
                    return;
                new Thread(() -> WSSServerImpl.this.eventHandler.onConnect(client)).start();
            }

            @Override
            public void onClose(Client client) {
                getLogger().info(client.getIP()+" disconnected");
                WSSServerImpl.this.activeConnections.remove((WSClient) client);
                if(WSSServerImpl.this.eventHandler == null)
                    return;
                new Thread(() -> WSSServerImpl.this.eventHandler.onClose(client)).start();
            }

            @Override
            public void onPacketReceive(Client client, byte[] packet) {
                if(WSSServerImpl.this.eventHandler == null)
                    return;
                new Thread(() -> WSSServerImpl.this.eventHandler.onPacketReceive(client, packet)).start();
            }
        };

        this.listener = new Thread(() -> {
            try {
                this.alive = true;
                logger.info("Waiting for connections...");

                while (this.alive && !this.serverSocket.isClosed()) {
                    this.activeConnections.removeIf(client -> !client.isAlive());

                    while(maxConnections > 0 && this.activeConnections.size() >= maxConnections) {
                        Thread.onSpinWait();
                    }

                    Socket socket = this.serverSocket.accept();
                    WSClient client = new WSClientImpl(socket, WSSServerImpl.this, innerEventHandler);
                    client.start();
                }
            } catch (RuntimeException | IOException e) {
                logger.alert("An error occurred: Server terminated: " + e.getClass().getSimpleName());
                logger.alertError(e);
            }

            logger.warn("Shutting down...");

            try {
                int remaining = activeConnections.size();
                for(Client c : new LinkedList<>(activeConnections))
                    c.close();

                logger.warn("Terminated "+remaining+" remaining connections");
            } catch (Exception e) {
                logger.alertError(e);
            }
        });

        this.initialized = true;
        this.alive = false;
    }

    @Override
    public void start() throws UncheckedIOException {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        try {
            this.init();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        logger.info("Starting WSS server...");
        this.listener.start();
    }

    @Override
    public void close() throws InterruptedException, UncheckedIOException {
        if(alive) {
            alive = false;
            try {
                serverSocket.close();
                listener.join();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }

    @Override
    public void setEventListener(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isMasked() {
        return this.masked;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public Logger getLogger() {
        return this.logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public ArrayList<WSClient> getActiveConnections() {
        return new ArrayList<>(this.activeConnections);
    }

    @Override
    public void setMaxConnections(int amount) {
        this.maxConnections = amount;
    }

    @Override
    public int getPort() {
        return this.port;
    }
}
