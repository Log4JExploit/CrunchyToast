/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.cert;

import javax.net.ServerSocketFactory;
import javax.net.ssl.*;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

public final class CertManagerImpl implements CertManager {

    private final String[] ignoredTokens = new String[] {
                    "-----BEGIN ENCRYPTED PRIVATE KEY-----",
                    "-----END ENCRYPTED PRIVATE KEY-----",
                    "-----BEGIN PRIVATE KEY-----",
                    "-----END PRIVATE KEY-----",
                    "\n",
                    "\r"
    };

    private char[] password = "password".toCharArray();

    private String certFileName = "cert.pem";
    private String keyFileName = "key.pem";

    private ServerSocketFactory serverSocketFactory;
    private File certFolder;
    private boolean loaded;


    public CertManagerImpl() {
        String folder = Path.of("").toAbsolutePath() + File.separator + "certificates";
        this.certFolder = new File(folder);
    }


    @Override
    public void createFactory() {
        try {
            if (!certFolder.exists() && !certFolder.mkdir()) {
                throw new FileNotFoundException("Certificates directory doesn't exist!");
            }

            Path certPath = Path.of(certFolder.getAbsolutePath() + File.separator + certFileName);
            Path keyPath = Path.of(certFolder.getAbsolutePath() + File.separator + keyFileName);

            File certFile = new File(certPath.toAbsolutePath().toString());
            File keyFile = new File(keyPath.toAbsolutePath().toString());

            if (!certFile.exists()) {
                throw new FileNotFoundException(certFile.getAbsolutePath() + " doesn't exist!");
            }

            if (!keyFile.exists()) {
                throw new FileNotFoundException(keyFile.getAbsolutePath() + " doesn't exist!");
            }

            byte[] certData = Files.readAllBytes(certFile.toPath());
            Certificate[] chain = CertificateFactory.getInstance("X509").generateCertificates(new ByteArrayInputStream(certData)).toArray(new Certificate[] {});

            String keyDataEncoded = Files.readString(keyFile.toPath());

            // if the key data is not encrypted, use the key as is
            boolean unencryptedPrivateKey = !keyDataEncoded.startsWith("-----BEGIN E");

            // Remove all wrappers
            for(String token : ignoredTokens) {
                keyDataEncoded = keyDataEncoded.replace(token, "");
            }

            byte[] rawPrivateKey = Base64.getDecoder().decode(keyDataEncoded);

            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PKCS8EncodedKeySpec pkcs8EncodedKeySpec;

            if(!unencryptedPrivateKey) {
                // Plan is to add support in the future for aes encrypted keys
                throw new RuntimeException("Encrypted private keys are not yet supported!");
            } else {
                // Use the unencrypted data as is
                pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(rawPrivateKey);
            }

            // Use the now available private key data
            PrivateKey privateKey = keyFactory.generatePrivate(
                pkcs8EncodedKeySpec
            );

            // If it hasn't crashed yet, try loading the private key into the keystore
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(null, password);
            keyStore.setCertificateEntry("certChain", chain[0]);

            keyStore.setEntry(
                    "privateKey",
                    new KeyStore.PrivateKeyEntry(privateKey, chain),
                    new KeyStore.PasswordProtection(password)
            );

            // Create a KeyManagerFactory, for key retrieval
            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("PKIX");
            keyManagerFactory.init(keyStore, this.password);
            KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();

            // Create a TrustManagerFactory, for key retrieval during SSL-Handshakes
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("PKIX");
            trustManagerFactory.init(keyStore);
            TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();

            // Define an SSLContext to only(!) use the (as of now) newest TLS version
            SSLContext.setDefault(SSLContext.getInstance("TLSv1.3"));
            SSLContext ctx2 = SSLContext.getDefault();
            ctx2.init(keyManagers, trustManagers, new SecureRandom());

            this.serverSocketFactory = ctx2.getServerSocketFactory();
            this.loaded = true;
        } catch (FileNotFoundException e) {
            // Make the application fail, if a file couldn't be found.
            throw new RuntimeException(e);
        } catch (Exception e) {
            this.loaded = false;
            RuntimeException runtimeException = new RuntimeException("Couldn't create certificate factories: "+e.getMessage());
            runtimeException.setStackTrace(e.getStackTrace());
            throw runtimeException;
        }
    }

    @Override
    public void createEmptyFactory() {
        try {
            SSLContext.setDefault(SSLContext.getInstance("TLSv1.3"));
            this.serverSocketFactory = SSLServerSocketFactory.getDefault();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    public void setCertificateFolder(Path path) {
        this.certFolder = new File(path.toString());
    }

    @Override
    public void setCertificateFile(String fileName) {
        this.certFileName = fileName;
    }

    @Override
    public void setPrivateKeyFile(String fileName) {
        this.keyFileName = fileName;
    }

    @Override
    public void setPrivateKeyPassword(char[] password) {
        this.password = password;
    }

    @Override
    public boolean hasLoaded() {
        return loaded;
    }

    @Override
    public ServerSocketFactory getServerSocketFactory() {
        return this.serverSocketFactory;
    }

    @Override
    public File getCertificateFolder() {
        return this.certFolder;
    }

    @Override
    public String getCertificateFileName() {
        return this.certFileName;
    }

    @Override
    public String getKeyFileName() {
        return this.keyFileName;
    }
}
