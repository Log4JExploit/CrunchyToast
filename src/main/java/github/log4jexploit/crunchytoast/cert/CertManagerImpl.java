/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.cert;

import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.net.ServerSocketFactory;
import javax.net.ssl.*;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

// Coded by Zadex at 15/10/2022
public final class CertManagerImpl implements CertManager {

    private final String symmetric = "PBEWithHmacSHA256AndAES_256";
    private char[] password = "password".toCharArray();

    private String certFileName = "cert.pem";
    private String keyFileName = "key.pem";

    private ServerSocketFactory serverSocketFactory;
    private File certFolder;
    private boolean loaded;


    public CertManagerImpl() {
        this.certFolder = new File(Path.of("").toAbsolutePath()+File.separator+"certificates");
    }


    @Override
    public void createFactory() {
        try {
            if (!certFolder.exists()) {
                certFolder.mkdir();
                throw new FileNotFoundException("Certificates directory doesn't exist!");
            }

            Path certPath = Path.of(certFolder.getAbsolutePath() + File.separator + certFileName);
            Path keyPath = Path.of(certFolder.getAbsolutePath() + File.separator + keyFileName);

            File certFile = new File(certPath.toAbsolutePath().toString());
            File keyFile = new File(keyPath.toAbsolutePath().toString());

            if (!certFile.exists()) {
                throw new FileNotFoundException(certFile.getAbsolutePath() + " doesn't exist!");
            }

            if (!keyFile.exists()) {
                throw new FileNotFoundException(keyFile.getAbsolutePath() + " doesn't exist!");
            }

            byte[] certData = Files.readAllBytes(certFile.toPath());
            Certificate[] chain = CertificateFactory.getInstance("X509").generateCertificates(new ByteArrayInputStream(certData)).toArray(new Certificate[] {});

            String keyDataEncoded = Files.readString(keyFile.toPath());

            // if the key data is not encrypted, treat it as unencrypted.
            boolean unencryptedPrivateKey = !keyDataEncoded.contains("ENCRYPTED");

            if(unencryptedPrivateKey)
                this.password = new char[0];

            keyDataEncoded =
                    keyDataEncoded.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "")
                    .replace("-----END ENCRYPTED PRIVATE KEY-----", "")
                    .replace("-----BEGIN PRIVATE KEY-----", "")
                    .replace("-----END PRIVATE KEY-----", "")
                    .replace("\n", "")
                    .replace("\r", "");

            byte[] rawPrivateKey = Base64.getDecoder().decode(keyDataEncoded);

            for (Provider provider : Security.getProviders()) {
                System.out.println();
                System.out.println(provider.getName() + ": ");
                for (Provider.Service service : provider.getServices()) {
                    System.out.println("- "+service.getAlgorithm() + " " + service.getType());
                }
            }

            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(symmetric);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PKCS8EncodedKeySpec pkcs8EncodedKeySpec;

            if(!unencryptedPrivateKey) {
                EncryptedPrivateKeyInfo encryptedKey = new EncryptedPrivateKeyInfo(
                        "AES",
                        Base64.getDecoder().decode(keyDataEncoded)
                );

                // Generate the symmetric key for the private key file
                PBEKeySpec passwordSpec = new PBEKeySpec(password);
                SecretKey symmetricKey = secretKeyFactory.generateSecret(passwordSpec);

                // Attempt to decrypt the encrypted private key
                pkcs8EncodedKeySpec = encryptedKey.getKeySpec(symmetricKey);
            } else {
                // Use the unencrypted data as is
                pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(rawPrivateKey);
            }

            // Use the now available private key data
            PrivateKey privateKey = keyFactory.generatePrivate(
                pkcs8EncodedKeySpec
            );

            // If it hasn't crashed yet, try loading the private key into the keystore
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(null, password);
            keyStore.setCertificateEntry("certChain", chain[0]);

            keyStore.setEntry(
                    "privateKey",
                    new KeyStore.PrivateKeyEntry(privateKey, chain),
                    new KeyStore.PasswordProtection(password)
            );

            // Create a KeyManagerFactory, for key retrieval
            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("PKIX");
            keyManagerFactory.init(keyStore, this.password);
            KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();

            // Create a TrustManagerFactory, for key retrieval during SSL-Handshakes
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("PKIX");
            trustManagerFactory.init(keyStore);
            TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();

            // Define an SSLContext to only! use the (as of now) newest TLS version
            SSLContext ctx2 = SSLContext.getInstance("TLSv1.3");
            ctx2.init(keyManagers, trustManagers, new SecureRandom());

            this.serverSocketFactory = ctx2.getServerSocketFactory();
            this.loaded = true;
        } catch (FileNotFoundException e) {
            // Make the application fail, if a file couldn't be found.
            throw new RuntimeException(e);
        } catch (Exception e) {
            this.loaded = false;
            RuntimeException runtimeException = new RuntimeException("Couldn't create certificate factories: "+e.getMessage());
            runtimeException.setStackTrace(e.getStackTrace());
            throw runtimeException;
        }
    }


    @Override
    public void setCertificateFolder(String path) {
        this.certFolder = new File(path);
    }

    @Override
    public void setCertificateFile(String fileName) {
        this.certFileName = fileName;
    }

    @Override
    public void setPrivateKeyFile(String fileName) {
        this.keyFileName = fileName;
    }

    @Override
    public void setPrivateKeyPassword(char[] password) {
        this.password = password;
    }

    @Override
    public boolean hasLoaded() {
        return loaded;
    }

    @Override
    public ServerSocketFactory getServerSocketFactory() {
        return this.serverSocketFactory;
    }

    @Override
    public File getCertificateFolder() {
        return this.certFolder;
    }

    @Override
    public String getCertificateFileName() {
        return this.certFileName;
    }

    @Override
    public String getKeyFileName() {
        return this.keyFileName;
    }
}
