/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.resource;

import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import org.jetbrains.annotations.NotNull;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

public class ResourceSplintered implements Resource {

    private final Http.ContentType contentType;
    private final List<byte[]> splinters;

    public ResourceSplintered(Http.ContentType contentType) {
        this.contentType = contentType;
        this.splinters = new ArrayList<>();
    }


    public void write(byte[] data) {
        this.splinters.add(data);
    }

    public void write(byte[] data, int offset, int length) {
        byte[] buf = new byte[length];
        System.arraycopy(data, offset, buf, 0, length);
        write(buf);
    }

    @Override
    public byte[] getData() {
        long size = this.getSize();
        if(size > Integer.MAX_VALUE)
            throw new RuntimeException("The data doesn't fit inside an array!");
        byte[] data = new byte[(int) this.getSize()];
        int c = 0;
        for(byte[] splinter : splinters) {
            System.arraycopy(splinter, 0, data, c, splinter.length);
            c += splinter.length;
        }
        return data;
    }

    @Override
    public byte[] getDataRange(long offset, int length) {
        InputStream in = getDataAsStream();
        UncheckedIOReader reader = new UncheckedIOReader(in);
        reader.skip(offset);
        byte[] result = reader.readNBytes(length);
        reader.close();
        return result;
    }

    @Override
    public InputStream getDataAsStream() {
        if(this.splinters.isEmpty())
            return new ByteArrayInputStream(new byte[0]);

        return new InputStream() {
            final List<byte[]> referenceSplinters = ResourceSplintered.this.splinters;
            byte[] referenceArray = referenceSplinters.get(0);
            int arrayIndex = 0;
            long counterInArray = 0;

            @Override
            public int read() {
                while(counterInArray >= referenceArray.length) {
                    if(arrayIndex + 1 >= referenceSplinters.size()) {
                        return -1;
                    }
                    arrayIndex++;
                    counterInArray -= referenceArray.length;
                    referenceArray = referenceSplinters.get(arrayIndex);
                }
                int value = Byte.toUnsignedInt(referenceArray[(int)counterInArray]);
                counterInArray++;
                return value;
            }

            @Override
            public long skip(long n) {
                this.counterInArray += n;
                return n;
            }

            @Override
            public void skipNBytes(long n) {
                skip(n);
            }
        };
    }

    public OutputStream getWriteableStream() {
        return new OutputStream() {
            @Override
            public void write(int i) {
                if(i < 0)
                    throw new IllegalArgumentException("Can't write EOF to stream!");
                ResourceSplintered.this.splinters.add(new byte[] {(byte)i});
            }

            @Override
            public void write(byte @NotNull [] buf) {
                performNullCheck(buf);
                ResourceSplintered.this.splinters.add(buf);
            }

            @Override
            public void write(byte @NotNull [] buf, int off, int len) {
                performNullCheck(buf);
                byte[] copy = new byte[len];
                System.arraycopy(buf, off, copy, 0, len);
                ResourceSplintered.this.splinters.add(copy);
            }

            private void performNullCheck(Object e) {
                if(e == null)
                    throw new RuntimeException(new IllegalArgumentException("Byte array can't be null!"));
            }
        };
    }

    @Override
    public boolean isSizeKnown() {
        return true;
    }

    @Override
    public long getSize() {
        long size = 0;
        for(byte[] splinter : splinters) {
            size += splinter.length;
        }
        return size;
    }

    public List<byte[]> getSplinters() {
        return new ArrayList<>(splinters);
    }

    @Override
    public Http.ContentType getContentType() {
        return this.contentType;
    }
}
