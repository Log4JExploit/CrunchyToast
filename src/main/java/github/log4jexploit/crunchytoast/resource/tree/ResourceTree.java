/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.resource.tree;

import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.provider.ResourceProvider;
import github.log4jexploit.crunchytoast.http.util.TreeNode;
import github.log4jexploit.crunchytoast.resource.Resource;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public abstract class ResourceTree<Type> implements ResourceProvider {

    TreeNode<String, Type> tree;


    public ResourceTree(TreeNode<String, Type> tree) {
        this.tree = Objects.requireNonNull(tree);
    }

    public ResourceTree(Type element) {
        Objects.requireNonNull(element);

        this.tree = new TreeNode<>(mapName(element), element);
        TreeNode.populate(this.tree, this::mapTreeStructure);
    }


    public List<Pair<String, Type>> mapTreeStructure(Type element) {
        return mapElements(element).stream().map(
                (e) -> new Pair<>(
                        mapName(e),
                        e
                )
        ).toList();
    }

    /**
     * Retrieve the list of elements within a given element
     * @param element any element
     * @return A list of all elements this element contains
     */
    public abstract List<Type> mapElements(Type element);

    public abstract String mapName(Type element);

    public abstract Resource mapResource(Type element);

    @Override
    public Optional<Resource> apply(String path) {
        Optional<TreeNode<String, Type>> node = matchToNode(path);
        if(node.isPresent()) {
            Optional<Type> carryValue = node.get().getCarryValue();
            return carryValue.map(this::mapResource);
        }
        return Optional.empty();
    }

    public Optional<TreeNode<String, Type>> matchToNode(String path) {
        Objects.requireNonNull(path);

        if(path.contains("//") || path.contains("\\"))
            return Optional.empty();

        if(path.startsWith("/")) {
            path = path.substring(1);
        }

        if(path.endsWith("/")) {
            path = path.substring(0, path.length() - 1);
        }

        if(path.isBlank()) {
            return Optional.of(this.tree);
        }

        List<String> pathElements = Arrays.asList(path.split("/"));
        return tree.searchNode(pathElements.listIterator());
    }

    public String getPathOf(TreeNode<String, Type> node) {
        StringBuilder builder = new StringBuilder("/");
        List<TreeNode<String, Type>> nodes = node.getPath();

        for(TreeNode<String, Type> any : nodes) {
            builder.append(any.getNodeValue()).append("/");
        }

        builder.append(node.getNodeValue());
        return builder.toString();
    }

    public TreeNode<String, Type> getTree() {
        return tree;
    }
}
