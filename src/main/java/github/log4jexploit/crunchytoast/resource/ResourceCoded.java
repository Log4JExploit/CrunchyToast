/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.resource;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.http.util.DecodingStream;
import github.log4jexploit.crunchytoast.http.util.EncodingStream;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.strategy.Strategy;

import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

public class ResourceCoded extends ResourceSplintered {

    private final Http.Encoding[] encodings;
    private final Resource source;

    private ResourceSplintered result;
    private Strategy strategy;
    private boolean invoked;


    public ResourceCoded(Resource source, Http.Encoding[] encodings, Mode mode) {
        super(source.getContentType());
        this.encodings = encodings;
        this.source = source;

        if(encodings == null) {
            throw new IllegalArgumentException("Encodings cannot be null!");
        }

        if(encodings.length == 0) {
            throw new IllegalArgumentException("Encodings cannot be empty!");
        }

        switch (mode) {
            case ENCODE -> this.strategy = new MethodEncode(this);
            case DECODE -> this.strategy = new MethodDecode(this);
        }
    }


    @Override
    public void write(byte[] data) {
        this.strategy.execute();
        this.result.write(data);
    }

    public void write(byte[] data, int offset, int length) {
        this.strategy.execute();
        this.result.write(data, offset, length);
    }

    @Override
    public byte[] getData() {
        this.strategy.execute();
        return this.result.getData();
    }

    @Override
    public byte[] getDataRange(long offset, int length) {
        this.strategy.execute();
        return this.result.getDataRange(offset, length);
    }

    @Override
    public InputStream getDataAsStream() {
        this.strategy.execute();
        return this.result.getDataAsStream();
    }

    public OutputStream getWriteableStream() {
        this.strategy.execute();
        return this.result.getWriteableStream();
    }

    @Override
    public boolean isSizeKnown() {
        return invoked;
    }

    @Override
    public long getSize() {
        this.strategy.execute();
        return this.result.getSize();
    }

    public List<byte[]> getSplinters() {
        this.strategy.execute();
        return this.result.getSplinters();
    }

    @Override
    public Http.ContentType getContentType() {
        return this.source.getContentType();
    }


    private static class MethodSkip implements Strategy {
        @Override
        public void execute() {}
    }

    public static class MethodEncode implements Strategy {

        private final ResourceCoded resource;

        public MethodEncode(ResourceCoded resource) {
            this.resource = resource;
        }

        @Override
        public void execute() {
            try {
                InputStream originalStream = this.resource.source.getDataAsStream();
                this.resource.result = new ResourceSplintered(this.resource.source.getContentType());
                EncodingStream stream = new EncodingStream(
                        this.resource.encodings,
                        this.resource.result.getWriteableStream()
                );

                byte[] buf = new byte[1024 * 128];
                long remaining = this.resource.source.getSize();

                do {
                    int read = originalStream.read(buf, 0, buf.length);
                    remaining -= read;
                    stream.write(buf, 0, read);
                    stream.flush();
                } while(remaining > 0);

                this.resource.invoked = true;
                this.resource.strategy = new MethodSkip();
            } catch (Exception e) {
                throw new HttpProtocolException("Content could not be encoded!");
            }
        }
    }

    public static class MethodDecode implements Strategy {

        private final ResourceCoded resource;

        public MethodDecode(ResourceCoded resource) {
            this.resource = resource;
        }

        @Override
        public void execute() {
            try {
                DecodingStream stream = new DecodingStream(
                        this.resource.encodings,
                        this.resource.source.getDataAsStream()
                );
                this.resource.result = new ResourceSplintered(this.resource.source.getContentType());
                byte[] buf = new byte[1024 * 128];

                int len;
                do {
                    len = stream.readNBytes(buf,0, buf.length);
                    if(len == 0) {
                        continue;
                    }
                    this.resource.result.write(buf, 0, len);
                } while (len > 0);

                this.resource.invoked = true;
                this.resource.strategy = new MethodSkip();
            } catch (Exception e) {
                throw new HttpProtocolException("Content could not be decoded!");
            }
        }
    }

    public enum Mode {
        ENCODE,
        DECODE
    }

}
