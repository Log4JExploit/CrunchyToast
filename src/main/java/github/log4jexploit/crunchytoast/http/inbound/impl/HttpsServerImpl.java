/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.inbound.impl;

import github.log4jexploit.crunchytoast.cert.CertManager;
import github.log4jexploit.crunchytoast.cert.CertManagerImpl;
import github.log4jexploit.crunchytoast.general.Client;
import github.log4jexploit.crunchytoast.http.endpoint.EndpointManager;
import github.log4jexploit.crunchytoast.http.endpoint.EndpointManagerImpl;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpClient;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpServer;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;

import java.io.File;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.*;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;

// Coded by Zadex at 14/10/2022
public final class HttpsServerImpl implements HttpServer {

    private final CopyOnWriteArrayList<HttpClient> activeConnections;
    private final EndpointManager endpointManager;
    private final CertManager certManager;
    private final int port;

    private HttpEventHandler internalEventHandler;
    private HttpEventHandler eventHandler;

    private ServerSocket serverSocket;
    private String bindingIP;
    private Thread listener;
    private Logger logger;

    private boolean enableKeepAlive;
    private boolean initialized;
    private boolean alive;

    private int maxContentLength;
    private int maxConnections;


    public HttpsServerImpl(int port) {
        this.port = port;
        this.activeConnections = new CopyOnWriteArrayList<>();

        this.eventHandler = new HttpEventHandler() {};

        String path = Path.of("").toAbsolutePath().toString();
        this.endpointManager = new EndpointManagerImpl(new File(path+File.separator+"resources"));
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.bindingIP = null;
        this.certManager = new CertManagerImpl();

        this.maxConnections = 0;
        this.maxContentLength = -1;
        this.initialized = false;
        this.enableKeepAlive = true;
    }


    /**
     * Prints the credits and advice for handling<br>
     * the certificate and key files
     */
    private void printDebug() {
        logger.debug("--- SECURITY INFO ---");
        logger.debug("TLS:");
        logger.debug("TLS Version: TLSv1.3");
        logger.debug("Supported Ciphers: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_128_CBC_SHA256");
        logger.debug("Supported Application Protocols: Http/1.1");
        logger.debug("Endpoint Identification Algorithm: HTTPS");
        logger.debug("");
        logger.debug("Certificates: ");
        logger.debug("The 'certificates' folder has to contain two files: 'cert.pem' and 'key.pem'");
        logger.debug("The 'key.pem' file has to be formatted as PKCS8, unencrypted, containing the private key");
        logger.debug("The 'cert.pem' file has to be a X509 certificate and needs to be formatted as PEM");
        logger.debug("");
        logger.debug("Credit:");
        logger.debug("Author: Log4JExploit");
        logger.debug("Github Repository: https://github.com/Log4JExploit/CrunchyToast/");
        logger.debug("");
        logger.debug("--- SECURITY INFO ---");
    }

    /**
     * Initializes the certificate factory and generates a {@link ServerSocket}
     * @return the newly created {@link ServerSocket}
     * @throws IOException Is thrown when binding to a specific port or address fails
     */
    private ServerSocket createServerSocket() throws IOException {
        this.certManager.createFactory();

        if(this.bindingIP == null) {
            this.serverSocket = this.certManager.getServerSocketFactory().createServerSocket(port);
        } else {
            InetAddress address = new InetSocketAddress(this.bindingIP, this.port).getAddress();
            this.serverSocket = this.certManager.getServerSocketFactory().createServerSocket(this.port,-1, address);
        }

        return this.serverSocket;
    }

    /**
     * Prepare the server for startup
     */
    private void initialize() {
        printDebug();

        this.internalEventHandler = new HttpEventHandler() {
            @Override
            public void onDisconnect(Client client) {
                getLogger().info(client.getIP()+" disconnected");
                HttpsServerImpl.this.activeConnections.remove((HttpClient) client);
                new Thread(() -> HttpsServerImpl.this.eventHandler.onDisconnect(client)).start();
            }

            @Override
            public void onConnect(Client client) {
                getLogger().info(client.getIP()+" connected");
                HttpsServerImpl.this.activeConnections.add((HttpClient) client);
                new Thread(() -> HttpsServerImpl.this.eventHandler.onConnect(client)).start();
            }
        };

        listener = new Thread(this::run);
        this.initialized = true;
        this.alive = false;
    }

    private void run() {
        try (ServerSocket currentServerSocket = this.createServerSocket()) {
            alive = true;
            logger.info("Waiting for connections...");

            while (this.alive) {
                // Remove all inactive clients
                this.activeConnections.removeIf(client -> !client.isAlive());

                // If the connection limit has been reached, do not accept new connections
                while(maxConnections > 0 && this.activeConnections.size() >= maxConnections) {
                    Thread.onSpinWait();
                }

                Socket socket = currentServerSocket.accept();
                HttpClient connection = new HttpClientImpl(socket, this, this.internalEventHandler);
                connection.start();
            }
        } catch (BindException e) {
            logger.alert("Port "+port+" is already in use!");
        } catch (Exception e) {
            logger.debugError(e);
        } finally {
            logger.alert("Shutting down...");
            this.initialized = false;
            this.alive = false;

            // Close all remaining connections after shutdown
            int remaining = activeConnections.size();
            for(HttpClient c : new LinkedList<>(activeConnections))
                c.close();

            logger.info("Closed "+remaining+" remaining connections!");
            logger.alert("Stopped!");
        }

    }

    /**
     * Starts the server
     */
    @Override
    public void start() {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.initialize();

        if(!initialized) {
            logger.alert("Server startup failed!");
            return;
        }

        logger.info("Starting HTTPS server...");
        listener.start();
    }

    @Override
    public void close() {
        if(!alive)
            return;

        try {
            alive = false;
            serverSocket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public void setEventHandler(HttpEventHandler eventHandler) {
        if(eventHandler == null)
            throw new IllegalArgumentException("Illegal argument: EventHandler cannot be null!");
        this.eventHandler = eventHandler;
    }

    @Override
    public void setBindingIP(String ip) {
        this.bindingIP = ip;
    }

    @Override
    public void setMaxContentLength(int maxContentLength) {
        this.maxContentLength = maxContentLength;
    }

    @Override
    public void setKeepAlive(boolean enableKeepAlive) {
        this.enableKeepAlive = enableKeepAlive;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public boolean isKeepAlive() {
        return enableKeepAlive;
    }

    @Override
    public int getPort() {
        return port;
    }

    @Override
    public String getBindingIP() {
        return this.bindingIP;
    }

    @Override
    public EndpointManager getEndpointManager() {
        return endpointManager;
    }

    @Override
    public ArrayList<HttpClient> getActiveConnections() {
        return new ArrayList<>(activeConnections);
    }

    @Override
    public void setMaxConnections(int amount) {
        this.maxConnections = amount;
    }

    @Override
    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public int getMaxContentLength() {
        return maxContentLength;
    }
}
