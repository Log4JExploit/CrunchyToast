/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.inbound.impl;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.http.endpoint.EndpointManager;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpClient;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.Socket;

public final class HttpClientImpl implements HttpClient {

    private final Socket socket;
    private final HttpServer server;

    private InputStream in;
    private OutputStream out;

    private Thread packetHandlerThread;
    private boolean alive;
    private boolean free;


    public HttpClientImpl(Socket socket, HttpServer server) {
        this.socket = socket;
        this.server = server;
        this.free = false;
    }

    private void onStart() {
        try {
            in = socket.getInputStream();
            out = socket.getOutputStream();

            this.alive = true;
            server.onConnect(this);

            while (this.alive && !this.free) {
                spin();
            }
        } catch (HttpProtocolException e) {
            server.getLogger().info("Http protocol violation: "+ getAddress()+": "+e.getMessage());
            server.getLogger().debugError(e);
        } catch (UncheckedIOException | IOException e) {
            server.getLogger().info("Connection closed: " + getAddress());
        } catch (RuntimeException e) {
            server.getLogger().info("Connection closed: " + getAddress());
            server.getLogger().debugError(e);
        } finally {
            server.onDisconnect(this);
            try {
                if(!free)
                    socket.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }

    /**
     * Handle incoming requests
     */
    private void spin() {
        HttpRequest request = HttpRequest.createDefault();
        IBodyContentReader bodyContentReader = request.receive(this);

        server.getLogger().debug(this.getAddress()+" "+request.getRequestType().toString());

        EndpointManager rm = HttpClientImpl.this.getEndpointManager();
        HttpResponse response = rm.delegateRequest(request);

        if(isFree())
            return;

        if(!response.isSending())
            response.send(this);

        // Flush remaining content
        bodyContentReader.onFlushRemaining();
        response.getBodyContentHandler().onFlushRemaining();

        boolean keepAlive = server.getSecurityPolicy().isKeepAliveByDefault();
        if (!(keepAlive && response.isKeepAlive())) {
            throw new RuntimeException();
        }
    }

    @Override
    public void start() {
        if(packetHandlerThread != null) {
            return;
        }
        this.packetHandlerThread = new Thread(this::onStart);
        this.packetHandlerThread.start();
    }

    @Override
    public void waitForClose() throws InterruptedException {
        this.packetHandlerThread.join();
    }

    @Override
    public boolean isFree() {
        return this.free;
    }

    @Override
    public Socket free() {
        this.free = true;
        this.alive = false;
        this.packetHandlerThread.interrupt();
        return this.socket;
    }

    @Override
    public void close() {
        if(!this.isAlive() && !this.packetHandlerThread.isAlive())
            return;
        try {
            this.alive = false;
            this.socket.close();
            this.packetHandlerThread.interrupt();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public HttpServer getServer() {
        return server;
    }

    @Override
    public EndpointManager getEndpointManager() {
        return server.getEndpointManager();
    }

    public String getAddress() {
        return socket.getInetAddress().getHostAddress();
    }

    public String getAddressResolved() {
        return socket.getInetAddress().getHostAddress();
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.server.getSecurityPolicy();
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }
}
