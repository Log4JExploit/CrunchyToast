/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.inbound.impl;

import github.log4jexploit.crunchytoast.exceptions.ConnectionClosedException;
import github.log4jexploit.crunchytoast.exceptions.ProtocolException;
import github.log4jexploit.crunchytoast.general.CommonText;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.general.ScheduledTask;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpClient;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.provider.PostProcessor;
import github.log4jexploit.crunchytoast.http.provider.Provider;
import github.log4jexploit.crunchytoast.http.provider.ProviderManager;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.Socket;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

public class HttpClientImpl implements HttpClient {

    private final AtomicReference<Optional<HttpResponse>> reference;
    protected ScheduledTask task;
    private HttpRequest request;

    protected final Socket socket;
    protected final HttpServer server;

    protected InputStream in;
    protected OutputStream out;

    protected Runnable hookClose;

    protected Thread handler;
    protected boolean alive;


    public HttpClientImpl(Socket socket, HttpServer server) {
        this.socket = Objects.requireNonNull(socket);
        this.server = Objects.requireNonNull(server);

        this.hookClose = this::closeSocket;

        this.reference = new AtomicReference<>();
        this.task = new ScheduledTask(() -> onTaskExecute(this.request, reference));

        this.init();
    }

    private void init() {
        try {
            in = this.socket.getInputStream();
            out = this.socket.getOutputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    protected void onStart() {
        try {
            if(alive)
                return;

            this.alive = true;
            this.server.getClientConnectHook().accept(this);

            while (this.alive) {
                this.spin();
            }
        } catch (Exception e) {
            this.onError(e);
        } finally {
            if(!this.alive) {
                this.closeSelf();
            }
        }
    }

    protected void onError(Exception e) {
        if(
                e instanceof ProtocolException ||
                e instanceof IOException ||
                e instanceof UncheckedIOException ||
                e instanceof ConnectionClosedException
        ) {
            server.getLogger().debugError(e);
            return;
        }

        server.getLogger().warnError(e);
    }

    /**
     * Handle incoming requests
     */
    protected void spin() {
        this.reference.set(Optional.empty());
        this.request = HttpRequest.createDefault();

        final IBodyContentReader bodyContentReader = request.receive(this);

        this.task.setDone(false);
        this.server.getWorkerGroup().add(task);

        if(!task.isDone()) {
            task.getLock().waitForWake();
        }

        reference.get().ifPresentOrElse(
                (response) -> this.sendResponse(response, bodyContentReader),
                this::closeSelf
        );
    }

    private void onTaskExecute(HttpRequest request, AtomicReference<Optional<HttpResponse>> reference) {
        this.server.getLogger().debug(CommonText.HTTP_DEBUG_REQUEST.apply(request));

        for(Provider preProcessor : this.server.getPreProcessors()) {
            Optional<HttpResponse> result = preProcessor.apply(request);
            if(result.isPresent()) {
                reference.set(result);
                return;
            }
        }

        reference.set(HttpClientImpl.this.getProviderManager().apply(request));
        Pair<HttpRequest, Optional<HttpResponse>> requestAndResponsePair = new Pair<>(request, reference.get());

        for(PostProcessor postProcessor : this.server.getPostProcessors()) {
            Optional<HttpResponse> result = postProcessor.apply(requestAndResponsePair);
            if(result.isPresent()) {
                reference.set(result);
                return;
            }
        }
    }

    private void sendResponse(HttpResponse response, IBodyContentReader reader) {
        if(!alive || response == null)
            throw new ConnectionClosedException();

        reader.onFlushRemaining();

        if(response.isSending() && !response.getClient().equals(this)) {
            response = (HttpResponse) response.clone();
        }

        if(!response.isSending()) {
            response.send(this).onFlushRemaining();
        }

        if (this.server.getSecurityPolicy().isKeepAliveByDefault() && response.isKeepAlive()) {
            return;
        }

        throw new ConnectionClosedException();
    }

    @Override
    public void start() {
        if(this.alive) {
            return;
        }

        this.handler = new Thread(this::onStart);
        this.handler.start();
        //this.lockStart.waitForWake();
    }

    @Override
    public void waitForClose() throws InterruptedException {
        this.handler.join();
    }

    @Override
    public Socket free() {
        this.hookClose = () -> {};
        this.close();
        return this.socket;
    }

    @Override
    public void close() {
        if(!alive)
            return;
        this.closeSelf();
        this.handler.interrupt();
    }

    private void closeSelf() {
        this.alive = false;
        this.hookClose.run();
        this.server.getClientDisconnectHook().accept(this);
    }

    private void closeSocket() {
        try {
            this.socket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public HttpServer getServer() {
        return server;
    }

    @Override
    public ProviderManager getProviderManager() {
        return server.getProviderManager();
    }

    public String getAddress() {
        return socket.getInetAddress().getHostAddress();
    }

    public String getAddressResolved() {
        return socket.getInetAddress().getHostAddress();
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.server.getSecurityPolicy();
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }
}
