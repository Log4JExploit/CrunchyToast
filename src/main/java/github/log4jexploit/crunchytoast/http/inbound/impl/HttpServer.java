/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.inbound.impl;

import github.log4jexploit.crunchytoast.general.CommonText;
import github.log4jexploit.crunchytoast.general.LockNotify;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.general.WorkerGroup;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpClient;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.provider.*;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.http.util.SecurityPolicy;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.server.Client;
import github.log4jexploit.crunchytoast.server.Server;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.BindException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;


public abstract class HttpServer implements Server {

    protected final List<HttpClient> activeConnections;

    protected final EndpointManager endpointManager;
    protected final ProviderManager providerManager;

    protected final Set<PostProcessor> postProcessors;
    protected final Set<Provider> preProcessors;

    protected final WorkerGroup workerGroup;
    protected final LockNotify lock;

    protected Logger logger;

    protected HttpSecurityPolicy securityPolicy;
    protected HttpEventHandler eventHandler;
    protected Thread handler;

    protected volatile boolean alive;

    private final int port;
    private ServerSocket serverSocket;
    private String bindingIP;
    private Runnable hookStart;


    protected HttpServer(int port) {
        this(port, "127.0.0.1", 4);
    }

    protected HttpServer(int port, String bindingIP, int workerThreadLimit) {
        this.port = port;
        this.eventHandler = new HttpEventHandler() {};

        this.activeConnections = new CopyOnWriteArrayList<>();
        this.postProcessors = new HashSet<>();
        this.preProcessors = new HashSet<>();

        this.workerGroup = new WorkerGroup(workerThreadLimit);
        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.endpointManager = new EndpointManagerImpl(this);
        this.providerManager = new ProviderManagerImpl();
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.lock = new LockNotify();
        this.bindingIP = bindingIP;

        this.hookStart = () -> {};

        this.providerManager.register(this.endpointManager);
    }

    /**
     * Generates and initializes a {@link ServerSocket}
     * @throws IOException Is thrown when binding to a specific port or address fails
     */
    protected abstract ServerSocket createServerSocket() throws IOException;

    /**
     * Prepare the server for startup
     */
    private void initialize() {
        try {
            this.serverSocket = this.createServerSocket();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        handler = new Thread(this::launch);
        this.alive = false;
    }

    private void launch() {
        try {
            this.alive = true;
            logger.info(CommonText.SERVER_STARTED.apply(this));
            while (this.alive) {
                spin();
            }
        } catch (Exception e) {
            this.onError(e);
        } finally {
            this.alive = false;
            this.closeRemaining();
            this.close();
        }
    }

    private void closeRemaining() {
        int remaining = activeConnections.size();
        activeConnections.forEach(Client::close);
        logger.warn(CommonText.SERVER_CLOSED_REMAINING.apply(new Pair<>(this, remaining)));
    }

    private void onError(Exception e) {
        if(e instanceof BindException) {
            logger.alert(CommonText.SERVER_PORT_FAIL.apply(this));
            return;
        }

        logger.alert(CommonText.SERVER_CRASH.apply(this));
        logger.alertError(e);
    }

    /**
     * Accepts new clients
     * @throws IOException in case something goes wrong
     */
    private void spin() throws IOException {
        // If the connection limit has been reached, do not accept new connections
        final long max = this.securityPolicy.getMaxConnections();

        if(max > 0 && this.activeConnections.size() > max) {
            lock.waitForWake();
        }

        this.cleanUp();

        Socket socket = this.serverSocket.accept();
        HttpClient connection = this.createHttpClient(socket);
        connection.start();
    }

    protected HttpClient createHttpClient(Socket socket) {
        return new HttpClientImpl(socket, this);
    }

    /**
     * Remove all inactive clients
     */
    private void cleanUp() {
        new ArrayList<>(this.activeConnections).forEach((client) -> {
            if(client.isAlive())
                return;
            client.close();
            onDisconnect(client);
        });
    }

    private void onDisconnect(HttpClient client) {
        Objects.requireNonNull(client);

        if(!this.alive)
            return;

        this.logger.info(CommonText.IN_CLIENT_DISCONNECT.apply(client));
        this.activeConnections.remove(client);
        this.lock.wakeAll();
        new Thread(() -> this.eventHandler.onDisconnect(client)).start();
    }

    private void onConnect(HttpClient client) {
        Objects.requireNonNull(client);

        if(!this.alive)
            return;

        this.logger.info(CommonText.IN_CLIENT_CONNECT.apply(client));
        this.activeConnections.add(client);
        new Thread(() -> this.eventHandler.onConnect(client)).start();
    }

    /**
     * Starts the server
     */
    @Override
    public void start() {
        if(this.alive) {
            return;
        }

        this.initialize();
        handler.start();
    }

    @Override
    public void close() {
        if(!alive)
            return;

        try {
            alive = false;
            this.handler.interrupt();
            serverSocket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = Objects.requireNonNull(eventHandler);
    }

    public void addPostProcessor(PostProcessor postProcessor) {
        this.postProcessors.add(postProcessor);
    }

    public void addPreProcessor(Provider preProcessor) {
        this.preProcessors.add(preProcessor);
    }

    public void removePostProcessor(PostProcessor postProcessor) {
        this.postProcessors.remove(postProcessor);
    }

    public void removePreProcessor(Provider preProcessor) {
        this.preProcessors.remove(preProcessor);
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public int getPort() {
        return port;
    }

    public ProviderManager getProviderManager() {
        return this.providerManager;
    }

    public EndpointManager getEndpointManager() {
        return endpointManager;
    }

    @Override
    public List<HttpClient> getActiveConnections() {
        return Collections.unmodifiableList(activeConnections);
    }

    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public String getBindingIP() {
        return bindingIP;
    }

    @Override
    public void setBindingIP(String bindingIP) {
        this.bindingIP = bindingIP;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }

    public WorkerGroup getWorkerGroup() {
        return workerGroup;
    }

    public Set<PostProcessor> getPostProcessors() {
        return Collections.unmodifiableSet(postProcessors);
    }

    public Set<Provider> getPreProcessors() {
        return Collections.unmodifiableSet(preProcessors);
    }

    public Consumer<HttpClient> getClientConnectHook() {
        return this::onConnect;
    }

    public Consumer<HttpClient> getClientDisconnectHook() {
        return this::onDisconnect;
    }

    public void setHookStart(Runnable hookStart) {
        this.hookStart = Objects.requireNonNull(hookStart);
    }

    @Override
    public void setSecurityPolicy(SecurityPolicy securityPolicy) {
        Objects.requireNonNull(securityPolicy);
        if(!(securityPolicy instanceof HttpSecurityPolicy))
            throw new RuntimeException("SecurityPolicy must be of type HttpSecurityPolicy!");
        this.securityPolicy = (HttpSecurityPolicy) securityPolicy;
    }
}