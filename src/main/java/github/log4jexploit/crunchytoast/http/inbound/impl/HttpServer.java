/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.inbound.impl;

import github.log4jexploit.crunchytoast.general.CommonText;
import github.log4jexploit.crunchytoast.general.LockNotify;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.general.WorkerGroup;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpClient;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.provider.EndpointManager;
import github.log4jexploit.crunchytoast.http.provider.EndpointManagerImpl;
import github.log4jexploit.crunchytoast.http.provider.ProviderManager;
import github.log4jexploit.crunchytoast.http.provider.ProviderManagerImpl;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.http.util.SecurityPolicy;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.server.Client;
import github.log4jexploit.crunchytoast.server.Server;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.BindException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;

public abstract class HttpServer implements Server {

    private final LockNotify lock;
    private final WorkerGroup workerGroup;
    private final CopyOnWriteArrayList<HttpClient> activeConnections;
    private final EndpointManager endpointManager;
    private final ProviderManager providerManager;

    final int port;
    ServerSocket serverSocket;
    String bindingIP;
    Logger logger;

    private HttpSecurityPolicy securityPolicy;
    private HttpEventHandler eventHandler;
    private Thread handler;

    private volatile boolean initialized;
    private volatile boolean alive;


    HttpServer(int port) {
        this(port, "127.0.0.1");
    }

    HttpServer(int port, String bindingIP) {
        this.port = port;
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.eventHandler = new HttpEventHandler() {};

        this.workerGroup = new WorkerGroup(6);
        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.endpointManager = new EndpointManagerImpl(this);
        this.providerManager = new ProviderManagerImpl();
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.initialized = false;
        this.lock = new LockNotify();
        this.bindingIP = bindingIP;

        this.providerManager.register(this.endpointManager);
    }

    /**
     * Generates and initializes a {@link ServerSocket}
     * @throws IOException Is thrown when binding to a specific port or address fails
     */
    abstract void createServerSocket() throws IOException;

    /**
     * Prepare the server for startup
     */
    private void initialize() {
        try {
            this.createServerSocket();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        handler = new Thread(this::launch);
        this.initialized = true;
        this.alive = false;
    }

    private void launch() {
        try {
            alive = true;
            logger.info(CommonText.SERVER_STARTED.apply(this));
            while (this.alive) {
                spin();
            }
        } catch (Exception e) {
            this.onError(e);
        } finally {
            this.initialized = false;
            this.alive = false;
            this.closeRemaining();
            this.close();
        }
    }

    private void closeRemaining() {
        int remaining = activeConnections.size();
        activeConnections.forEach(Client::close);
        logger.warn(CommonText.SERVER_CLOSED_REMAINING.apply(new Pair<>(this, remaining)));
    }

    private void onError(Exception e) {
        if(e instanceof BindException) {
            logger.alert(CommonText.SERVER_PORT_FAIL.apply(this));
            return;
        }

        logger.alert(CommonText.SERVER_CRASH.apply(this));
        logger.alertError(e);
    }

    /**
     * Accepts new clients
     * @throws IOException in case something goes wrong
     */
    private void spin() throws IOException {
        cleanUp();

        // If the connection limit has been reached, do not accept new connections
        final long max = this.securityPolicy.getMaxConnections();

        if(max > 0 && this.activeConnections.size() > max) {
            lock.waitForWake();
        }

        Socket socket = this.serverSocket.accept();
        HttpClient connection = new HttpClientImpl(socket, this);
        this.onConnect(connection);
        connection.start();
    }

    /**
     * Remove all inactive clients
     */
    private void cleanUp() {
        new ArrayList<>(this.activeConnections).forEach((client) -> {
            if(client.isAlive())
                return;
            client.close();
            onDisconnect(client);
        });
    }

    void onDisconnect(HttpClient client) {
        if(!this.alive)
            return;

        Objects.requireNonNull(client);
        this.logger.info(CommonText.IN_CLIENT_DISCONNECT.apply(client));
        this.activeConnections.remove(client);
        this.lock.wakeAll();
        new Thread(() -> this.eventHandler.onDisconnect(client)).start();
    }

    void onConnect(HttpClient client) {
        if(!this.alive)
            return;

        Objects.requireNonNull(client);
        this.logger.info(CommonText.IN_CLIENT_CONNECT.apply(client));
        this.activeConnections.add(client);
        new Thread(() -> this.eventHandler.onConnect(client)).start();
    }

    /**
     * Starts the server
     */
    @Override
    public void start() {
        if(this.alive) {
            return;
        }

        this.initialize();

        if(!initialized) {
            throw new RuntimeException("Initialization failed, aborting!");
        }

        handler.start();
    }

    @Override
    public void close() {
        if(!alive)
            return;

        try {
            alive = false;
            this.handler.interrupt();
            serverSocket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = Objects.requireNonNull(eventHandler);
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public int getPort() {
        return port;
    }

    public ProviderManager getProviderManager() {
        return this.providerManager;
    }

    public EndpointManager getEndpointManager() {
        return endpointManager;
    }

    @Override
    public List<HttpClient> getActiveConnections() {
        return new ArrayList<>(activeConnections);
    }

    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public String getBindingIP() {
        return bindingIP;
    }

    @Override
    public void setBindingIP(String bindingIP) {
        this.bindingIP = bindingIP;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }

    public WorkerGroup getWorkerGroup() {
        return workerGroup;
    }

    @Override
    public void setSecurityPolicy(SecurityPolicy securityPolicy) {
        Objects.requireNonNull(securityPolicy);
        if(!(securityPolicy instanceof HttpSecurityPolicy))
            throw new RuntimeException("SecurityPolicy must be of type HttpSecurityPolicy!");
        this.securityPolicy = (HttpSecurityPolicy) securityPolicy;
    }
}