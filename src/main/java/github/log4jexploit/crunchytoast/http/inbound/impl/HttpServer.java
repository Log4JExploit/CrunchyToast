/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.inbound.impl;

import github.log4jexploit.crunchytoast.general.Client;
import github.log4jexploit.crunchytoast.general.Server;
import github.log4jexploit.crunchytoast.http.endpoint.EndpointManager;
import github.log4jexploit.crunchytoast.http.endpoint.EndpointManagerImpl;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpClient;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;

import java.io.File;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.BindException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public abstract class HttpServer implements Server {

    private final CopyOnWriteArrayList<HttpClient> activeConnections;
    private final EndpointManager endpointManager;

    final int port;
    ServerSocket serverSocket;
    String bindingIP;
    Logger logger;

    private HttpSecurityPolicy securityPolicy;
    private HttpEventHandler eventHandler;
    private Thread clientHandlerThread;

    private volatile boolean initialized;
    private volatile boolean alive;


    HttpServer(int port) {
        this(port, "127.0.0.1");
    }

    HttpServer(int port, String bindingIP) {
        this.port = port;
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.eventHandler = new HttpEventHandler() {};

        String path = Path.of("").toAbsolutePath().toString();
        File resourcesFolder = new File(path+File.separator+"resources");

        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.endpointManager = new EndpointManagerImpl(resourcesFolder, this);
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.initialized = false;
        this.bindingIP = null;
    }

    /**
     * Generates and initializes a {@link ServerSocket}
     * @throws IOException Is thrown when binding to a specific port or address fails
     */
    abstract void createServerSocket() throws IOException;

    /**
     * Prepare the server for startup
     */
    private void initialize() {
        try {
            this.createServerSocket();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        clientHandlerThread = new Thread(this::launch);
        this.initialized = true;
        this.alive = false;
    }

    private void launch() {
        try {
            alive = true;
            logger.info("Waiting for connections...");
            while (this.alive) {
                spin();
            }
        } catch (BindException e) {
            logger.alert("Port " + port + " is already in use!");
        } catch (IOException e) {
            logger.alert("Server terminated, IO/Error: "+e.getMessage());
            logger.alertError(e);
        } catch (Exception e) {
            logger.debugError(e);
        } finally {
            logger.warn("Server closed.");
            logger.warn("Shutting down...");

            this.initialized = false;
            this.alive = false;

            int remaining = activeConnections.size();
            activeConnections.forEach(Client::close);

            logger.warn("Closed "+remaining+" remaining connections!");
            this.close();
        }
    }

    /**
     * Accepts new clients
     * @throws IOException in case something goes wrong
     */
    private void spin() throws IOException {
        cleanUp();

        // If the connection limit has been reached, do not accept new connections
        final long max = this.securityPolicy.getMaxConnections();

        if(max > 0) {
            while(this.activeConnections.size() >= max) {
                Thread.onSpinWait();
            }
        }

        Socket socket = this.serverSocket.accept();
        HttpClient connection = new HttpClientImpl(socket, this);
        connection.start();
    }

    /**
     * Remove all inactive clients
     */
    private void cleanUp() {
        new ArrayList<>(this.activeConnections).forEach((client) -> {
            if(!client.isAlive() && !client.isFree()) {
                client.close();
                onDisconnect(client);
            }
        });
    }

    void onDisconnect(HttpClient client) {
        this.logger.info(client.getAddress()+" disconnected");
        this.activeConnections.remove(client);
        new Thread(() -> this.eventHandler.onDisconnect(client)).start();
    }

    void onConnect(HttpClient client) {
        this.logger.info(client.getAddress()+" connected");
        this.activeConnections.add(client);
        new Thread(() -> this.eventHandler.onConnect(client)).start();
    }

    /**
     * Starts the server
     */
    @Override
    public void start() {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.initialize();

        if(!initialized) {
            throw new RuntimeException("Initialization failed, aborting!");
        }

        clientHandlerThread.start();
    }

    @Override
    public void close() {
        if(!alive)
            return;

        try {
            alive = false;
            this.clientHandlerThread.interrupt();
            serverSocket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public void setEventHandler(HttpEventHandler eventHandler) {
        if(eventHandler == null)
            throw new IllegalArgumentException("Illegal argument: EventHandler cannot be null!");
        this.eventHandler = eventHandler;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public int getPort() {
        return port;
    }

    public EndpointManager getEndpointManager() {
        return endpointManager;
    }

    @Override
    public List<HttpClient> getActiveConnections() {
        return new ArrayList<>(activeConnections);
    }

    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }

    @Override
    public void setSecurityPolicy(HttpSecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy;
    }
}