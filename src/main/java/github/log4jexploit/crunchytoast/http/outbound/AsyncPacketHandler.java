/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.outbound;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Async;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.logger.inf.Logger;

import java.io.IOException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.Deque;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.function.Consumer;

public class AsyncPacketHandler implements Runnable {

    private final HttpOutboundClient client;
    private final Logger logger;
    private volatile HttpRequest last;
    private final Deque<Pair<HttpRequest, Consumer<HttpResponse>>> packetQueue;


    public AsyncPacketHandler(HttpOutboundClient outboundClient) {
        this.packetQueue = new ConcurrentLinkedDeque<>();
        this.client = outboundClient;
        this.logger = client.getLogger();
        this.last = null;
    }


    @Override
    public void run() {
        try {
            execute();
            client.socket.close();
        }
        catch (HttpProtocolException e) {
            logger.alert("Http protocol violated: " + e.getMessage());
            logger.alertError(e);
        } catch (SocketTimeoutException e) {
            logger.alert("Connection to "+client.ip+":"+client.port+" timed out!");
            logger.alertError(e);
        } catch (SocketException e) {
            logger.alert("Unable to connect to "+client.ip+":"+client.port+": "+e.getMessage());
            logger.alertError(e);
        } catch (IOException e) {
            logger.debugError(e);
        } catch (Exception e) {
            logger.alert("An error occurred: "+e.getMessage());
            logger.alertError(e);
        } finally {
            logger.alert("Connection closed. Shutting down...");

            client.initialized = false;
            client.alive = false;
            packetQueue.clear();

            new Thread(() -> client.eventHandler.onDisconnect(client))
                    .start();
        }
    }

    public void execute() {
        while (client.alive) {
            while (this.packetQueue.isEmpty() && client.alive) {
                Thread.onSpinWait();
            }

            if(!client.alive || client.socket.isClosed())
                break;

            final HttpResponse response = HttpResponse.createDefault();
            handleNext(response);

            while(!response.isSendingComplete())
                Thread.onSpinWait();

            if(!response.isKeepAlive())
                break;
        }

        client.alive = false;
    }

    public void handleNext(HttpResponse response) {
        response.setSecurityPolicy(HttpSecurityPolicy.unrestricted());
        IBodyContentHandler content = response.receive(client);
        Pair<HttpRequest, Consumer<HttpResponse>> request;

        synchronized (this.packetQueue) {
            request = this.packetQueue.poll();
        }

        if (request == null)
            throw new RuntimeException("Queue contains null value!");

        try {
            Thread callbackThread = new Thread(() -> request.getValueB().accept(response));
            callbackThread.start();
            callbackThread.join();
        } catch (Exception ignored) {}

        content.onFlushRemaining();
    }

    /**
     * Sends a request to other party and enqueues the callback
     * @param request the request
     * @param callback callback to invoke upon arrival of the response
     * @apiNote This method call might block, if the previous request hasn't finished sending yet
     */
    @Async
    public IBodyContentWriter send(HttpRequest request, Consumer<HttpResponse> callback) {
        synchronized (this.packetQueue) {
            while(last != null && !last.isSendingComplete())
                Thread.onSpinWait();

            this.packetQueue.add(new Pair<>(request, callback));
            last = request;
            return request.send(this.client);
        }
    }
}
