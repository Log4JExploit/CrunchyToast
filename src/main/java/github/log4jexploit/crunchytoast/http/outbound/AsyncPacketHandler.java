/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.outbound;

import github.log4jexploit.crunchytoast.annotation.Async;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;

import java.io.IOException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.Deque;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.function.Consumer;

public class AsyncPacketHandler implements Runnable {

    private final HttpOutboundClient client;
    private volatile HttpRequest last;
    private final Deque<Pair<HttpRequest, Consumer<HttpResponse>>> packetQueue;


    public AsyncPacketHandler(HttpOutboundClient outboundClient) {
        this.packetQueue = new ConcurrentLinkedDeque<>();
        this.client = outboundClient;
        this.last = null;
    }


    @Override
    public void run() {
        try {
            execute();
            client.socket.close();
        }
        catch (HttpProtocolException e) {
            client.getLogger().alert("Http protocol violated: " + e.getMessage());
            client.getLogger().alertError(e);
        } catch (SocketTimeoutException e) {
            client.getLogger().alert("Connection to " + client.ip + ":" + client.port + " timed out!");
            client.getLogger().alertError(e);
        } catch (SocketException e) {
            client.getLogger().alert("Unable to connect to " + client.ip + " on port " + client.port + ": " + e.getMessage());
            client.getLogger().alertError(e);
        } catch (IOException e) {
            client.getLogger().debugError(e);
        } catch (Exception e) {
            client.getLogger().alert("An error occurred: " + e.getMessage());
            client.getLogger().alertError(e);
        } finally {
            client.getLogger().alert("Connection closed. Shutting down...");
            client.initialized = false;
            client.alive = false;
            packetQueue.clear();

            new Thread(() ->
                    client.eventHandler.onDisconnect(client)
            ).start();
        }
    }

    private void execute() {
        while (client.alive) {
            while (this.packetQueue.isEmpty()) {
                if(!client.alive)
                    return;
                Thread.onSpinWait();
            }

            final HttpResponse response = HttpResponse.createDefault();
            handleNext(response);

            while(!response.isSendingComplete())
                Thread.onSpinWait();

            if(!response.isKeepAlive())
                break;
        }

        client.alive = false;
    }

    private void handleNext(HttpResponse response) {
        response.setSecurityPolicy(this.client.getSecurityPolicy());
        IBodyContentHandler content = response.receive(client);
        Pair<HttpRequest, Consumer<HttpResponse>> request;

        synchronized (this.packetQueue) {
            request = this.packetQueue.poll();
        }

        if (request == null)
            throw new RuntimeException("Queue contains null value!");

        try {
            Thread callbackThread = new Thread(() -> request.getValueB().accept(response));
            callbackThread.start();
            callbackThread.join();
        } catch (Exception ignored) {
            if(Thread.interrupted())
                Thread.currentThread().interrupt();
        }
        content.onFlushRemaining();
    }

    /**
     * Sends a request to other party and enqueues the callback
     * @param request the request
     * @param callback callback to invoke upon arrival of the response
     * @apiNote This method call might block, if the previous request hasn't finished sending yet
     */
    @Async
    public IBodyContentWriter send(HttpRequest request, Consumer<HttpResponse> callback) {
        synchronized (this.packetQueue) {
            while(last != null && !last.isSendingComplete())
                Thread.onSpinWait();

            this.packetQueue.add(new Pair<>(request, callback));
            last = request;
            return request.send(this.client);
        }
    }
}
