/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.outbound;

import github.log4jexploit.crunchytoast.exceptions.ConnectionClosedException;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.HttpCallback;
import github.log4jexploit.crunchytoast.general.HttpSendProcess;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;

import javax.net.SocketFactory;
import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.ArrayDeque;

// Coded by Zadex at 23/10/2022
public final class HttpOutboundClientImpl implements HttpOutboundClient {

    private final ArrayDeque<Pair<HttpRequest, HttpCallback>> packetQueue;
    private final Logger logger;
    private final String ip;
    private final int port;

    private InputStream in;
    private OutputStream out;

    private HttpEventHandler eventHandler;
    private boolean alive, initialized;
    private Thread listener, connector;
    private Socket socket;
    private String bindingIP;


    public HttpOutboundClientImpl(String ip, int port) {
        this.ip = ip;
        this.port = port;
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.packetQueue = new ArrayDeque<>();
        this.bindingIP = "127.0.0.1";
    }

    private void createSocket() throws IOException {
        this.socket = SocketFactory.getDefault().createSocket();
        this.socket.bind(new InetSocketAddress(0));
    }

    private void init() {
        try {
            this.createSocket();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        if(this.eventHandler == null) {
            this.eventHandler = new HttpEventHandler() {};
        }

        this.connector = new Thread(() -> {
            try {
                this.logger.info("Connecting...");
                this.socket.connect(new InetSocketAddress(this.ip, this.port));
                this.in = this.socket.getInputStream();
                this.out = this.socket.getOutputStream();
                this.alive = true;
                this.logger.info("Connection established!");

                new Thread(() -> this.eventHandler.onConnect(HttpOutboundClientImpl.this)).start();
                this.listener.start();
            } catch (Exception e) {
                new Thread(() -> this.eventHandler.onDisconnect(HttpOutboundClientImpl.this)).start();
            }
        });

        this.listener = new Thread(() -> {
            try {
                HttpResponse response;
                BufferedReader reader = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));

                while (this.alive) {
                    while (this.packetQueue.isEmpty()) {
                        Thread.onSpinWait();
                    }

                    if(!this.alive || this.socket.isClosed())
                        break;

                    response = HttpResponse.createDefault();
                    IBodyContentHandler bodyContentHandler = response.receive(this);

                    Pair<HttpRequest, HttpCallback> request;
                    synchronized (this.packetQueue) {
                        request = this.packetQueue.poll();
                    }

                    if (request == null)
                        throw new Exception("Queue contains null value!");

                    HttpResponse finalResponse = response;

                    try {
                        Thread callback = new Thread(() -> request.getValueB().onCallback(finalResponse, bodyContentHandler));
                        callback.start();
                        callback.join();

                        bodyContentHandler.onFlushRemaining();
                    } catch (Exception ignored) {
                        break;
                    }

                    if(!response.getHeaders().containsKey(Http.HeaderType.CONNECTION))
                        break;

                    if(!response.getHeader(Http.HeaderType.CONNECTION).equalsIgnoreCase("keep-alive"))
                        break;
                }
                this.alive = false;
                reader.close();
            } catch (HttpProtocolException e) {
                this.logger.alert("Http protocol violated: " + e.getMessage());
                this.logger.alertError(e);
            } catch (SocketTimeoutException e) {
                this.logger.alert("Connection to "+this.ip+":"+this.port+" timed out!");
                this.logger.alertError(e);
            } catch (SocketException e) {
                this.logger.alert("Unable to connect to "+this.ip+":"+this.port+": "+e.getMessage());
                this.logger.alertError(e);
            } catch (IOException e) {
                this.logger.alert("Connection terminated, IO/Error: "+e.getMessage());
                this.logger.alertError(e);
            } catch (Exception e) {
                this.logger.alert("An error occurred: "+e.getMessage());
                this.logger.alertError(e);
            } finally {
                this.logger.alert("Shutting down...");

                this.initialized = false;
                this.packetQueue.clear();
                this.close();
                this.alive = false;

                new Thread(() -> this.eventHandler.onDisconnect(HttpOutboundClientImpl.this)).start();
                this.logger.alert("Stopped!");
            }
        });

        this.initialized = true;
    }

    @Override
    public void startAndJoin() throws InterruptedException {
        start();

        if(!this.connector.isAlive())
            return;

        this.connector.join();
    }

    @Override
    public void start() {
        if(alive) {
            logger.warn("Server already started!");
            return;
        }

        this.init();

        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        this.connector.start();
    }

    @Override
    public void close() {
        if(!alive)
            return;

        try {
            alive = false;
            listener.interrupt();
            socket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public void send(HttpRequest request, HttpSendProcess sendProcess, HttpCallback callback) throws HttpProtocolException, ConnectionClosedException {
        try {
            if (!this.alive || this.socket.isClosed())
                throw new HttpProtocolException("Client is not connected!");
            synchronized (this.packetQueue) {
                this.packetQueue.add(new Pair<>(request, callback));
                IBodyContentHandler contentCoder = request.send(this);
                if(sendProcess != null)
                    sendProcess.sendRequest(contentCoder);
                contentCoder.onFlushRemaining();
            }
        } catch (Exception e) {
            throw new HttpProtocolException("Request couldn't be converted: " + e.getMessage());
        }
    }

    @Override
    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    @Override
    public void setBindingIP(String ip) {
        this.bindingIP = ip;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public boolean isConnected() {
        return this.alive && this.socket != null && !this.socket.isClosed();
    }

    @Override
    public String getIP() {
        return this.socket.getRemoteSocketAddress().toString();
    }

    @Override
    public String getBindingIP() {
        return this.bindingIP;
    }

    @Override
    public int getPort() {
        return this.port;
    }

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }
}
