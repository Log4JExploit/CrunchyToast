/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.outbound;

import github.log4jexploit.crunchytoast.annotation.Async;
import github.log4jexploit.crunchytoast.annotation.Sync;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.LockNotify;
import github.log4jexploit.crunchytoast.general.Version;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.server.Client;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

public abstract class HttpOutboundClient implements Client {

    private final AsyncPacketHandler packetHandler;
    private HttpSecurityPolicy securityPolicy;
    private String bindingIP;

    private Thread packetHandlerThread;
    private Thread connectThread;

    volatile boolean initialized;
    volatile boolean alive;

    final Logger logger;
    String ip;
    int port;

    HttpEventHandler eventHandler;
    OutputStream out;
    InputStream in;
    Socket socket;


    HttpOutboundClient(String ip, int port, String bindingIP) {
        this(ip, port);
        this.bindingIP = bindingIP;
    }

    HttpOutboundClient(String ip, int port) {
        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.eventHandler = new HttpEventHandler() {};
        this.bindingIP = "127.0.0.1";
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.packetHandler = new AsyncPacketHandler(this);
        this.port = port;
        this.ip = ip;
    }

    HttpOutboundClient(String bindingIP) {
        this(null, -1, bindingIP);
    }

    HttpOutboundClient() {
        this(null, -1);
    }


    abstract void createSocket() throws IOException;

    void init() {
        try {
            createSocket();
            this.connectThread = new Thread(this::connect);
            this.initialized = true;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void connect() {
        try {
            this.logger.info("Connecting...");
            this.socket.connect(new InetSocketAddress(this.ip, this.port));
            this.in = this.socket.getInputStream();
            this.out = this.socket.getOutputStream();
            this.alive = true;
            this.logger.info("Connection established!");

            new Thread(() -> this.eventHandler.onConnect(HttpOutboundClient.this)).start();

            this.packetHandlerThread = new Thread(this.packetHandler);
            this.packetHandlerThread.start();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            new Thread(() -> this.eventHandler.onDisconnect(HttpOutboundClient.this)).start();
        }
    }

    @Sync
    public void startAndJoin() throws InterruptedException {
        start();

        if(!this.connectThread.isAlive())
            return;

        this.connectThread.join();
    }

    @Override
    public void start() {
        if(alive) {
            logger.warn("Client already up and running!");
            return;
        }

        this.init();
        this.connectThread.start();
    }

    @Override
    public void close() throws UncheckedIOException {
        if(!alive)
            return;

        try {
            alive = false;
            if(this.connectThread.isAlive())
                this.connectThread.interrupt();

            if(this.packetHandlerThread.isAlive())
                this.packetHandlerThread.interrupt();

            this.socket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    /**
     * Sends a request to the destination and awaits their response.
     * This call will block until the response is fully read
     * @param request the request
     * @return The response from the origin server
     */
    @Sync
    public HttpResponse awaitFetch(HttpRequest request) {
        checkClientConnected();
        LockNotify lock = new LockNotify();
        AtomicReference<HttpResponse> reference = new AtomicReference<>();

        this.packetHandler.send(request, (response -> {
            reference.set(response);
            lock.wakeAll();
        })).onFlushRemaining();

        lock.waitForWake();
        return reference.get();
    }

    @Async
    public void fetch(HttpRequest request, Consumer<HttpResponse> callback) {
        checkClientConnected();
        IBodyContentWriter writer = this.packetHandler.send(request, callback);
        writer.onFlushRemaining();
    }

    private void checkClientConnected() {
        if (!this.alive || this.socket.isClosed() || !this.initialized)
            throw new HttpProtocolException("Client is not connected!");
    }

    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setBindingIP(String ip) {
        this.bindingIP = ip;
    }

    public boolean isAlive() {
        return this.alive;
    }

    public boolean isConnected() {
        return this.alive && this.socket != null && !this.socket.isClosed();
    }

    @Override
    public String getAddress() {
        return this.ip;
    }

    @Override
    public String getAddressResolved() {
        return this.socket.getInetAddress().getHostAddress();
    }

    public String getBindingIP() {
        return this.bindingIP;
    }

    public int getPort() {
        return this.port;
    }

    public Logger getLogger() {
        return logger;
    }

    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }


    public static HttpResponse awaitFetch(String url) {
        Object[] urlProperties = getURLProperties(url);
        HttpOutboundClient outboundClient = null;

        try {
            outboundClient = HttpClientBuilder.build(
                    (String) urlProperties[1],
                    (Integer) urlProperties[2],
                    (String) urlProperties[0]
            );

            outboundClient.start();

            while(!outboundClient.isAlive()) {
                Thread.onSpinWait();
            }

            HttpRequest request = HttpRequest.createDefault();
            request.setRequestURI((String) urlProperties[3]);
            request.setCustomHeader("Accept", "*/*");
            request.setAcceptEncodings(new Http.Encoding[]{Http.Encoding.GZIP, Http.Encoding.DEFLATE});
            request.setAcceptLanguages(new Http.Language[] {Http.Language.EN, Http.Language.EN_US});
            request.setUserAgent("CrunchyToast/"+Version.getVersion());
            request.setHost((String) urlProperties[1]);
            request.setKeepAlive(false);

            return outboundClient.awaitFetch(request);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            if(outboundClient != null && outboundClient.isAlive()) {
                outboundClient.close();
            }
        }
    }

    private static Object[] getURLProperties(String url) {
        if(url.isBlank())
            throw new IllegalArgumentException();

        String protocol = url.split(":")[0];
        String link = url.split("//")[1];
        String domain = link.split("/")[0];
        String uri = link.substring(link.indexOf('/'));

        if(domain.isBlank()) {
            throw new IllegalArgumentException("Domain/IP couldn't be identified!");
        }

        int port;
        switch (protocol.toLowerCase()) {
            case "https" -> port = 443;
            case "http" -> port = 80;
            default -> throw new IllegalArgumentException("Unsupported protocol!");
        }

        if(domain.contains(":")) {
            port = Integer.parseInt(domain.split(":")[1]);
            domain = domain.split(":")[0];
        }

        return new Object[] {protocol.toUpperCase(), domain, port, uri};
    }

    public void setSecurityPolicy(HttpSecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return securityPolicy;
    }
}
