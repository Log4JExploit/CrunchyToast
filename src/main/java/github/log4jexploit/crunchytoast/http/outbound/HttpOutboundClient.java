/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.outbound;

import github.log4jexploit.crunchytoast.exceptions.ConnectionClosedException;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.*;
import github.log4jexploit.crunchytoast.http.inbound.inf.HttpEventHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

public abstract class HttpOutboundClient implements Client {

    private final AsyncPacketHandler packetHandler;
    private String bindingIP;

    private Thread packetHandlerThread;
    private Thread connectThread;

    volatile boolean initialized;
    volatile boolean alive;

    final Logger logger;
    final String ip;
    final int port;

    HttpEventHandler eventHandler;
    OutputStream out;
    InputStream in;
    Socket socket;


    HttpOutboundClient(String ip, int port) {
        this.logger = new LoggerTimeImpl(System.out, this.getClass());
        this.eventHandler = new HttpEventHandler() {};
        this.bindingIP = "127.0.0.1";
        this.packetHandler = new AsyncPacketHandler(this);
        this.port = port;
        this.ip = ip;
    }


    abstract void createSocket() throws IOException;

    void init() {
        try {
            createSocket();
            this.connectThread = new Thread(this::connect);
            this.initialized = true;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void connect() {
        try {
            this.logger.info("Connecting...");
            this.socket.connect(new InetSocketAddress(this.ip, this.port));
            this.in = this.socket.getInputStream();
            this.out = this.socket.getOutputStream();
            this.alive = true;
            this.logger.info("Connection established!");

            new Thread(() -> this.eventHandler.onConnect(HttpOutboundClient.this)).start();

            this.packetHandlerThread = new Thread(this.packetHandler);
            this.packetHandlerThread.start();
        } catch (Exception e) {
            new Thread(() -> this.eventHandler.onDisconnect(HttpOutboundClient.this)).start();
        }
    }

    @Sync
    public void startAndJoin() throws InterruptedException {
        start();

        if(!this.connectThread.isAlive())
            return;

        this.connectThread.join();
    }

    @Override
    public void start() {
        if(alive) {
            logger.warn("Client already up and running!");
            return;
        }

        this.init();
        this.connectThread.start();
    }

    @Override
    public void close() throws UncheckedIOException {
        if(!alive)
            return;

        try {
            alive = false;
            if(this.connectThread.isAlive())
                this.connectThread.interrupt();

            if(this.packetHandlerThread.isAlive())
                this.packetHandlerThread.interrupt();

            this.socket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Async
    @Deprecated
    void send(HttpRequest request, HttpSendProcess sendProcess, HttpCallback callback) throws HttpProtocolException, ConnectionClosedException {
        if (!this.alive || this.socket.isClosed() || !this.initialized)
            throw new HttpProtocolException("Client is not connected!");

        final IBodyContentWriter writer = this.packetHandler.send(request, (response ->
                callback.onCallback(response, response.getBodyContentHandler()))
        );

        sendProcess.sendRequest(writer);
    }

    /**
     * Sends a request to the destination and awaits their response.
     * This call will block until the response is fully read
     * @param request
     * @return
     */
    @Sync
    public HttpResponse awaitFetch(HttpRequest request) {
        if (!this.alive || this.socket.isClosed() || !this.initialized)
            throw new HttpProtocolException("Client is not connected!");

        LockQueue lock = new LockQueue();
        AtomicReference<HttpResponse> reference = new AtomicReference<>();

        IBodyContentWriter writer = this.packetHandler.send(request, (response -> {
            reference.set(response);
            lock.wakeAll();
        }));

        try {
            writer.onFlushRemaining();
            lock.waitForWake();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        return reference.get();
    }

    @Async
    public void fetch(HttpRequest request, Consumer<HttpResponse> callback) {
        if (!this.alive || this.socket.isClosed() || !this.initialized)
            throw new HttpProtocolException("Client is not connected!");

        IBodyContentWriter writer = this.packetHandler.send(request, callback);
        writer.onFlushRemaining();
    }

    public void setEventHandler(HttpEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setBindingIP(String ip) {
        this.bindingIP = ip;
    }

    public boolean isAlive() {
        return this.alive;
    }

    public boolean isConnected() {
        return this.alive && this.socket != null && !this.socket.isClosed();
    }

    @Override
    public String getAddress() {
        return this.ip;
    }

    @Override
    public String getAddressResolved() {
        return this.socket.getInetAddress().getHostAddress();
    }

    public String getBindingIP() {
        return this.bindingIP;
    }

    public int getPort() {
        return this.port;
    }

    public Logger getLogger() {
        return logger;
    }

    public HttpEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.out;
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }

}
