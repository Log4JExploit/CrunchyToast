/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.endpoint;

import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Function;
import java.util.function.Supplier;

public class HandlerResultHelper {

    private static final Map<Class<?>, Function<Object, HttpResponse>> registry;
    private static final Function<Object, HttpResponse> defaultFunction;
    private static final Supplier<HttpResponse> nullFunction;

    static {
        registry = new HashMap<>();

        defaultFunction = object -> HttpResponse.compose()
                .withCode(Http.ResponseCode.OK)
                .withResponse(object.toString())
                .build();

        nullFunction = () -> HttpResponse.compose()
                .withCode(Http.ResponseCode.OK)
                .build();

        registry.put(Collection.class, (object) -> {
            String arrayString = Arrays.toString(((Collection<?>) object).toArray());
            return HttpResponse.Builder
                    .compose()
                    .withCode(Http.ResponseCode.OK)
                    .withResponse(arrayString)
                    .build();
        });

        registry.put(HttpResponse.class, (object) -> (HttpResponse) object);

        registry.put(LocalDate.class, object -> HttpResponse.compose()
                .withCode(Http.ResponseCode.OK)
                .withResponse(((LocalDate) object).format(DateTimeFormatter.RFC_1123_DATE_TIME))
                .build());

        registry.put(Object[].class, (object) -> {
            String arrayString = Arrays.toString((Object[])object);
            return HttpResponse.Builder
                    .compose()
                    .withCode(Http.ResponseCode.OK)
                    .withResponse(arrayString)
                    .build();
        });
    }

    public static HttpResponse createResult(Object object) {
        if(object == null)
            return nullFunction.get();

        Function<Object, HttpResponse> function = registry.get(object.getClass());

        if(function == null) {
            for(Class<?> clazz : registry.keySet()) {
                if(List.of(object.getClass().getInterfaces()).contains(clazz)) {
                    function = registry.get(clazz);
                    break;
                }
                if(object.getClass().isArray() && clazz.isArray()) {
                    function = registry.get(clazz);
                    break;
                }
            }
        }

        if(function == null)
            function = defaultFunction;

        return function.apply(object);
    }

    private static boolean hasSuper(Object object, Class<?> clazz) {
        return clazz.isAssignableFrom(object.getClass());
    }

}
