/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.endpoint;

import github.log4jexploit.crunchytoast.exceptions.HttpEndpointException;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Client;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.general.Server;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyChunked;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;

import java.io.File;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;


public class EndpointManagerImpl implements EndpointManager {

    private final ArrayList<EndpointHandler> handlers;
    private final Server server;
    private File resourceFolder;


    public EndpointManagerImpl(File resourceFolder, Server server) {
        this.handlers = new ArrayList<>();
        this.resourceFolder = resourceFolder;
        this.server = server;
    }


    @Override
    public HttpResponse delegateRequest(HttpRequest request) throws HttpProtocolException {
        String uri = request.getRequestURI().split("\\?")[0];
        HttpResponse response = findHandler(request, uri);

        if(response != null)
            return response;

        HttpResource resource = findResource(request.getRequestURI());

        if(resource != null) {
            return sendResourceFile(request.getClient(), resource);
        }

        return HttpResponse.compose()
                .withCode(Http.ResponseCode.NOT_FOUND)
                .build();
    }

    @Override
    public HttpResource findResource(String requestURI) {
        Http.ContentType contentType = Http.ContentType.BIN;
        File file = new File(
                this.resourceFolder.getAbsolutePath() +
                        requestURI.split("\\?")[0]
        );

        if(!file.exists() || file.isDirectory())
            return null;

        if(!file.getAbsolutePath().startsWith(resourceFolder.getAbsolutePath())) {
            return null;
        }

        if (file.getName().contains("."))
            contentType = Http.ContentType.byAlias(file.getName().split("\\.")[1]);

        return new HttpResourceDynamic(file, contentType);
    }

    @Override
    public void reverseProxy(String inbound, String outbound, int port, String scheme) {
        if(!"HTTP".equalsIgnoreCase(scheme) && !"HTTPS".equalsIgnoreCase(scheme))
            throw new IllegalArgumentException("Illegal scheme: May only be HTTP or HTTPS");


    }

    @Override
    public void registerHandler(Object instance) {
        for(Method method : instance.getClass().getDeclaredMethods()) {
            if(method.isAnnotationPresent(HttpEndpoint.class))
                registerMethod(instance, method);
        }
    }

    @Override
    public void unregisterHandler(Object instance) {
        for(EndpointHandler endpointHandler : List.copyOf(handlers))
            if(endpointHandler.getInstance().getClass().isInstance(instance))
                handlers.remove(endpointHandler);
    }

    @Override
    public void setResourceFolder(String path) {
        this.resourceFolder = new File(path);
    }

    @Override
    public ArrayList<Object> getHandlers() {
        return new ArrayList<>(this.handlers);
    }

    @Override
    public File getResourceFolder() {
        return this.resourceFolder;
    }

    public Server getServer() {
        return this.server;
    }

    private HttpResponse sendResourceFile(Client client, HttpResource resource) {
        HttpResponse response = HttpResponse.compose().withCode(Http.ResponseCode.OK).build();
        response.setContent(resource);
        response.setChunkedTransfer(true);

        IBodyChunked.Writer bodyWriter = (IBodyChunked.Writer) response.send(client);
        transfer(bodyWriter, resource);

        return response;
    }

    private void transfer(IBodyChunked.Writer bodyWriter, HttpResource resource) {
        UncheckedIOReader reader = new UncheckedIOReader(resource.getDataAsStream());
        byte[] buf = new byte[1024 * 64];
        int len;

        do {
            len = reader.readNBytes(buf, 0, buf.length);
            if(len < 1)
                break;
            bodyWriter.writeNextChunk(buf, 0, len);
        } while(len == buf.length);

        bodyWriter.onFlushRemaining();
    }

    private HttpResponse findHandler(HttpRequest request, String uri) {
        EndpointHandler target = null;

        for(EndpointHandler handler : handlers) {
            if(!handler.getRequestType().equals(request.getRequestType()))
                continue;
            if(!handler.getURI().equalsIgnoreCase(uri))
                continue;
            target = handler;
            break;
        }

        return target != null ? callHandler(request, target) : null;
    }

    private HttpResponse callHandler(HttpRequest request, EndpointHandler handler) {
        List<Pair<HttpArg, Object>> objectList = createHandlerArgs(request, handler.getParameters());
        List<Object> callParameters = new ArrayList<>();

        for (Pair<HttpArg, Object> pair : objectList) {
            if (pair.getValueB() == null && pair.getValueA().required()) {
                return missingArgumentResponse(pair.getValueA());
            }

            if (pair.getValueB() == null && !pair.getValueA().type().isNullable()) {
                throwNullValueFound(pair.getValueA());
            }

            if(pair.getValueB() == null) {
                callParameters.add(null);
                continue;
            }

            if (!pair.getValueA().type().getParameterClass().isInstance(pair.getValueB())) {
                throwValueClassInvalid();
            }

            callParameters.add(pair.getValueB());
        }

        return mapHandlerResponse(callParameters.toArray(), handler);
    }

    private HttpResponse mapHandlerResponse(Object[] parameters, EndpointHandler handler) {
        Object response = handler.invoke(parameters);
        return HandlerResultHelper.createResult(response);
    }

    private void throwValueClassInvalid() {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be of invalid class type!"
        );
    }

    private void throwNullValueFound(HttpArg arg) {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be 'null', where 'null' is not allowed: " +
                        arg.type()
        );
    }

    private HttpResponse missingArgumentResponse(HttpArg arg) {
        return HttpResponse.compose()
                .withCode(Http.ResponseCode.BAD_REQUEST)
                .withResponse(
                        "Request is missing property of type: " +
                               arg.type().toString()
                ).build();
    }

    private List<Pair<HttpArg, Object>> createHandlerArgs(HttpRequest request, HttpArg[] args) {
        List<Pair<HttpArg, Object>> objects = new ArrayList<>();

        for(HttpArg arg : args) {
            Object object = HandlerArgumentHelper.createArgument(request, arg, this.server);
            objects.add(new Pair<>(arg, object));
        }

        return objects;
    }

    private EndpointHandler getHandlerByURI(String uri) {
        for(EndpointHandler handler : handlers) {
            if(handler.getURI().equalsIgnoreCase(uri))
                return handler;
        }
        return null;
    }

    private void registerMethod(Object instance, Method method) {
        HttpEndpoint annotation = method.getAnnotation(HttpEndpoint.class);
        assert annotation != null;

        if(getHandlerByURI(annotation.uri()) != null)
            throw new HttpEndpointException(
                    "Unable to declare HttpEndpoint: URI already in use: " +
                            method.getName() +
                            " of class " +
                            method.getDeclaringClass().getName()
            );

        EndpointHandler endpointHandler = new EndpointHandler(
                annotation.type(),
                annotation.uri(),
                method,
                instance
        );

        this.handlers.add(endpointHandler);
    }
}
