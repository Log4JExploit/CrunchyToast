/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.endpoint;

import github.log4jexploit.crunchytoast.exceptions.HttpEndpointException;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.resource.Resource;
import github.log4jexploit.crunchytoast.resource.ResourceDynamic;
import github.log4jexploit.crunchytoast.server.Client;
import github.log4jexploit.crunchytoast.server.Server;

import java.io.File;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;


public class EndpointManagerImpl implements EndpointManager {

    private final ArrayList<EndpointHandler> handlers;
    private final Server server;
    private File resourceFolder;


    public EndpointManagerImpl(File resourceFolder, Server server) {
        this.handlers = new ArrayList<>();
        this.resourceFolder = resourceFolder;
        this.server = server;
    }


    @Override
    public HttpResponse delegateRequest(HttpRequest request) throws HttpProtocolException {
        String uri = request.getRequestURI().split("\\?")[0];

        if(request.getRequestType() == Http.RequestType.CONNECT) {
            return findDestination(request, request.getRequestDestination());
        }

        HttpResponse response = findHandler(request, uri);

        if(response != null)
            return response;

        Resource resource = findResource(request.getRequestURI());

        if(resource != null) {
            return sendResourceFile(request.getClient(), request, resource);
        }

        return HttpResponse.compose()
                .withCode(Http.ResponseCode.NOT_FOUND)
                .build();
    }

    @Override
    public Resource findResource(String requestURI) {
        Http.ContentType contentType = Http.ContentType.BIN;
        File file = new File(
                this.resourceFolder.getAbsolutePath() +
                        requestURI.split("\\?")[0]
        );

        if(!file.exists() || file.isDirectory())
            return null;

        if(!file.getAbsolutePath().startsWith(resourceFolder.getAbsolutePath())) {
            return null;
        }

        if (file.getName().contains("."))
            contentType = Http.ContentType.byAlias(file.getName().split("\\.")[1]);

        return new ResourceDynamic(file, contentType);
    }

    @Override
    public void registerHandler(Object instance) {
        for(Method method : instance.getClass().getDeclaredMethods()) {
            if(method.isAnnotationPresent(HttpEndpoint.class))
                registerMethod(instance, method);
        }
    }

    @Override
    public void unregisterHandler(Object instance) {
        for(EndpointHandler endpointHandler : List.copyOf(handlers))
            if(endpointHandler.getInstance().getClass().isInstance(instance))
                handlers.remove(endpointHandler);
    }

    @Override
    public void setResourceFolder(String path) {
        this.resourceFolder = new File(path);
    }

    @Override
    public ArrayList<Object> getHandlers() {
        return new ArrayList<>(this.handlers);
    }

    @Override
    public File getResourceFolder() {
        return this.resourceFolder;
    }

    public Server getServer() {
        return this.server;
    }

    private HttpResponse sendResourceFile(Client client, HttpRequest request, Resource resource) {
        HttpResponse response = HttpResponse.compose().withCode(Http.ResponseCode.OK).build();
        response.setContent(resource);

        if(request.getAcceptEncodingsList().contains(Http.Encoding.GZIP)) {
            response.setContentEncodings(new Http.Encoding[]{ Http.Encoding.GZIP });
        }

        response.send(client);

        return response;
    }

    private HttpResponse findDestination(HttpRequest request, String destination) {
        EndpointHandler target = null;

        for(EndpointHandler handler : handlers) {
            if(handler.getDestination().equals("*")) {
                target = handler;
                continue;
            }
            if(handler.getDestination().equalsIgnoreCase(destination)) {
                target = handler;
                break;
            }
        }

        return target != null ? callHandler(request, target) : proxyUnavailable();
    }

    private HttpResponse findHandler(HttpRequest request, String uri) {
        EndpointHandler target = null;

        for(EndpointHandler handler : handlers) {
            if(!handler.getRequestType().equals(request.getRequestType()))
                continue;
            if(!handler.getURI().equalsIgnoreCase(uri))
                continue;
            target = handler;
            break;
        }

        return target != null ? callHandler(request, target) : null;
    }

    private HttpResponse callHandler(HttpRequest request, EndpointHandler handler) {
        List<Pair<HttpArg, Object>> objectList = createHandlerArgs(request, handler.getParameters());
        List<Object> callParameters = new ArrayList<>();

        for (Pair<HttpArg, Object> pair : objectList) {
            if (pair.getValueB() == null && pair.getValueA().required()) {
                return missingArgumentResponse(pair.getValueA());
            }

            if (pair.getValueB() == null && !pair.getValueA().type().isNullable()) {
                throwNullValueFound(pair.getValueA());
            }

            if(pair.getValueB() == null) {
                callParameters.add(null);
                continue;
            }

            if (!pair.getValueA().type().getParameterClass().isInstance(pair.getValueB())) {
                throwValueClassInvalid();
            }

            callParameters.add(pair.getValueB());
        }

        return mapHandlerResponse(callParameters.toArray(), handler);
    }

    private HttpResponse mapHandlerResponse(Object[] parameters, EndpointHandler handler) {
        Object response = handler.invoke(parameters);
        return HandlerResultHelper.createResult(response);
    }

    private HttpResponse proxyUnavailable() {
        return HttpResponse
                .compose()
                .withCode(Http.ResponseCode.SERVICE_UNAVAILABLE)
                .build();
    }

    private void throwValueClassInvalid() {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be of invalid class type!"
        );
    }

    private void throwNullValueFound(HttpArg arg) {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be 'null', where 'null' is not allowed: " +
                        arg.type()
        );
    }

    private HttpResponse missingArgumentResponse(HttpArg arg) {
        return HttpResponse.compose()
                .withCode(Http.ResponseCode.BAD_REQUEST)
                .withResponse(
                        "Request is missing property of type: " +
                               arg.type().toString()
                ).build();
    }

    private List<Pair<HttpArg, Object>> createHandlerArgs(HttpRequest request, HttpArg[] args) {
        List<Pair<HttpArg, Object>> objects = new ArrayList<>();

        for(HttpArg arg : args) {
            Object object = HandlerArgumentHelper.createArgument(request, arg, this.server);
            objects.add(new Pair<>(arg, object));
        }

        return objects;
    }

    private EndpointHandler getHandlerByURI(String uri) {
        for(EndpointHandler handler : handlers) {
            if(handler.getURI().equalsIgnoreCase(uri))
                return handler;
        }
        return null;
    }

    private void registerMethod(Object instance, Method method) {
        HttpEndpoint annotation = method.getAnnotation(HttpEndpoint.class);
        assert annotation != null;

        if(getHandlerByURI(annotation.uri()) != null)
            throw new HttpEndpointException(
                    "Unable to declare HttpEndpoint: URI already in use: " +
                            method.getName() +
                            " of class " +
                            method.getDeclaringClass().getName()
            );

        EndpointHandler endpointHandler = new EndpointHandler(
                annotation.type(),
                annotation.uri(),
                annotation.destination(),
                method,
                instance
        );

        this.handlers.add(endpointHandler);
    }
}
