/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.endpoint;

import github.log4jexploit.crunchytoast.exceptions.HttpEndpointException;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;


public class EndpointManagerImpl implements EndpointManager {

    private final ArrayList<EndpointHandler> handlers;
    private File resourceFolder;


    public EndpointManagerImpl(File resourceFolder) {
        this.handlers = new ArrayList<>();
        this.resourceFolder = resourceFolder;
    }


    @Override
    public HttpResponse delegateRequest(HttpRequest request) throws HttpProtocolException {
        String uri = request.getRequestURI().split("\\?")[0];
        HttpResponse response = findHandler(request, uri);

        if(response != null)
            return response;

        HttpResource resource = findResource(request.getRequestURI());

        if(resource != null) {
            response = HandlerResultHelper.createResult(resource);
            return response;
        }

        return HttpResponse.compose()
                .withCode(Http.ResponseCode.NOT_FOUND)
                .build();
    }

    @Override
    public HttpResource findResource(String requestURI) {
        Http.ContentType contentType = Http.ContentType.BIN;
        File file = new File(
                this.resourceFolder.getAbsolutePath() +
                        requestURI.split("\\?")[0]
        );

        if(!file.exists() || file.isDirectory())
            return null;

        if(!file.getAbsolutePath().startsWith(resourceFolder.getAbsolutePath())) {
            return null;
        }

        if (file.getName().contains("."))
            contentType = Http.ContentType.byAlias(file.getName().split("\\.")[1]);

        try {
            HttpResource resource;

            if(file.length() < 1024 * 1024) {
                FileInputStream in = new FileInputStream(file);
                resource = new HttpResourceBuffered(in.readAllBytes(), contentType);
                in.close();
            } else {
                resource = new HttpResourceDynamic(file, contentType);
            }

            return resource;
        } catch (IOException e) {
            throw new UncheckedIOException("File IO/Error: "+e.getMessage(), e);
        }
    }

    @Override
    public void registerHandler(Object instance) {
        for(Method method : instance.getClass().getDeclaredMethods()) {
            if(method.isAnnotationPresent(HttpEndpoint.class))
                registerMethod(instance, method);
        }
    }

    @Override
    public void unregisterHandler(Object instance) {
        for(EndpointHandler endpointHandler : List.copyOf(handlers))
            if(endpointHandler.getInstance().getClass().isInstance(instance))
                handlers.remove(endpointHandler);
    }

    @Override
    public void setResourceFolder(String path) {
        this.resourceFolder = new File(path);
    }

    @Override
    public ArrayList<Object> getHandlers() {
        return new ArrayList<>(this.handlers);
    }

    @Override
    public File getResourceFolder() {
        return this.resourceFolder;
    }

    private HttpResponse findHandler(HttpRequest request, String uri) {
        EndpointHandler target = null;

        for(EndpointHandler handler : handlers) {
            if(!handler.getRequestType().equals(request.getRequestType()))
                continue;
            if(!handler.getURI().equalsIgnoreCase(uri))
                continue;
            target = handler;
            break;
        }

        return target != null ? callHandler(request, target) : null;
    }

    private HttpResponse callHandler(HttpRequest request, EndpointHandler handler) {
        List<Pair<HttpArg, Object>> objectList = createHandlerArgs(request, handler.getParameters());
        List<Object> callParameters = new ArrayList<>();

        for (Pair<HttpArg, Object> pair : objectList) {
            if (pair.getValueB() == null && pair.getValueA().required()) {
                return missingArgumentResponse(pair.getValueA());
            }

            if (pair.getValueB() == null && !pair.getValueA().type().isNullable()) {
                throwNullValueFound(pair.getValueA());
            }

            if (!pair.getValueA().type().getParameterClass().isInstance(pair.getValueB())) {
                throwValueClassInvalid();
            }

            callParameters.add(pair.getValueB());
        }

        return mapHandlerResponse(callParameters.toArray(), handler);
    }

    private HttpResponse mapHandlerResponse(Object[] parameters, EndpointHandler handler) {
        Object response = handler.invoke(parameters);
        return HandlerResultHelper.createResult(response);
    }

    private void throwValueClassInvalid() {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be of invalid class type!"
        );
    }

    private void throwNullValueFound(HttpArg arg) {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be 'null', where 'null' is not allowed: " +
                        arg.type()
        );
    }

    private HttpResponse missingArgumentResponse(HttpArg arg) {
        return HttpResponse.compose()
                .withCode(Http.ResponseCode.BAD_REQUEST)
                .withResponse(
                        "Request is missing property of type: " +
                               arg.type().toString()
                ).build();
    }

    private List<Pair<HttpArg, Object>> createHandlerArgs(HttpRequest request, HttpArg[] args) {
        List<Pair<HttpArg, Object>> objects = new ArrayList<>();

        for(HttpArg arg : args) {
            Object object = HandlerArgumentHelper.createArgument(request, arg);
            objects.add(new Pair<>(arg, object));
        }

        return objects;
    }

    private EndpointHandler getHandlerByURI(String uri) {
        for(EndpointHandler handler : handlers) {
            if(handler.getURI().equalsIgnoreCase(uri))
                return handler;
        }
        return null;
    }

    private void registerMethod(Object instance, Method method) {
        HttpEndpoint annotation = method.getAnnotation(HttpEndpoint.class);
        assert annotation != null;

        if(getHandlerByURI(annotation.uri()) != null)
            throw new HttpEndpointException(
                    "Unable to declare HttpEndpoint: URI already in use: " +
                            method.getName() +
                            " of class " +
                            method.getDeclaringClass().getName()
            );

        EndpointHandler endpointHandler = new EndpointHandler(
                annotation.type(),
                annotation.uri(),
                method,
                instance
        );

        this.handlers.add(endpointHandler);
    }
}
