/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.provider;

import github.log4jexploit.crunchytoast.exceptions.HttpEndpointException;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.http.endpoint.*;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.server.Server;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class EndpointManagerImpl implements EndpointManager {

    private final List<EndpointHandler> endpoints;
    private final Server server;


    public EndpointManagerImpl(Server server) {
        this.endpoints = new ArrayList<>();
        this.server = server;
    }


    @Override
    public Optional<HttpResponse> apply(HttpRequest request) {
        for(EndpointHandler handler : endpoints) {
            if(!handler.getRequestType().equals(request.getRequestType()))
                continue;
            if(!handler.getURI().equalsIgnoreCase(request.getResourcePath()))
                continue;
            return Optional.of(callHandler(request, handler));
        }

        return Optional.empty();
    }

    private HttpResponse callHandler(HttpRequest request, EndpointHandler handler) {
        List<Pair<HttpArg, Object>> objectList = createHandlerArgs(request, handler.getParameters());
        List<Object> callParameters = new ArrayList<>();

        for (Pair<HttpArg, Object> pair : objectList) {
            if (pair.getValueB() == null && pair.getValueA().required()) {
                return missingArgumentResponse(pair.getValueA());
            }

            if (pair.getValueB() == null && !pair.getValueA().type().isNullable()) {
                throwNullValueFound(pair.getValueA());
            }

            if(pair.getValueB() == null) {
                callParameters.add(null);
                continue;
            }

            if (!pair.getValueA().type().getParameterClass().isInstance(pair.getValueB())) {
                throwValueClassInvalid();
            }

            callParameters.add(pair.getValueB());
        }

        return mapHandlerResponse(callParameters.toArray(), handler);
    }

    private HttpResponse mapHandlerResponse(Object[] parameters, EndpointHandler handler) {
        Object response = handler.invoke(parameters);
        return HandlerResultHelper.createResult(response);
    }

    private HttpResponse proxyUnavailable() {
        return HttpResponse
                .compose()
                .withCode(Http.ResponseCode.SERVICE_UNAVAILABLE)
                .build();
    }

    private void throwValueClassInvalid() {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be of invalid class type!"
        );
    }

    private void throwNullValueFound(HttpArg arg) {
        throw new HttpEndpointException(
                "HttpEndpoint argument appears to be 'null', where 'null' is not allowed: " +
                        arg.type()
        );
    }

    private HttpResponse missingArgumentResponse(HttpArg arg) {
        return HttpResponse.compose()
                .withCode(Http.ResponseCode.BAD_REQUEST)
                .withResponse(
                        "Request is missing property of type: " +
                                arg.type().toString()
                ).build();
    }

    private List<Pair<HttpArg, Object>> createHandlerArgs(HttpRequest request, HttpArg[] args) {
        List<Pair<HttpArg, Object>> objects = new ArrayList<>();

        for(HttpArg arg : args) {
            Object object = HandlerArgumentHelper.createArgument(request, arg, this.server);
            objects.add(new Pair<>(arg, object));
        }

        return objects;
    }

    private EndpointHandler getEndpointByURI(String uri) {
        for(EndpointHandler handler : endpoints) {
            if(handler.getURI().equalsIgnoreCase(uri))
                return handler;
        }
        return null;
    }

    private void registerMethod(Object instance, Method method) {
        HttpEndpoint annotation = method.getAnnotation(HttpEndpoint.class);
        assert annotation != null;

        if(getEndpointByURI(annotation.uri()) != null)
            throw new HttpEndpointException(
                    "Unable to declare HttpEndpoint: URI already in use: " +
                            method.getName() +
                            " of class " +
                            method.getDeclaringClass().getName()
            );

        EndpointHandler endpointHandler = new EndpointHandler(
                annotation.type(),
                annotation.uri(),
                annotation.destination(),
                method,
                instance
        );

        this.endpoints.add(endpointHandler);
    }

    @Override
    public void registerHandler(Object instance) {
        for(Method method : instance.getClass().getDeclaredMethods()) {
            if(method.isAnnotationPresent(HttpEndpoint.class))
                registerMethod(instance, method);
        }
    }

    @Override
    public void unregisterHandler(Object instance) {
        for(EndpointHandler endpointHandler : List.copyOf(endpoints))
            if(endpointHandler.getInstance().getClass().isInstance(instance))
                endpoints.remove(endpointHandler);
    }

    @Override
    public ArrayList<Object> getEndpoints() {
        return new ArrayList<>(this.endpoints);
    }
}
