/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.body.impl;

import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.message.inf.Strategy;
import github.log4jexploit.crunchytoast.http.util.DecodingInputStream;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOWriter;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

public class BodyContentReaderDirect implements IBodyContentReader {

    private final Strategy.Message strategy;
    private final Http.Encoding[] encodings;
    private final UncheckedIOReader reader;

    private final List<byte[]> content;
    private final int finalLength;
    private boolean decoded;
    private int counter;


    public BodyContentReaderDirect(HttpMessage message, Strategy.Message strategy) {
        this.reader = new UncheckedIOReader(message.getClient().getInputStream());
        this.encodings = message.getContentEncodings();
        this.finalLength = message.getContentLength();
        this.content = new ArrayList<>();
        this.strategy = strategy;
        this.counter = 0;
    }

    public void readAll() {
        read(calculateLen() - this.counter);
    }

    public void read() {
        read(1);
    }

    public void read(int count) {
        if(decoded || counter >= finalLength)
            return;

        if(counter + count > finalLength)
            count = finalLength - this.counter;

        byte[] buf = new byte[count];
        reader.readNBytes(buf, 0, count);
        counter += count;

        this.content.add(buf);

        if(this.counter >= finalLength)
            this.strategy.executeTrailers();
    }

    public int readRaw(byte[] buffer, int count) {
        if(counter >= finalLength)
            return 0;

        if(count + counter > finalLength)
            count = finalLength - counter;

        reader.readNBytes(buffer, 0, count);
        counter += count;

        return count;
    }

    public int skipBytesRaw(int count) {
        if(counter >= finalLength)
            return 0;

        if(count + counter > finalLength)
            count = finalLength - counter;

        int skipped = reader.skip(count);
        counter += skipped;
        return skipped;
    }

    @Override
    public void decode() {
        if(decoded || this.counter < finalLength)
            return;

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++)
            encodings[i] = this.encodings[i].toString();

        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        UncheckedIOWriter streamWriter = new UncheckedIOWriter(stream);
        for(byte[] buf : this.content)
            streamWriter.write(buf);
        streamWriter.flush();

        DecodingInputStream decodingInputStream = new DecodingInputStream(encodings, stream.toByteArray());
        this.content.clear();
        this.content.add(decodingInputStream.readAllBytes());
        this.decoded = true;
    }

    public byte[] getDecoded() {
        onFlushRemaining();
        return this.content.get(0);
    }

    private int calculateLen() {
        int len = 0;
        for(byte[] buf : content)
            len += buf.length;
        return len;
    }

    @Override
    public void onFlushRemaining() {
        readAll();
        decode();
    }

    @Override
    public Http.Encoding[] getEncodings() {
        return this.encodings;
    }

    @Override
    public InputStream getInputStream() {
        return this.reader.getInputStream();
    }

    @Override
    public UncheckedIOReader getReader() {
        return this.reader;
    }

    public int getContentLength() {
        return calculateLen();
    }

    public int getBytesRead() {
        return counter;
    }
}
