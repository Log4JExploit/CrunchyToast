/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.body.impl;

import github.log4jexploit.crunchytoast.http.endpoint.HttpResourceSplintered;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyChunked;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.message.inf.Strategy;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import github.log4jexploit.crunchytoast.http.util.UtilChunks;

import java.io.InputStream;

public class BodyContentReaderChunked implements IBodyChunked.Reader {

    private final HttpResourceSplintered content;
    private final Http.Encoding[] encodings;
    private final Strategy.Message strategy;
    private final UtilChunks util;
    private final InputStream in;

    private boolean endOfStream;
    private int counter;


    public BodyContentReaderChunked(HttpMessage message, Strategy.Message strategy) {
        this.encodings = message.getContentEncodings();
        this.strategy = strategy;
        this.in = message.getClient().getInputStream();
        this.util = new UtilChunks();
        this.counter = 0;
        this.content = new HttpResourceSplintered(message.getContentType());
        message.setContent(this.content);
    }


    @Override
    public byte[] readNextChunk() {
        if(endOfStream)
            return new byte[0];

        byte[] encodedData = util.readEncodedChunk(in);
        counter += encodedData.length;

        this.content.write(encodedData);

        if(encodedData.length == 0) {
            endOfStream = true;
            this.strategy.executeTrailers();
        }

        return encodedData;
    }

    @Override
    public void onFlushRemaining() {
        byte[] chunk;
        do {
          chunk = readNextChunk();
        } while(chunk.length != 0);
    }

    @Override
    public Http.Encoding[] getEncodings() {
        return this.encodings;
    }

    @Override
    public long getContentLength() {
        return this.counter;
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }

    @Override
    public UncheckedIOReader getReader() {
        return null;
    }

    @Override
    public void decode() {
        // Do nothing
    }

    @Override
    public boolean isFinished() {
        return endOfStream;
    }
}
