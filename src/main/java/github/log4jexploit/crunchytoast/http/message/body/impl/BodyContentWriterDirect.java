/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.body.impl;

import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.message.inf.Strategy;
import github.log4jexploit.crunchytoast.http.util.EncodingInputStream;
import github.log4jexploit.crunchytoast.http.util.Http;

import java.io.OutputStream;

public class BodyContentWriterDirect implements IBodyContentWriter {

    private final Strategy.Message strategy;
    private final Http.Encoding[] encodings;
    private final UncheckedIOWriter writer;

    private boolean encoded;
    private byte[] content;
    private int counter;


    public BodyContentWriterDirect(HttpMessage message, Strategy.Message strategy) {
        this.content = message.getContent().clone();

        this.encodings = message.getContentEncodings();
        this.strategy = strategy;
        this.counter = 0;

        this.writer = new UncheckedIOWriter(message.getClient().getOutputStream());
        this.content = new byte[content.length];
    }


    public void writeAll() {
        write(this.content.length - this.counter);
    }

    public void write() {
        write(1);
    }

    public void write(int count) {
        encode();

        if(counter >= this.content.length || count <= 0)
            return;

        if(counter + count > this.content.length)
            return;

        this.writer.write(this.content, this.counter, this.counter + count - 1);
        this.counter += count;

        if(this.counter >= content.length)
            this.strategy.executeTrailers();
    }

    @Override
    public void encode() {
        if(encoded)
            return;

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++)
            encodings[i] = this.encodings[i].toString();

        EncodingInputStream encodingInputStream = new EncodingInputStream(encodings, this.content);
        this.content = encodingInputStream.readAllBytes();
        this.encoded = true;
    }

    @Override
    public void onFlushRemaining() {
        writeAll();
    }

    @Override
    public Http.Encoding[] getEncodings() {
        return this.encodings;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.writer.getOutputStream();
    }

    @Override
    public int getContentLength() {
        return content.length;
    }

    public int getBytesSent() {
        return counter;
    }
}
