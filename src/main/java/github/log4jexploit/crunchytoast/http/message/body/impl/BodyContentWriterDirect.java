/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.body.impl;

import github.log4jexploit.crunchytoast.http.endpoint.HttpResource;
import github.log4jexploit.crunchytoast.http.endpoint.HttpResourceRaw;
import github.log4jexploit.crunchytoast.http.endpoint.HttpResourceSplintered;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.message.inf.Strategy;
import github.log4jexploit.crunchytoast.http.util.EncodingStream;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOWriter;

import java.io.OutputStream;

public class BodyContentWriterDirect implements IBodyContentWriter {

    private final Strategy.Message strategy;
    private final Http.Encoding[] encodings;
    private final UncheckedIOWriter writer;

    private HttpResource resource;
    private boolean encoded;
    private long counter;


    public BodyContentWriterDirect(HttpMessage message, Strategy.Message strategy) {
        this.resource = message.getContentAsResource();
        this.encodings = message.getContentEncodings();

        this.strategy = strategy;
        this.counter = 0;

        this.writer = new UncheckedIOWriter(message.getClient().getOutputStream());
    }


    public void writeAll() {
        while(this.counter < resource.getSize())
            write(1024);
    }

    public void write() {
        write(1);
    }

    public void write(int count) {
        encode();

        if(counter >= resource.getSize() || count <= 0)
            return;

        int safe = (int) Math.min((this.resource.getSize() - counter), Integer.MAX_VALUE);
        count = Math.min(safe, count);

        if(counter + count > resource.getSize())
            return;

        byte[] data = resource.getDataRange(counter, count);
        writer.write(data);
        writer.flush();
        counter += count;

        if(counter >= resource.getSize())
            strategy.executeTrailers();
    }

    public int writeRaw(byte[] buffer) {
        return writeRaw(buffer, 0, buffer.length);
    }

    public int writeRaw(byte[] buffer, int offset, int length) {
        if(length > buffer.length + offset)
            throw new IllegalArgumentException("Length is bigger than the available data!");

        if(length == 0)
            return 0;

        if(counter >= resource.getSize())
            return 0;

        int safe = (int) Math.min((this.resource.getSize() - length), Integer.MAX_VALUE);
        int count = Math.min(safe, length);

        writer.write(buffer, offset, count);
        counter += count;

        return count;
    }

    @Override
    public void encode() {
        if(encoded || this.encodings.length < 1) {
            encoded = true;
            return;
        }

        if(resource instanceof HttpResourceRaw) {
            encoded = true;
            return;
        }

        HttpResourceSplintered target = new HttpResourceSplintered(this.resource.getContentType());
        EncodingStream encodingInputStream = new EncodingStream(encodings, target.getWriteableStream());

        UncheckedIOWriter localWriter = new UncheckedIOWriter(encodingInputStream);
        UncheckedIOReader localReader = new UncheckedIOReader(this.resource.getDataAsStream());

        byte[] buf = new byte[1024];
        int len;
        do {
            len = localReader.readNBytes(buf, 0, buf.length);
            if(len == -1)
                break;

            localWriter.write(buf, 0, len);
            localWriter.flush();
        } while(len == buf.length);

        localWriter.close();
        localReader.close();

        this.resource = target;
        this.encoded = true;
    }

    @Override
    public void onFlushRemaining() {
        writeAll();
    }

    @Override
    public Http.Encoding[] getEncodings() {
        return this.encodings;
    }

    @Override
    public OutputStream getOutputStream() {
        return this.writer.getOutputStream();
    }

    @Override
    public UncheckedIOWriter getWriter() {
        return this.writer;
    }

    @Override
    public long getContentLength() {
        return resource.getSize();
    }

    public long getBytesSent() {
        return counter;
    }
}
