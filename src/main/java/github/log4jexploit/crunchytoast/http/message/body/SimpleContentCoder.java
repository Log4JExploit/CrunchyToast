/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.body;

import github.log4jexploit.crunchytoast.http.util.DecodingInputStream;
import github.log4jexploit.crunchytoast.http.util.EncodingInputStream;
import github.log4jexploit.crunchytoast.http.util.Http;

import java.io.*;

// Coded by Zadex at 29/10/2022
public class SimpleContentCoder implements ContentCoder {

    private final ByteArrayOutputStream encoded;
    private final ByteArrayOutputStream decoded;
    private final Http.Encoding[] encodings;

    private final OutputStream out;
    private final InputStream in;

    private final boolean readMode;
    private final int contentLength;

    private byte[] output;
    private int counter = 0;

    private boolean decodingFinished;
    private boolean encodingFinished;

    private boolean writingFinished;
    private boolean readingFinished;


    public SimpleContentCoder(InputStream in, int contentLength, Http.Encoding[] encodings) {
        this.in = in;
        this.out = null;
        this.contentLength = contentLength;

        this.readMode = true;
        this.encodings = encodings;

        this.encoded = new ByteArrayOutputStream();
        this.decoded = new ByteArrayOutputStream();
    }

    public SimpleContentCoder(OutputStream out, byte[] data, Http.Encoding[] encodings) {
        this.out = out;
        this.in = null;
        this.contentLength = data.length;

        this.encodings = encodings;
        this.readMode = false;

        this.encoded = new ByteArrayOutputStream();
        this.decoded = new ByteArrayOutputStream();
        this.decoded.writeBytes(data);
    }


    @Override
    public byte[] read() {
        if(!this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in write mode!");

        if(this.readingFinished || this.counter >= this.contentLength) {
            this.readingFinished = true;
            return new byte[0];
        }

        byte[] read = new byte[] {
                (byte) this.in.read()
        };

        this.encoded.writeBytes(read);
        this.counter++;

        return read;
    }

    @Override
    public byte[] readAll() {
        if(!this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in write mode!");

        while(!this.readingFinished) {
            this.read();
        }

        this.decodeAll();
        return this.decoded.toByteArray();
    }

    @Override
    public void write() {
        if(this.writingFinished)
            return;

        if(this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in read mode!");

        if(!this.encodingFinished)
            this.encodeAll();

        if(this.counter >= this.output.length) {
            this.writingFinished = true;
            return;
        }

        out.write(this.output[counter]);

        this.counter++;
    }

    @Override
    public void writeAll() {
        if(this.writingFinished)
            return;

        if(this.readMode)
            throw new IllegalStateException("This ContentCoder instance is in read mode!");

        out.write(this.output, this.counter, this.output.length);
        out.flush();

        this.counter = this.output.length;

        this.writingFinished = true;
    }

    @Override
    public void decodeAll() {
        if(!readMode || decodingFinished)
            return;

        if(!this.readingFinished)
            this.readAll();

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++) {
            encodings[i] = this.encodings[i].toString().toLowerCase().trim();
        }

        try {
            DecodingInputStream stream = new DecodingInputStream(encodings,this.encoded.toByteArray());
            this.decoded.writeBytes(stream.readAllBytes());
            stream.close();
            this.decodingFinished = true;   
        } catch (Exception e) {
            throw new IOException("Decoding failed: "+e.getMessage(), e);
        }
    }

    @Override
    public void encodeAll() throws IOException {
        if(this.encodingFinished)
            return;

        if(this.readMode)
            throw new IOException("This ContentCoder instance is in read mode!");

        String[] encodings = new String[this.encodings.length];
        for(int i = 0; i < encodings.length; i++)
            encodings[i] = this.encodings[i].toString().toLowerCase();

        EncodingInputStream inputStream = new EncodingInputStream(encodings, decoded.toByteArray());
        this.encoded.reset();
        this.encoded.writeBytes(inputStream.getBytes());
        this.encoded.flush();
        inputStream.close();

        this.output = this.encoded.toByteArray();
        this.encodingFinished = true;
    }

    @Override
    public boolean isReadingFinished() {
        return this.readingFinished;
    }

    @Override
    public boolean isWritingFinished() {
        return this.writingFinished;
    }

    @Override
    public boolean isDecodingFinished() {
        return this.decodingFinished;
    }

    @Override
    public boolean isEncodingFinished() {
        return this.encodingFinished;
    }

    @Override
    public byte[] getDecoded() {
        return this.decoded.toByteArray();
    }

    @Override
    public byte[] getEncoded() {
        return this.encoded.toByteArray();
    }
}
