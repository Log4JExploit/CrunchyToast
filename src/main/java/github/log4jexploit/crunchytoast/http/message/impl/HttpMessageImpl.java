/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.impl;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Pair;
import github.log4jexploit.crunchytoast.general.Parseable;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.resource.Resource;
import github.log4jexploit.crunchytoast.resource.ResourceBuffered;
import github.log4jexploit.crunchytoast.resource.ResourceEmpty;
import github.log4jexploit.crunchytoast.server.Client;
import github.log4jexploit.crunchytoast.strategy.Strategy;
import github.log4jexploit.crunchytoast.strategy.StrategyMessageReceiveImpl;
import github.log4jexploit.crunchytoast.strategy.StrategyMessageSendImpl;

import java.lang.reflect.Array;
import java.util.*;

public class HttpMessageImpl implements HttpMessage {

    private static final String PROTOCOL = "HTTP/1.1";

    protected Map<Http.HeaderType, String> headers;
    protected Map<String, String> customHeaders;

    protected Map<Http.HeaderType, String> trailers;
    protected Map<String, String> customTrailers;

    protected HttpSecurityPolicy securityPolicy;
    protected Strategy.Message messageStrategy;
    protected Resource resource;
    protected Client client;


    public HttpMessageImpl() {
        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.resource = new ResourceEmpty();

        this.customTrailers = new HashMap<>();
        this.customHeaders = new HashMap<>();
        this.trailers = new HashMap<>();
        this.headers = new HashMap<>();
    }


    @Override
    public IBodyContentWriter send(Client client) {
        this.client = Objects.requireNonNull(client);
        this.securityPolicy = (HttpSecurityPolicy) this.client.getSecurityPolicy();
        this.messageStrategy = new StrategyMessageSendImpl();
        this.messageStrategy.initialize(this.client, this);
        execute();
        return (IBodyContentWriter) messageStrategy.getContentHandler();
    }

    @Override
    public IBodyContentReader receive(Client client) {
        reset();
        this.client = Objects.requireNonNull(client);
        this.securityPolicy = (HttpSecurityPolicy) this.client.getSecurityPolicy();
        this.messageStrategy = new StrategyMessageReceiveImpl();
        this.messageStrategy.initialize(this.client, this);
        execute();
        return (IBodyContentReader) messageStrategy.getContentHandler();
    }

    @Override
    public void performChecks() {
        checkIllegalTrailerSection();
        checkRequestSmuggling();
        checkHeaderCount();
        checkTrailerCount();
    }

    /**
     * Checks if a trailer section is present without a content body.
     */
    private void checkIllegalTrailerSection() {
        if(this.getHeaders().containsKey(Http.HeaderType.CONTENT_TYPE)) {
            if(this.getHeaders().containsKey(Http.HeaderType.TRAILER)) {
                if(this.securityPolicy.isDiscardWhenInvalid()) {
                    throw new HttpProtocolException("Request contains illegal trailer section!");
                }

                removeHeader(Http.HeaderType.TRAILER);
                trailers.clear();
                customTrailers.clear();
            }
        }
    }

    /**
     * Checks if a message contains multiple content bodies<br>
     * and removes the 'Content_Length' header, if multiple bodies were found.
     */
    private void checkRequestSmuggling() {
        if(this.isChunkedTransfer() && this.getContentLength() > 0) {
            if(this.securityPolicy.isDiscardWhenInvalid())
                throw new HttpProtocolException("ContentLength and TransferEncoding are both set!");
            this.removeHeader(Http.HeaderType.CONTENT_LENGTH);
        }
    }

    /**
     * Checks if a message exceeds the maximum header count
     */
    private void checkHeaderCount() {
        if(this.getHeaders().size() + this.getCustomHeaders().size()
                > this.securityPolicy.getMaxHeaderCount()) {
            throw new HttpProtocolException("Maximum header count exceeded!");
        }
    }

    /**
     * Checks if a message exceeds the maximum trailer count
     */
    private void checkTrailerCount() {
        if(this.getTrailerFields().length + this.getCustomTrailers().size()
                > this.securityPolicy.getMaxHeaderCount()) {
            throw new HttpProtocolException("Maximum trailer count exceeded!");
        }
    }


    @Override
    public void sendTrailers() {
        this.messageStrategy.executeTrailers();
    }

    @Override
    public void receiveTrailers() {
        this.messageStrategy.executeTrailers();
    }


    @Override
    public void setKeepAlive(boolean keepAlive) {
        this.headers.put(Http.HeaderType.CONNECTION, keepAlive ? "keep-alive" : "closed");
    }

    @Override
    public boolean isKeepAlive() {
        if(!hasHeader(Http.HeaderType.CONNECTION)) {
            return false;
        }
        return "keep-alive".equalsIgnoreCase(this.headers.get(Http.HeaderType.CONNECTION));
    }

    @Override
    public void setServer(String server) {
        this.headers.put(Http.HeaderType.SERVER, Objects.requireNonNull(server).trim());
    }

    @Override
    public String getServer() {
        return this.headers.get(Http.HeaderType.SERVER);
    }

    /**
     * Use <code>setContentAsResource()</code> instead. This might<br>
     * be removed in a future version.
     * @param length the content's length
     */
    @Deprecated
    @Override
    public void setContentLength(long length) {
        if(length < 0) {
            throw new IllegalArgumentException("Length must be greater than zero!");
        }
        this.headers.put(Http.HeaderType.CONTENT_LENGTH, String.valueOf(length));
    }

    @Override
    public long getContentLength() {
        return this.headers.containsKey(Http.HeaderType.CONTENT_LENGTH) ?
                Long.parseLong(this.getHeader(Http.HeaderType.CONTENT_LENGTH)) : 0;
    }

    @Override
    public void setContentTransferEncoding(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.CONTENT_TRANSFER_ENCODING, Objects.requireNonNull(encodings));
    }

    @Override
    public Http.Encoding[] getContentTransferEncoding() {
        return getParseableList(Http.HeaderType.CONTENT_TRANSFER_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public List<Http.Encoding> getContentTransferEncodingList() {
        Http.Encoding[] array = getContentTransferEncoding();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setContentEncodings(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.CONTENT_ENCODING, Objects.requireNonNull(encodings));
    }

    @Override
    public Http.Encoding[] getContentEncodings() {
        return getParseableList(Http.HeaderType.CONTENT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public List<Http.Encoding> getContentEncodingsList() {
        Http.Encoding[] array = getContentEncodings();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setTrailerFields(Http.HeaderType[] headerTypes) {
        setParseableList(Http.HeaderType.TRAILER, Objects.requireNonNull(headerTypes));
    }

    @Override
    public Http.HeaderType[] getTrailerFields() {
        return getParseableList(Http.HeaderType.TRAILER, Http.HeaderType.values()[0]);
    }

    @Override
    public void setAcceptEncodings(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.ACCEPT_ENCODING, Objects.requireNonNull(encodings));
    }

    @Override
    public Http.Encoding[] getAcceptEncodings() {
        return getParseableList(Http.HeaderType.ACCEPT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public List<Http.Encoding> getAcceptEncodingsList() {
        Http.Encoding[] array = getAcceptEncodings();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setAcceptLanguages(Http.Language[] languages) {
        setParseableList(Http.HeaderType.ACCEPT_LANGUAGE, Objects.requireNonNull(languages));
    }

    @Override
    public Http.Language[] getAcceptLanguages() {
        return getParseableList(Http.HeaderType.ACCEPT_LANGUAGE, Http.Language.values()[0]);
    }

    @Override
    public List<Http.Language> getAcceptLanguagesList() {
        Http.Language[] array = getAcceptLanguages();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setAcceptCharsets(Http.Charset[] charsets) {
        setParseableList(Http.HeaderType.ACCEPT_CHARSET, Objects.requireNonNull(charsets));
    }

    @Override
    public Http.Charset[] getAcceptCharsets() {
        return getParseableList(Http.HeaderType.ACCEPT_CHARSET, Http.Charset.values()[0]);
    }

    @Override
    public List<Http.Charset> getAcceptCharsetsList() {
        Http.Charset[] array = getAcceptCharsets();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setContentType(Http.ContentType contentType) {
        this.headers.put(Http.HeaderType.CONTENT_TYPE, Objects.requireNonNull(contentType).toString());
    }

    @Override
    public Http.ContentType getContentType() {
        return Http.ContentType.values()[0].byString(this.headers.get(Http.HeaderType.CONTENT_TYPE));
    }

    @Override
    public void setChunkedTransfer(boolean chunked) {
        if(chunked) {
            this.headers.put(Http.HeaderType.TRANSFER_ENCODING, "chunked");
            this.headers.remove(Http.HeaderType.CONTENT_LENGTH);
        } else {
            this.headers.remove(Http.HeaderType.TRANSFER_ENCODING);
            this.headers.put(Http.HeaderType.CONTENT_LENGTH, "0");
            this.resource = new ResourceEmpty();
        }
    }

    @Override
    public boolean isChunkedTransfer() {
        return this.headers.containsKey(Http.HeaderType.TRANSFER_ENCODING) &&
                this.headers.get(Http.HeaderType.TRANSFER_ENCODING).startsWith("chunked");
    }

    @Override
    public void setCacheControl(String cacheControl) {
        this.headers.put(Http.HeaderType.CACHE_CONTROL, Objects.requireNonNull(cacheControl));
    }

    @Override
    public String getCacheControl() {
        return this.headers.get(Http.HeaderType.CACHE_CONTROL);
    }

    @Override
    public void setCookie(String cookie) {
        this.headers.put(Http.HeaderType.COOKIE, Objects.requireNonNull(cookie));
    }

    @Override
    public String getCookie() {
        return this.headers.get(Http.HeaderType.COOKIE);
    }

    @Override
    public void setSetCookie(String cookie) {
        this.headers.put(Http.HeaderType.SET_COOKIE, Objects.requireNonNull(cookie));
    }

    @Override
    public String getSetCookie() {
        return this.headers.get(Http.HeaderType.SET_COOKIE);
    }

    @Override
    public void setDate(String date) {
        this.headers.put(Http.HeaderType.DATE, Objects.requireNonNull(date));
    }

    @Override
    public String getDate() {
        return this.headers.get(Http.HeaderType.DATE);
    }

    @Override
    public void setHost(String host) {
        this.headers.put(Http.HeaderType.HOST, Objects.requireNonNull(host));
    }

    @Override
    public String getHost() {
        return this.headers.get(Http.HeaderType.HOST);
    }

    @Override
    public void setLocation(String location) {
        this.headers.put(Http.HeaderType.LOCATION, Objects.requireNonNull(location));
    }

    @Override
    public String getLocation() {
        return this.headers.get(Http.HeaderType.LOCATION);
    }

    @Override
    public void setUserAgent(String userAgent) {
        this.headers.put(Http.HeaderType.USER_AGENT, Objects.requireNonNull(userAgent));
    }

    @Override
    public String getUserAgent() {
        return this.headers.get(Http.HeaderType.USER_AGENT);
    }

    @Override
    public void setVia(String via) {
        this.headers.put(Http.HeaderType.VIA, Objects.requireNonNull(via));
    }

    @Override
    public String getVia() {
        return this.headers.get(Http.HeaderType.VIA);
    }

    @Override
    public void setProxyAuthorization(String username, String password) {
        this.setBasicAuthFor(Http.HeaderType.PROXY_AUTHORIZATION, username, password);
    }

    @Override
    public Optional<Pair<String, String>> getProxyAuthorization() {
        return getBasicAuthFor(Http.HeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public boolean hasProxyAuth() {
        return this.headers.containsKey(Http.HeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public void setReferer(String referer) {
        this.headers.put(Http.HeaderType.REFERER, Objects.requireNonNull(referer));
    }

    @Override
    public String getReferer() {
        return this.headers.get(Http.HeaderType.REFERER);
    }

    @Override
    public boolean hasTrailer(Http.HeaderType headerType) {
        return this.trailers.containsKey(Objects.requireNonNull(headerType));
    }

    @Override
    public void removeTrailer(Http.HeaderType headerType) {
        this.trailers.remove(Objects.requireNonNull(headerType));
    }

    @Override
    public void setTrailer(Http.HeaderType headerType, String value) {
        this.trailers.put(headerType, value);
    }

    @Override
    public String getTrailer(Http.HeaderType headerType) {
        return trailers.get(headerType);
    }

    @Override
    public boolean hasCustomTrailer(String name) {
        return this.customTrailers.containsKey(name);
    }

    @Override
    public void setCustomTrailer(String key, String value) {
        Objects.requireNonNull(key);
        Objects.requireNonNull(value);

        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.trailers.put(headerType, value);
        else
            this.customTrailers.put(key, value);
    }

    @Override
    public String getCustomTrailer(String key) {
        Objects.requireNonNull(key);

        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            return this.trailers.get(headerType);
        else
            return this.customTrailers.get(key);
    }

    @Override
    public void setBasicAuth(String username, String password) {
        this.setBasicAuthFor(Http.HeaderType.AUTHORIZATION, username, password);
    }

    @Override
    public Optional<Pair<String, String>> getBasicAuth() {
        return getBasicAuthFor(Http.HeaderType.AUTHORIZATION);
    }

    @Override
    public void setWWWAuthenticate(boolean enable) {
        if(enable)
            this.headers.put(Http.HeaderType.WWW_AUTHENTICATE, "Basic");
        else
            this.headers.remove(Http.HeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public boolean isWWWAuthenticate() {
        return this.headers.containsKey(Http.HeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public void setWarning(String warning) {
        this.headers.put(Http.HeaderType.WARNING, Objects.requireNonNull(warning));
    }

    @Override
    public String getWarning() {
        return this.headers.get(Http.HeaderType.WARNING);
    }

    @Override
    public void setUpgradeInsecureRequests(boolean enabled) {
        if(enabled)
            this.headers.put(Http.HeaderType.UPGRADE_INSECURE_REQUESTS, "1");
        else
            this.headers.remove(Http.HeaderType.UPGRADE_INSECURE_REQUESTS);
    }

    @Override
    public boolean isUpgradeInsecureRequests() {
        return this.headers.containsKey(Http.HeaderType.UPGRADE_INSECURE_REQUESTS) &&
                "1".equalsIgnoreCase(this.headers.get(Http.HeaderType.UPGRADE_INSECURE_REQUESTS));
    }

    @Override
    public boolean hasHeader(Http.HeaderType headerType) {
        return this.headers.containsKey(Objects.requireNonNull(headerType));
    }

    @Override
    public void setHeader(Http.HeaderType headerType, String value) {
        this.headers.put(Objects.requireNonNull(headerType), Objects.requireNonNull(value));
    }

    @Override
    public String getHeader(Http.HeaderType headerType) {
        return this.headers.get(headerType);
    }

    @Override
    public boolean hasCustomHeader(String name) {
        return this.customHeaders.containsKey(name.toLowerCase());
    }

    @Override
    public void setCustomHeader(String key, String value) {
        Http.HeaderType headerType;

        Objects.requireNonNull(key);
        Objects.requireNonNull(value);

        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.headers.put(headerType, value);
        else
            this.customHeaders.put(key.toLowerCase(), value);
    }

    @Override
    public void removeHeader(String key) {
        Objects.requireNonNull(key);

        Http.HeaderType headerType = Http.HeaderType.values()[0].byString(key);

        if(headerType != Http.HeaderType.CUSTOM) {
            this.removeHeader(headerType);
        } else{
            this.customHeaders.remove(key.toLowerCase());
        }
    }

    @Override
    public void removeHeader(Http.HeaderType headerType) {
        this.headers.remove(Objects.requireNonNull(headerType));
    }

    @Override
    public String getCustomHeader(String key) {
        Objects.requireNonNull(key);

        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.CONTENT_TYPE.byString(key)) != Http.HeaderType.CUSTOM) {
            return this.headers.get(headerType);
        }
        return this.customHeaders.get(key);
    }

    @Override
    public Map<Http.HeaderType, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, String> getCustomHeaders() {
        return this.customHeaders;
    }

    @Override
    public Map<Http.HeaderType, String> getTrailers() {
        return this.trailers;
    }

    @Override
    public Map<String, String> getCustomTrailers() {
        return this.customTrailers;
    }

    @Override
    public void setContent(byte[] content) {
        this.resource = new ResourceBuffered(Objects.requireNonNull(content), Http.ContentType.TXT);
        this.headers.remove(Http.HeaderType.CONTENT_LENGTH);
        this.headers.remove(Http.HeaderType.CONTENT_MD5);
        this.headers.remove(Http.HeaderType.TRANSFER_ENCODING);
    }

    /**
     * Causes the entire resource to be loaded. As this<br>
     * may cause several issues, so be advised. Use<br>
     * at your own risk.
     * @return the content
     */
    @Override
    @Deprecated
    public byte[] getContent() {
        return this.resource.getData();
    }

    @Override
    public Resource getContentAsResource() {
        return this.resource;
    }

    @Override
    public void setContent(byte[] content, Http.ContentType contentType) {
        setContent(Objects.requireNonNull(content));
        setContentType(Objects.requireNonNull(contentType));
    }

    @Override
    public void setContent(Resource resource) {
        this.resource = Objects.requireNonNull(resource);
        if(resource instanceof ResourceEmpty) {
            return;
        }
        setContentType(resource.getContentType());
    }

    @Override
    public String getProtocol() {
        return PROTOCOL;
    }

    @Override
    public Client getClient() {
        return this.client;
    }

    @Override
    public void setSecurityPolicy(HttpSecurityPolicy securityPolicy) {
        this.securityPolicy = Objects.requireNonNull(securityPolicy);
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.securityPolicy;
    }

    @Override
    public IBodyContentHandler getBodyContentHandler() {
        return this.messageStrategy.getContentHandler();
    }

    @Override
    public boolean isSending() {
        return this.messageStrategy != null;
    }

    @Override
    public boolean isSendingComplete() {
        return this.messageStrategy != null && this.messageStrategy.getContentHandler().isFinished();
    }


    @SuppressWarnings("unchecked")
    private <T> T[] getParseableList(Http.HeaderType headerType, T typeObject) {
        if(!List.of(typeObject.getClass().getInterfaces()).contains(Parseable.class))
            throw new RuntimeException("TypeObject's class is not implementing Parseable!");

        if(!this.hasHeader(headerType) || this.headers.get(headerType) == null)
            return (T[]) Array.newInstance(typeObject.getClass(), 0);

        String listString = this.headers.get(headerType);
        String[] split = listString.split(",");
        List<Parseable> list = new ArrayList<>();

        for (String s : split) {
            Parseable p = ((Parseable) typeObject).byString(s.trim());
            if(p != null) {
                list.add(p);
            }
        }

        T[] array = (T[]) Array.newInstance(typeObject.getClass(), list.size());
        for(int i = 0; i < list.size(); i++) {
            array[i] = (T) list.get(i);
        }

        return array;
    }

    private void setParseableList(Http.HeaderType headerType, Parseable... elements) {
        StringBuilder builder = new StringBuilder();
        if(Objects.requireNonNull(elements).length > 0) {
            for(Parseable element : elements) {
                builder.append(element.toString()).append(", ");
            }
            builder.delete(builder.length()-2, builder.length());
            this.headers.put(Objects.requireNonNull(headerType), builder.toString());
        } else {
            this.headers.remove(Objects.requireNonNull(headerType));
        }
    }

    private Optional<Pair<String, String>> getBasicAuthFor(Http.HeaderType headerType) {
        Objects.requireNonNull(headerType);

        if(!this.headers.containsKey(headerType) || this.headers.get(headerType) == null)
            return Optional.empty();

        String[] split = this.headers.get(headerType).trim().split(" ");
        String name = split[0];
        String value = split[1];

        if(split.length != 2 || !"BASIC".equalsIgnoreCase(name)) {
            return Optional.empty();
        }

        String auth = new String(Base64.getDecoder().decode(value));
        int index = auth.indexOf(':');

        if(index < 0)
            throw new HttpProtocolException("Invalid " + headerType + "! Basic auth value is missing a colon!");

        String user = auth.substring(0, index);
        String password = auth.substring(index + 1);

        return Optional.of(new Pair<>(user, password));
    }

    private void setBasicAuthFor(Http.HeaderType headerType, String username, String password) {
        Objects.requireNonNull(headerType);
        Objects.requireNonNull(username);
        Objects.requireNonNull(password);

        String decoded = username + ":" + password;
        String encoded = Base64.getEncoder().encodeToString(decoded.getBytes());
        headers.put(headerType, "Basic "+encoded);
    }

    private void reset() {
        this.headers.clear();
        this.customHeaders.clear();
        this.trailers.clear();
        this.customTrailers.clear();
        this.resource = new ResourceEmpty();
        this.messageStrategy = null;
    }

    private void execute() {
        this.messageStrategy.execute();
    }

    @Override
    public HttpMessageImpl clone() {
        HttpMessageImpl message = new HttpMessageImpl();
        return clone(message);
    }

    public HttpMessageImpl clone(HttpMessageImpl message) {
        message.headers.putAll(this.headers);
        message.customHeaders.putAll(this.customHeaders);
        message.trailers.putAll(this.trailers);
        message.customTrailers.putAll(this.customTrailers);
        message.setContent(this.resource);
        message.setSecurityPolicy(this.getSecurityPolicy());
        return message;
    }
}
