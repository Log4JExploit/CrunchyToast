/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.impl;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Client;
import github.log4jexploit.crunchytoast.general.Parseable;
import github.log4jexploit.crunchytoast.http.endpoint.HttpResource;
import github.log4jexploit.crunchytoast.http.endpoint.HttpResourceBuffered;
import github.log4jexploit.crunchytoast.http.endpoint.HttpResourceSplintered;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.message.inf.Strategy;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.strategy.StrategyMessageReceiveImpl;
import github.log4jexploit.crunchytoast.strategy.StrategyMessageSendImpl;

import java.lang.reflect.Array;
import java.util.*;

public class HttpMessageImpl implements HttpMessage {

    private static final String PROTOCOL = "HTTP/1.1";

    protected Map<Http.HeaderType, String> headers;
    protected Map<String, String> customHeaders;

    protected Map<Http.HeaderType, String> trailers;
    protected Map<String, String> customTrailers;

    protected HttpSecurityPolicy securityPolicy;
    protected Strategy.Message messageStrategy;
    protected HttpResource resource;
    protected Client client;


    public HttpMessageImpl() {
        this.customHeaders = new HashMap<>();
        this.headers = new HashMap<>();

        this.customTrailers = new HashMap<>();
        this.trailers = new HashMap<>();

        this.resource = new HttpResourceSplintered(Http.ContentType.TXT);
        this.securityPolicy = HttpSecurityPolicy.createDefault();
    }


    @Override
    public IBodyContentWriter send(Client client) {
        this.client = client;
        this.messageStrategy = new StrategyMessageSendImpl();
        this.messageStrategy.initialize(this.client, this);
        execute();
        return (IBodyContentWriter) messageStrategy.getContentHandler();
    }

    @Override
    public IBodyContentReader receive(Client client) {
        reset();
        this.client = client;
        this.messageStrategy = new StrategyMessageReceiveImpl();
        this.messageStrategy.initialize(this.client, this);
        execute();
        return (IBodyContentReader) messageStrategy.getContentHandler();
    }

    @Override
    public void sendTrailers() {
        this.messageStrategy.executeTrailers();
    }

    @Override
    public void receiveTrailers() {
        this.messageStrategy.executeTrailers();
    }


    @Override
    public void setKeepAlive(boolean keepAlive) {
        this.headers.put(Http.HeaderType.CONNECTION, keepAlive ? "keep-alive" : "close");
    }

    @Override
    public boolean isKeepAlive() {
        return "keep-alive".equalsIgnoreCase(this.headers.get(Http.HeaderType.CONNECTION));
    }

    @Override
    public void setServer(String server) {
        this.headers.put(Http.HeaderType.SERVER, server);
    }

    @Override
    public String getServer() {
        return this.headers.get(Http.HeaderType.SERVER);
    }

    /**
     * Use <code>setContentAsResource()</code> instead. This might<br>
     * be removed in a future version.
     * @param length the content's length
     */
    @Deprecated
    @Override
    public void setContentLength(long length) {
        this.headers.put(Http.HeaderType.CONTENT_LENGTH, String.valueOf(length));
    }

    @Override
    public long getContentLength() {
        return this.headers.containsKey(Http.HeaderType.CONTENT_LENGTH) ?
                Integer.parseInt(this.getHeader(Http.HeaderType.CONTENT_LENGTH)) : 0;
    }

    @Override
    public void setContentTransferEncoding(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.CONTENT_TRANSFER_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getContentTransferEncoding() {
        return getParseableList(Http.HeaderType.CONTENT_TRANSFER_ENCODING, Http.Encoding.BASE64);
    }

    @Override
    public void setContentEncodings(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.CONTENT_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getContentEncodings() {
        return getParseableList(Http.HeaderType.CONTENT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public void setTrailerFields(Http.HeaderType[] headerTypes) {
        setParseableList(Http.HeaderType.TRAILER, headerTypes);
    }

    @Override
    public Http.HeaderType[] getTrailerFields() {
        return getParseableList(Http.HeaderType.TRAILER, Http.HeaderType.values()[0]);
    }

    @Override
    public void setAcceptEncodings(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.ACCEPT_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getAcceptEncodings() {
        return getParseableList(Http.HeaderType.ACCEPT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public void setAcceptLanguages(Http.Language[] languages) {
        setParseableList(Http.HeaderType.ACCEPT_LANGUAGE, languages);
    }

    @Override
    public Http.Language[] getAcceptLanguages() {
        return getParseableList(Http.HeaderType.ACCEPT_LANGUAGE, Http.Language.values()[0]);
    }

    @Override
    public void setAcceptCharsets(Http.Charset[] charsets) {
        setParseableList(Http.HeaderType.ACCEPT_CHARSET, charsets);
    }

    @Override
    public Http.Charset[] getAcceptCharsets() {
        return getParseableList(Http.HeaderType.ACCEPT_CHARSET, Http.Charset.values()[0]);
    }

    @Override
    public void setContentType(Http.ContentType contentType) {
        this.headers.put(Http.HeaderType.CONTENT_TYPE, contentType.toString());
    }

    @Override
    public Http.ContentType getContentType() {
        return Http.ContentType.values()[0].byString(this.headers.get(Http.HeaderType.CONTENT_TYPE));
    }

    @Override
    public void setChunkedTransfer(boolean chunked) {
        if(chunked) {
            this.headers.put(Http.HeaderType.TRANSFER_ENCODING, "chunked");
            this.headers.remove(Http.HeaderType.CONTENT_LENGTH);
        } else {
            this.headers.remove(Http.HeaderType.TRANSFER_ENCODING);
            this.headers.put(Http.HeaderType.CONTENT_LENGTH, "0");
            this.resource = new HttpResourceBuffered(new byte[0], Http.ContentType.TXT);
        }
    }

    @Override
    public boolean isChunkedTransfer() {
        return this.headers.containsKey(Http.HeaderType.TRANSFER_ENCODING) &&
                this.headers.get(Http.HeaderType.TRANSFER_ENCODING).startsWith("chunked");
    }

    @Override
    public void setCacheControl(String cacheControl) {
        this.headers.put(Http.HeaderType.CACHE_CONTROL, cacheControl);
    }

    @Override
    public String getCacheControl() {
        return this.headers.get(Http.HeaderType.CACHE_CONTROL);
    }

    @Override
    public void setCookie(String cookie) {
        this.headers.put(Http.HeaderType.COOKIE, cookie);
    }

    @Override
    public String getCookie() {
        return this.headers.get(Http.HeaderType.COOKIE);
    }

    @Override
    public void setSetCookie(String cookie) {
        this.headers.put(Http.HeaderType.SET_COOKIE, cookie);
    }

    @Override
    public String getSetCookie() {
        return this.headers.get(Http.HeaderType.SET_COOKIE);
    }

    @Override
    public void setDate(String date) {
        this.headers.put(Http.HeaderType.DATE, date);
    }

    @Override
    public String getDate() {
        return this.headers.get(Http.HeaderType.DATE);
    }

    @Override
    public void setHost(String host) {
        this.headers.put(Http.HeaderType.HOST, host);
    }

    @Override
    public String getHost() {
        return this.headers.get(Http.HeaderType.HOST);
    }

    @Override
    public void setLocation(String location) {
        this.headers.put(Http.HeaderType.LOCATION, location);
    }

    @Override
    public String getLocation() {
        return this.headers.get(Http.HeaderType.LOCATION);
    }

    @Override
    public void setUserAgent(String userAgent) {
        this.headers.put(Http.HeaderType.USER_AGENT, userAgent);
    }

    @Override
    public String getUserAgent() {
        return this.headers.get(Http.HeaderType.USER_AGENT);
    }

    @Override
    public void setVia(String via) {
        this.headers.put(Http.HeaderType.VIA, via);
    }

    @Override
    public String getVia() {
        return this.headers.get(Http.HeaderType.VIA);
    }

    @Override
    public void setProxyAuthorization(String username, String password) {
        this.setAuthFor(Http.HeaderType.PROXY_AUTHORIZATION, username, password);
    }

    @Override
    public String[] getProxyAuthorization() {
        return getAuthFor(Http.HeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public boolean hasProxyAuth() {
        return this.headers.containsKey(Http.HeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public void setReferer(String referer) {
        this.headers.put(Http.HeaderType.REFERER, referer);
    }

    @Override
    public String getReferer() {
        return this.headers.get(Http.HeaderType.REFERER);
    }

    @Override
    public void addTrailer(Http.HeaderType headerType, String value) {
        this.trailers.put(headerType, value);
    }

    @Override
    public void removeTrailer(Http.HeaderType headerType) {
        this.trailers.remove(headerType);
    }

    @Override
    public void setTrailer(Http.HeaderType headerType, String value) {
        this.trailers.put(headerType, value);
    }

    @Override
    public String getTrailer(Http.HeaderType headerType) {
        return trailers.get(headerType);
    }

    @Override
    public void setCustomTrailer(String key, String value) {
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.trailers.put(headerType, value);
        else
            this.customTrailers.put(key, value);
    }

    @Override
    public String getCustomTrailer(String key) {
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            return this.trailers.get(headerType);
        else
            return this.customTrailers.get(key);
    }

    @Override
    public void setAuthorization(String username, String password) {
        this.setAuthFor(Http.HeaderType.AUTHORIZATION, username, password);
    }

    @Override
    public String[] getAuthorization() {
        return getAuthFor(Http.HeaderType.AUTHORIZATION);
    }

    @Override
    public void setWWWAuthenticate(boolean value) {
        if(value)
            this.headers.put(Http.HeaderType.WWW_AUTHENTICATE, "Basic");
        else
            this.headers.remove(Http.HeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public boolean isWWWAuthenticate() {
        return this.headers.containsKey(Http.HeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public void setWarning(String warning) {
        this.headers.put(Http.HeaderType.WARNING, warning);
    }

    @Override
    public String getWarning() {
        return this.headers.get(Http.HeaderType.WARNING);
    }

    @Override
    public void setUpgradeInsecureRequests(boolean enabled) {
        if(enabled)
            this.headers.put(Http.HeaderType.UPGRADE_INSECURE_REQUESTS, "1");
        else
            this.headers.remove(Http.HeaderType.UPGRADE_INSECURE_REQUESTS);
    }

    @Override
    public boolean isUpgradeInsecureRequests() {
        return this.headers.containsKey(Http.HeaderType.UPGRADE_INSECURE_REQUESTS) &&
                "1".equalsIgnoreCase(this.headers.get(Http.HeaderType.UPGRADE_INSECURE_REQUESTS));
    }

    @Override
    public void setHeader(Http.HeaderType headerType, String value) {
        this.headers.put(headerType, value);
    }

    @Override
    public String getHeader(Http.HeaderType headerType) {
        return this.headers.get(headerType);
    }

    @Override
    public void setCustomHeader(String key, String value) {
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.headers.put(headerType, value);
        else
            this.customHeaders.put(key.toLowerCase(), value);
    }

    @Override
    public void removeHeader(String key) {
        if(key == null)
            return;
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.removeHeader(headerType);
        else
            this.customHeaders.remove(key.toLowerCase());
    }

    @Override
    public void removeHeader(Http.HeaderType headerType) {
        if(headerType == null)
            return;
        this.headers.remove(headerType);
    }

    @Override
    public String getCustomHeader(String key) {
        if(key == null)
            return null;
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.CONTENT_TYPE.byString(key)) != Http.HeaderType.CUSTOM) {
            return this.headers.get(headerType);
        }
        return this.customHeaders.get(key);
    }

    @Override
    public Map<Http.HeaderType, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, String> getCustomHeaders() {
        return this.customHeaders;
    }

    @Override
    public Map<Http.HeaderType, String> getTrailers() {
        return this.trailers;
    }

    @Override
    public Map<String, String> getCustomTrailers() {
        return this.customTrailers;
    }

    @Override
    public void setContent(byte[] content) {
        this.resource = new HttpResourceBuffered(content, Http.ContentType.TXT);
        this.headers.remove(Http.HeaderType.CONTENT_LENGTH);
        this.headers.remove(Http.HeaderType.CONTENT_MD5);
        this.headers.remove(Http.HeaderType.TRANSFER_ENCODING);
    }

    /**
     * Causes the entire resource to be loaded. As this<br>
     * may cause several issues, you are advised to use it<br>
     * at your own risk.
     * @return the content
     */
    @Override
    @Deprecated
    public byte[] getContent() {
        return this.resource.getData();
    }

    @Override
    public HttpResource getContentAsResource() {
        return this.resource;
    }

    @Override
    public void setContent(byte[] content, Http.ContentType contentType) {
        setContent(content);
        setContentType(contentType);
    }

    @Override
    public void setContent(HttpResource resource) {
        this.resource = resource;
        setContentType(resource.getContentType());
    }

    @Override
    public String getProtocol() {
        return PROTOCOL;
    }

    @Override
    public Client getClient() {
        return this.client;
    }

    @Override
            public void setSecurityPolicy(HttpSecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy.clone();
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.securityPolicy.clone();
    }

    @Override
    public IBodyContentHandler getBodyContentHandler() {
        return this.messageStrategy.getContentHandler();
    }

    @Override
    public boolean isSent() {
        return this.messageStrategy != null;
    }

    /**
     * Performs various checks to make sure the message is in a usable state.
     */
    @Override
    public void performChecks() {
        this.checkForRequestSmuggling();
        this.checkForIllegalTrailerSection();
        this.checkForKeepAlive();
        this.checkContentLength();
    }

    /**
     * Checks if a trailer section is present without a content body.
     */
    private void checkForIllegalTrailerSection() {
        if(!this.getHeaders().containsKey(Http.HeaderType.TRANSFER_ENCODING) &&
                !this.getHeaders().containsKey(Http.HeaderType.CONTENT_TYPE))
        {
            this.removeHeader(Http.HeaderType.TRAILER);
            this.getTrailers().clear();
            this.getCustomTrailers().clear();
        }
    }

    /**
     * Checks if a message contains multiple content bodies<br>
     * and removes the 'Content_Length' header, if multiple bodies where found.
     */
    private void checkForRequestSmuggling() {
        if(isChunkedTransfer() && getContentLength() > 0) {
            if(getSecurityPolicy().isDiscardWhenInvalid())
                throw new HttpProtocolException("ContentLength and TransferEncoding are both set!");
            removeHeader(Http.HeaderType.CONTENT_LENGTH);
        }
    }

    /**
     * Checks if a message doesn't contain a 'Connection' header and adds one, if required.
     */
    private void checkForKeepAlive() {
        if(!getHeaders().containsKey(Http.HeaderType.CONNECTION)) {
            setKeepAlive(getSecurityPolicy().isKeepAliveByDefault());
        }
    }

    /**
     * Checks if a message exceeds the maximum content length.
     */
    private void checkContentLength() {
        if(getTrailerFields().length > getSecurityPolicy().getMaxHeaderCount())
            throw new HttpProtocolException("Maximum trailer count exceeded!");
    }

    @SuppressWarnings("unchecked")
    private <T> T[] getParseableList(Http.HeaderType headerType, T typeObject) {
        if(!List.of(typeObject.getClass().getInterfaces()).contains(Parseable.class))
            throw new RuntimeException("Class is not implementing Parseable interface!");

        if(!this.headers.containsKey(headerType) || this.headers.get(headerType) == null)
            return (T[]) Array.newInstance(typeObject.getClass(), 0);

        String listString = this.headers.get(headerType);
        String[] split = listString.split(",");
        List<Parseable> list = new ArrayList<>();

        for (String s : split) {
            list.add(((Parseable) typeObject).byString(s.trim()));
        }

        T[] array = (T[]) Array.newInstance(typeObject.getClass(), list.size());
        for(int i = 0; i < list.size(); i++) {
            array[i] = (T) list.get(i);
        }

        return array;
    }

    private void setParseableList(Http.HeaderType headerType, Parseable... elements) {
        StringBuilder builder = new StringBuilder();
        for(Parseable element : elements) {
            builder.append(element.toString()).append(", ");
        }
        builder.delete(builder.length()-2, builder.length());
        this.headers.put(headerType, builder.toString());
    }

    private String[] getAuthFor(Http.HeaderType headerType) {
        if(!this.headers.containsKey(headerType) || this.headers.get(headerType) == null)
            return new String[0];

        String auth = this.headers.get(headerType).split(" ")[1];
        auth = new String(Base64.getDecoder().decode(auth));

        if(!auth.contains(":"))
            throw new HttpProtocolException("Invalid "+headerType.toString()+" value!");

        return auth.split(":");
    }

    private void setAuthFor(Http.HeaderType headerType, String username, String password) {
        String decoded = username + ":" + password;
        String encoded = Base64.getEncoder().encodeToString(decoded.getBytes());
        headers.put(headerType, "Basic "+encoded);
    }

    private void reset() {
        this.headers.clear();
        this.customHeaders.clear();
        this.trailers.clear();
        this.customTrailers.clear();
        this.resource = new HttpResourceBuffered(new byte[0], Http.ContentType.TXT);
        this.client = null;
        this.messageStrategy = null;
    }

    private void execute() {
        if(this.securityPolicy == null)
            this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.messageStrategy.execute();
    }

    @Override
    public HttpMessage clone() {
        HttpMessageImpl message = new HttpMessageImpl();
        message.headers.putAll(this.headers);
        message.customHeaders.putAll(this.customHeaders);
        message.trailers.putAll(this.trailers);
        message.customTrailers.putAll(this.customTrailers);
        return message;
    }
}
