/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.message.impl;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.Parseable;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.resource.Resource;
import github.log4jexploit.crunchytoast.resource.ResourceBuffered;
import github.log4jexploit.crunchytoast.resource.ResourceEmpty;
import github.log4jexploit.crunchytoast.server.Client;
import github.log4jexploit.crunchytoast.strategy.Strategy;
import github.log4jexploit.crunchytoast.strategy.StrategyMessageReceiveImpl;
import github.log4jexploit.crunchytoast.strategy.StrategyMessageSendImpl;

import java.lang.reflect.Array;
import java.util.*;

public class HttpMessageImpl implements HttpMessage {

    private static final String PROTOCOL = "HTTP/1.1";

    protected Map<Http.HeaderType, String> headers;
    protected Map<String, String> customHeaders;

    protected Map<Http.HeaderType, String> trailers;
    protected Map<String, String> customTrailers;

    protected HttpSecurityPolicy securityPolicy;
    protected Strategy.Message messageStrategy;
    protected Resource resource;
    protected Client client;


    public HttpMessageImpl() {
        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.resource = new ResourceEmpty();

        this.customTrailers = new HashMap<>();
        this.customHeaders = new HashMap<>();
        this.trailers = new HashMap<>();
        this.headers = new HashMap<>();
    }


    @Override
    public IBodyContentWriter send(Client client) {
        this.client = client;
        this.securityPolicy = (HttpSecurityPolicy) this.client.getSecurityPolicy();
        this.messageStrategy = new StrategyMessageSendImpl();
        this.messageStrategy.initialize(this.client, this);
        execute();
        return (IBodyContentWriter) messageStrategy.getContentHandler();
    }

    @Override
    public IBodyContentReader receive(Client client) {
        reset();
        this.client = client;
        this.securityPolicy = (HttpSecurityPolicy) this.client.getSecurityPolicy();
        this.messageStrategy = new StrategyMessageReceiveImpl();
        this.messageStrategy.initialize(this.client, this);
        execute();
        return (IBodyContentReader) messageStrategy.getContentHandler();
    }

    @Override
    public void performChecks() {
        checkIllegalTrailerSection();
        checkRequestSmuggling();
        checkHeaderCount();
        checkTrailerCount();
    }

    /**
     * Checks if a trailer section is present without a content body.
     */
    private void checkIllegalTrailerSection() {
        if(this.getHeaders().containsKey(Http.HeaderType.CONTENT_TYPE)) {
            if(this.getHeaders().containsKey(Http.HeaderType.TRAILER)) {
                if(getSecurityPolicy().isDiscardWhenInvalid()) {
                    throw new HttpProtocolException("Request contains illegal trailer section!");
                }

                removeHeader(Http.HeaderType.TRAILER);
                trailers.clear();
                customTrailers.clear();
            }
        }
    }

    /**
     * Checks if a message contains multiple content bodies<br>
     * and removes the 'Content_Length' header, if multiple bodies were found.
     */
    private void checkRequestSmuggling() {
        if(this.isChunkedTransfer() && this.getContentLength() > 0) {
            if(this.getSecurityPolicy().isDiscardWhenInvalid())
                throw new HttpProtocolException("ContentLength and TransferEncoding are both set!");
            this.removeHeader(Http.HeaderType.CONTENT_LENGTH);
        }
    }

    /**
     * Checks if a message exceeds the maximum header count
     */
    private void checkHeaderCount() {
        if(this.getHeaders().size() + this.getCustomHeaders().size()
                > this.getSecurityPolicy().getMaxHeaderCount()) {
            throw new HttpProtocolException("Maximum header count exceeded!");
        }
    }

    /**
     * Checks if a message exceeds the maximum trailer count
     */
    private void checkTrailerCount() {
        if(this.getTrailerFields().length + this.getCustomTrailers().size()
                > this.getSecurityPolicy().getMaxHeaderCount()) {
            throw new HttpProtocolException("Maximum trailer count exceeded!");
        }
    }


    @Override
    public void sendTrailers() {
        this.messageStrategy.executeTrailers();
    }

    @Override
    public void receiveTrailers() {
        this.messageStrategy.executeTrailers();
    }


    @Override
    public void setKeepAlive(boolean keepAlive) {
        this.headers.put(Http.HeaderType.CONNECTION, keepAlive ? "keep-alive" : "closed");
    }

    @Override
    public boolean isKeepAlive() {
        if(!hasHeader(Http.HeaderType.CONNECTION)) {
            return false;
        }
        return "keep-alive".equalsIgnoreCase(this.headers.get(Http.HeaderType.CONNECTION));
    }

    @Override
    public void setServer(String server) {
        this.headers.put(Http.HeaderType.SERVER, server.trim());
    }

    @Override
    public String getServer() {
        return this.headers.get(Http.HeaderType.SERVER);
    }

    /**
     * Use <code>setContentAsResource()</code> instead. This might<br>
     * be removed in a future version.
     * @param length the content's length
     */
    @Deprecated
    @Override
    public void setContentLength(long length) {
        this.headers.put(Http.HeaderType.CONTENT_LENGTH, String.valueOf(length));
    }

    @Override
    public long getContentLength() {
        return this.headers.containsKey(Http.HeaderType.CONTENT_LENGTH) ?
                Long.parseLong(this.getHeader(Http.HeaderType.CONTENT_LENGTH)) : 0;
    }

    @Override
    public void setContentTransferEncoding(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.CONTENT_TRANSFER_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getContentTransferEncoding() {
        return getParseableList(Http.HeaderType.CONTENT_TRANSFER_ENCODING, Http.Encoding.BASE64);
    }

    @Override
    public List<Http.Encoding> getContentTransferEncodingList() {
        Http.Encoding[] array = getContentTransferEncoding();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setContentEncodings(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.CONTENT_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getContentEncodings() {
        return getParseableList(Http.HeaderType.CONTENT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public List<Http.Encoding> getContentEncodingsList() {
        Http.Encoding[] array = getContentEncodings();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setTrailerFields(Http.HeaderType[] headerTypes) {
        setParseableList(Http.HeaderType.TRAILER, headerTypes);
    }

    @Override
    public Http.HeaderType[] getTrailerFields() {
        return getParseableList(Http.HeaderType.TRAILER, Http.HeaderType.values()[0]);
    }

    @Override
    public void setAcceptEncodings(Http.Encoding[] encodings) {
        setParseableList(Http.HeaderType.ACCEPT_ENCODING, encodings);
    }

    @Override
    public Http.Encoding[] getAcceptEncodings() {
        return getParseableList(Http.HeaderType.ACCEPT_ENCODING, Http.Encoding.values()[0]);
    }

    @Override
    public List<Http.Encoding> getAcceptEncodingsList() {
        Http.Encoding[] array = getAcceptEncodings();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setAcceptLanguages(Http.Language[] languages) {
        setParseableList(Http.HeaderType.ACCEPT_LANGUAGE, languages);
    }

    @Override
    public Http.Language[] getAcceptLanguages() {
        return getParseableList(Http.HeaderType.ACCEPT_LANGUAGE, Http.Language.values()[0]);
    }

    @Override
    public List<Http.Language> getAcceptLanguagesList() {
        Http.Language[] array = getAcceptLanguages();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setAcceptCharsets(Http.Charset[] charsets) {
        setParseableList(Http.HeaderType.ACCEPT_CHARSET, charsets);
    }

    @Override
    public Http.Charset[] getAcceptCharsets() {
        return getParseableList(Http.HeaderType.ACCEPT_CHARSET, Http.Charset.values()[0]);
    }

    @Override
    public List<Http.Charset> getAcceptCharsetsList() {
        Http.Charset[] array = getAcceptCharsets();
        if(array.length == 0) {
            return new ArrayList<>();
        }
        return List.of(array);
    }

    @Override
    public void setContentType(Http.ContentType contentType) {
        this.headers.put(Http.HeaderType.CONTENT_TYPE, contentType.toString());
    }

    @Override
    public Http.ContentType getContentType() {
        return Http.ContentType.values()[0].byString(this.headers.get(Http.HeaderType.CONTENT_TYPE));
    }

    @Override
    public void setChunkedTransfer(boolean chunked) {
        if(chunked) {
            this.headers.put(Http.HeaderType.TRANSFER_ENCODING, "chunked");
            this.headers.remove(Http.HeaderType.CONTENT_LENGTH);
        } else {
            this.headers.remove(Http.HeaderType.TRANSFER_ENCODING);
            this.headers.put(Http.HeaderType.CONTENT_LENGTH, "0");
            this.resource = new ResourceEmpty();
        }
    }

    @Override
    public boolean isChunkedTransfer() {
        return this.headers.containsKey(Http.HeaderType.TRANSFER_ENCODING) &&
                this.headers.get(Http.HeaderType.TRANSFER_ENCODING).startsWith("chunked");
    }

    @Override
    public void setCacheControl(String cacheControl) {
        this.headers.put(Http.HeaderType.CACHE_CONTROL, cacheControl);
    }

    @Override
    public String getCacheControl() {
        return this.headers.get(Http.HeaderType.CACHE_CONTROL);
    }

    @Override
    public void setCookie(String cookie) {
        this.headers.put(Http.HeaderType.COOKIE, cookie);
    }

    @Override
    public String getCookie() {
        return this.headers.get(Http.HeaderType.COOKIE);
    }

    @Override
    public void setSetCookie(String cookie) {
        this.headers.put(Http.HeaderType.SET_COOKIE, cookie);
    }

    @Override
    public String getSetCookie() {
        return this.headers.get(Http.HeaderType.SET_COOKIE);
    }

    @Override
    public void setDate(String date) {
        this.headers.put(Http.HeaderType.DATE, date);
    }

    @Override
    public String getDate() {
        return this.headers.get(Http.HeaderType.DATE);
    }

    @Override
    public void setHost(String host) {
        this.headers.put(Http.HeaderType.HOST, host);
    }

    @Override
    public String getHost() {
        return this.headers.get(Http.HeaderType.HOST);
    }

    @Override
    public void setLocation(String location) {
        this.headers.put(Http.HeaderType.LOCATION, location);
    }

    @Override
    public String getLocation() {
        return this.headers.get(Http.HeaderType.LOCATION);
    }

    @Override
    public void setUserAgent(String userAgent) {
        this.headers.put(Http.HeaderType.USER_AGENT, userAgent);
    }

    @Override
    public String getUserAgent() {
        return this.headers.get(Http.HeaderType.USER_AGENT);
    }

    @Override
    public void setVia(String via) {
        this.headers.put(Http.HeaderType.VIA, via);
    }

    @Override
    public String getVia() {
        return this.headers.get(Http.HeaderType.VIA);
    }

    @Override
    public void setProxyAuthorization(String username, String password) {
        this.setAuthFor(Http.HeaderType.PROXY_AUTHORIZATION, username, password);
    }

    @Override
    public String[] getProxyAuthorization() {
        return getAuthFor(Http.HeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public boolean hasProxyAuth() {
        return this.headers.containsKey(Http.HeaderType.PROXY_AUTHORIZATION);
    }

    @Override
    public void setReferer(String referer) {
        this.headers.put(Http.HeaderType.REFERER, referer);
    }

    @Override
    public String getReferer() {
        return this.headers.get(Http.HeaderType.REFERER);
    }

    @Override
    public boolean hasTrailer(Http.HeaderType headerType) {
        return this.trailers.containsKey(headerType);
    }

    @Override
    public void removeTrailer(Http.HeaderType headerType) {
        this.trailers.remove(headerType);
    }

    @Override
    public void setTrailer(Http.HeaderType headerType, String value) {
        this.trailers.put(headerType, value);
    }

    @Override
    public String getTrailer(Http.HeaderType headerType) {
        return trailers.get(headerType);
    }

    @Override
    public boolean hasCustomTrailer(String name) {
        return this.customTrailers.containsKey(name);
    }

    @Override
    public void setCustomTrailer(String key, String value) {
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.trailers.put(headerType, value);
        else
            this.customTrailers.put(key, value);
    }

    @Override
    public String getCustomTrailer(String key) {
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            return this.trailers.get(headerType);
        else
            return this.customTrailers.get(key);
    }

    @Override
    public void setAuthorization(String username, String password) {
        this.setAuthFor(Http.HeaderType.AUTHORIZATION, username, password);
    }

    @Override
    public String[] getAuthorization() {
        return getAuthFor(Http.HeaderType.AUTHORIZATION);
    }

    @Override
    public void setWWWAuthenticate(boolean value) {
        if(value)
            this.headers.put(Http.HeaderType.WWW_AUTHENTICATE, "Basic");
        else
            this.headers.remove(Http.HeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public boolean isWWWAuthenticate() {
        return this.headers.containsKey(Http.HeaderType.WWW_AUTHENTICATE);
    }

    @Override
    public void setWarning(String warning) {
        this.headers.put(Http.HeaderType.WARNING, warning);
    }

    @Override
    public String getWarning() {
        return this.headers.get(Http.HeaderType.WARNING);
    }

    @Override
    public void setUpgradeInsecureRequests(boolean enabled) {
        if(enabled)
            this.headers.put(Http.HeaderType.UPGRADE_INSECURE_REQUESTS, "1");
        else
            this.headers.remove(Http.HeaderType.UPGRADE_INSECURE_REQUESTS);
    }

    @Override
    public boolean isUpgradeInsecureRequests() {
        return this.headers.containsKey(Http.HeaderType.UPGRADE_INSECURE_REQUESTS) &&
                "1".equalsIgnoreCase(this.headers.get(Http.HeaderType.UPGRADE_INSECURE_REQUESTS));
    }

    @Override
    public boolean hasHeader(Http.HeaderType headerType) {
        return this.headers.containsKey(headerType);
    }

    @Override
    public void setHeader(Http.HeaderType headerType, String value) {
        this.headers.put(headerType, value);
    }

    @Override
    public String getHeader(Http.HeaderType headerType) {
        return this.headers.get(headerType);
    }

    @Override
    public boolean hasCustomHeader(String name) {
        return this.customHeaders.containsKey(name.toLowerCase());
    }

    @Override
    public void setCustomHeader(String key, String value) {
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.headers.put(headerType, value);
        else
            this.customHeaders.put(key.toLowerCase(), value);
    }

    @Override
    public void removeHeader(String key) {
        if(key == null)
            return;
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.values()[0].byString(key)) != Http.HeaderType.CUSTOM)
            this.removeHeader(headerType);
        else
            this.customHeaders.remove(key.toLowerCase());
    }

    @Override
    public void removeHeader(Http.HeaderType headerType) {
        if(headerType == null)
            return;
        this.headers.remove(headerType);
    }

    @Override
    public String getCustomHeader(String key) {
        if(key == null)
            return null;
        Http.HeaderType headerType;
        if((headerType = Http.HeaderType.CONTENT_TYPE.byString(key)) != Http.HeaderType.CUSTOM) {
            return this.headers.get(headerType);
        }
        return this.customHeaders.get(key);
    }

    @Override
    public Map<Http.HeaderType, String> getHeaders() {
        return this.headers;
    }

    @Override
    public Map<String, String> getCustomHeaders() {
        return this.customHeaders;
    }

    @Override
    public Map<Http.HeaderType, String> getTrailers() {
        return this.trailers;
    }

    @Override
    public Map<String, String> getCustomTrailers() {
        return this.customTrailers;
    }

    @Override
    public void setContent(byte[] content) {
        this.resource = new ResourceBuffered(content, Http.ContentType.TXT);
        this.headers.remove(Http.HeaderType.CONTENT_LENGTH);
        this.headers.remove(Http.HeaderType.CONTENT_MD5);
        this.headers.remove(Http.HeaderType.TRANSFER_ENCODING);
    }

    /**
     * Causes the entire resource to be loaded. As this<br>
     * may cause several issues, so be advised. Use<br>
     * at your own risk.
     * @return the content
     */
    @Override
    @Deprecated
    public byte[] getContent() {
        return this.resource.getData();
    }

    @Override
    public Resource getContentAsResource() {
        return this.resource;
    }

    @Override
    public void setContent(byte[] content, Http.ContentType contentType) {
        setContent(content);
        setContentType(contentType);
    }

    @Override
    public void setContent(Resource resource) {
        this.resource = resource;
        if(resource instanceof ResourceEmpty) {

            return;
        }
        setContentType(resource.getContentType());
    }

    @Override
    public String getProtocol() {
        return PROTOCOL;
    }

    @Override
    public Client getClient() {
        return this.client;
    }

    @Override
    public void setSecurityPolicy(HttpSecurityPolicy securityPolicy) {
        this.securityPolicy = securityPolicy.clone();
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.securityPolicy.clone();
    }

    @Override
    public IBodyContentHandler getBodyContentHandler() {
        return this.messageStrategy.getContentHandler();
    }

    @Override
    public boolean isSending() {
        return this.messageStrategy != null;
    }

    @Override
    public boolean isSendingComplete() {
        return this.messageStrategy != null && this.messageStrategy.getContentHandler().isFinished();
    }


    @SuppressWarnings("unchecked")
    private <T> T[] getParseableList(Http.HeaderType headerType, T typeObject) {
        if(!List.of(typeObject.getClass().getInterfaces()).contains(Parseable.class))
            throw new RuntimeException("TypeObject's class is not implementing Parseable!");

        if(!this.hasHeader(headerType) || this.headers.get(headerType) == null)
            return (T[]) Array.newInstance(typeObject.getClass(), 0);

        String listString = this.headers.get(headerType);
        String[] split = listString.split(",");
        List<Parseable> list = new ArrayList<>();

        for (String s : split) {
            Parseable p = ((Parseable) typeObject).byString(s.trim());
            if(p != null) {
                list.add(p);
            }
        }

        T[] array = (T[]) Array.newInstance(typeObject.getClass(), list.size());
        for(int i = 0; i < list.size(); i++) {
            array[i] = (T) list.get(i);
        }

        return array;
    }

    private void setParseableList(Http.HeaderType headerType, Parseable... elements) {
        StringBuilder builder = new StringBuilder();
        for(Parseable element : elements) {
            builder.append(element.toString()).append(", ");
        }
        builder.delete(builder.length()-2, builder.length());
        this.headers.put(headerType, builder.toString());
    }

    private String[] getAuthFor(Http.HeaderType headerType) {
        if(!this.headers.containsKey(headerType) || this.headers.get(headerType) == null)
            return new String[0];

        String auth = this.headers.get(headerType).split(" ")[1];
        auth = new String(Base64.getDecoder().decode(auth));

        if(!auth.contains(":"))
            throw new HttpProtocolException("Invalid "+headerType.toString()+" value!");

        return auth.split(":");
    }

    private void setAuthFor(Http.HeaderType headerType, String username, String password) {
        String decoded = username + ":" + password;
        String encoded = Base64.getEncoder().encodeToString(decoded.getBytes());
        headers.put(headerType, "Basic "+encoded);
    }

    private void reset() {
        this.headers.clear();
        this.customHeaders.clear();
        this.trailers.clear();
        this.customTrailers.clear();
        this.resource = new ResourceEmpty();
        this.client = null;
        this.messageStrategy = null;
    }

    private void execute() {
        if(this.securityPolicy == null)
            this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.messageStrategy.execute();
    }

    @Override
    public HttpMessageImpl clone() {
        HttpMessageImpl message = new HttpMessageImpl();
        message.headers.putAll(this.headers);
        message.customHeaders.putAll(this.customHeaders);
        message.trailers.putAll(this.trailers);
        message.customTrailers.putAll(this.customTrailers);
        message.setContent(this.resource);
        return message;
    }
}
