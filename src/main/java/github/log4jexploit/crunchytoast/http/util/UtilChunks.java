/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.util;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.general.CommonText;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;

public class UtilChunks {

    /**
     * Reads a chunk from the given InputStream
     * @param in The source
     * @return the encoded chunk data
     */
    public byte[] readEncodedChunk(InputStream in) {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();

        UncheckedIOWriter writer = new UncheckedIOWriter(buffer);
        UncheckedIOReader reader = new UncheckedIOReader(in);

        String hexLength = reader.nextLine().toUpperCase();
        int length = hexLength.length();
        int chunkSize = 0;

        for(int i = 0; i < length; i++) {
            char c = Character.toUpperCase(hexLength.charAt(i));
            int v = c >= '0' && c <= '9' ? c - '0' : c - 'A' + 10;
            chunkSize += (int) (Math.pow(16, length - i - 1) * v);
        }

        byte[] chunk = new byte[chunkSize];

        for(int i = 0; i < chunkSize; i++)
            chunk[i] = reader.read();

        reader.read();

        writer.write(chunk);
        writer.flush();

        return chunk;

        reader.read();

        for(int i = 0; i < trailerList.length; i++) {
            String line = reader.nextLine();
            StringBuilder builder = new StringBuilder(line);

            String key = builder.substring(0, builder.indexOf(":")).trim();
            String value = builder.substring(builder.indexOf(":")+1, builder.length()).trim();

            Http.HeaderType type = Http.HeaderType.byString(key);

            if(type == null)
                throw new HttpProtocolException(CommonText.HTTP_UNKNOWN_TRAILER);

            if(!isTrailerRegistered(type))
                throw new HttpProtocolException(CommonText.HTTP_ILLEGAL_TRAILER);

            this.trailers.put(type, value);
        }

        this.readingFinished = true;
        return chunk;
    }

    /**
     * Writes a chunk to the given OutputStream
     * @param out The destination
     * @param encodedBytes The encoded data to send
     */
    public void writeEncodedChunk(OutputStream out, byte[] encodedBytes) {

    }

}
