/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.util;

import github.log4jexploit.crunchytoast.http.endpoint.HttpResourceSplintered;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

// Coded by Zadex at 18/04/2022
public final class UncheckedIOReader {

    private final InputStream in;

    public UncheckedIOReader(InputStream in) {
        this.in = in;
    }

    public String nextLine() {
        return nextLine(StandardCharsets.UTF_8, Long.MAX_VALUE);
    }

    public String nextLine(long limit) {
        return nextLine(StandardCharsets.UTF_8, limit);
    }

    public String nextLine(Charset charset, long limit) {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        int read;
        while((read = this.read()) != 10) {
            if (read == 13)
                continue;
            if(stream.size() >= limit)
                throw new UncheckedIOException("Character limit reached!", new IOException());
            stream.write(read);
        }
        return stream.toString(charset);
    }

    public byte[] readNBytes(int length) {
        try {
            return in.readNBytes(length);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public int readNBytes(byte[] target, int offset, int length) {
        try {
            return in.read(target, offset, length);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public byte[] readAllBytes() {
        try {
            HttpResourceSplintered resource = new HttpResourceSplintered(null);
            byte[] buf = new byte[1024];
            boolean eof;
            do {
                long len = in.read(buf, 0, buf.length);
                eof = len != buf.length;
                resource.write(buf, 0, (int) len);
            } while (!eof);
            return resource.getData();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public byte read() {
        try {
            int b = in.read();
            if(b == -1)
                throw new IOException("EOF reached!");
            return (byte) b;
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public long skip(long count) {
        long skipped = 0;
        try {
            while(skipped < count)
                skipped += in.skip(count);
            return skipped;
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public void close() {
        try {
            this.in.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public InputStream getInputStream() {
        return in;
    }
}
