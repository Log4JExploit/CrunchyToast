/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.util;

import github.log4jexploit.crunchytoast.general.Pair;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Function;

public class TreeNode<A, B> {
    private final Map<A, TreeNode<A, B>> children;
    private TreeNode<A, B> parent;
    private A nodeValue;
    private B carryValue;


    public TreeNode(A nodeValue) {
        this(nodeValue, null);
    }

    public TreeNode(A nodeValue, B carryValue) {
        this.children = new HashMap<>();
        this.nodeValue =  Objects.requireNonNull(nodeValue);
        this.carryValue = carryValue;
    }


    public boolean matches(A value) {
        return Objects.requireNonNull(value).equals(this.nodeValue);
    }

    public Optional<TreeNode<A, B>> find(A value) {
        TreeNode<A, B> node = children.get(Objects.requireNonNull(value));
        return node != null ? Optional.of(node) : Optional.empty();
    }

    public void addChild(TreeNode<A, B> child) {
        this.children.put(child.getNodeValue(), child);
        child.setParent(this);
    }

    public void remove(A child) {
        this.children.remove(child);
    }

    public Optional<TreeNode<A, B>> searchNode(Iterator<A> path) {
        if(!Objects.requireNonNull(path).hasNext()) {
            throw new IllegalArgumentException("Path has no elements!");
        }

        Optional<TreeNode<A, B>> node = find(path.next());
        if(node.isEmpty())
            return Optional.empty();

        if(path.hasNext()) {
           return node.get().searchNode(path);
        }

        return node;
    }

    public Optional<B> search(Iterator<A> path) {
        Optional<TreeNode<A, B>> node = searchNode(path);
        if(node.isPresent()) {
            return node.get().getCarryValue();
        }
        return Optional.empty();
    }

    public List<TreeNode<A, B>> getPath() {
        List<TreeNode<A, B>> nodes = new ArrayList<>();
        TreeNode<A, B> node = this;

        while(node.getParent().isPresent()) {
            TreeNode<A, B> parent = node.getParent().get();
            Optional<TreeNode<A, B>> parentOfParent = parent.getParent();

            if(parentOfParent.isEmpty()) // Do not include root node in path
                break;

            nodes.add(node.getParent().get());
            node = node.getParent().get();
        }

        Collections.reverse(nodes);
        return nodes;
    }

    public void setParent(TreeNode<A, B> parent) {
        this.parent = parent;
    }

    public Optional<TreeNode<A, B>> getParent() {
        return Optional.ofNullable(parent);
    }

    public A getNodeValue() {
        return nodeValue;
    }

    public void setNodeValue(A nodeValue) {
        this.nodeValue = nodeValue;
    }

    public Optional<B> getCarryValue() {
        return carryValue != null ? Optional.of(carryValue) : Optional.empty();
    }

    public void setCarryValue(B carryValue) {
        this.carryValue = carryValue;
    }

    public Map<A, TreeNode<A, B>> getChildren() {
        return children;
    }

    public void forEachChild(BiConsumer<A, Optional<B>> consumer) {
        this.children.forEach((key, value) -> consumer.accept(value.getNodeValue(), value.getCarryValue()));
    }

    public static <A, B> void populate(TreeNode<A, B> root, Function<B, List<Pair<A, B>>> nodeGenerator) {
        if(root.getCarryValue().isEmpty()) {
            throw new IllegalArgumentException("Root node must have a carry value!");
        }

        for(Pair<A, B> result : nodeGenerator.apply(root.getCarryValue().get())) {
            TreeNode<A, B> node = new TreeNode<>(result.getValueA(), result.getValueB());
            populate(node, nodeGenerator);
            root.addChild(node);
        }
    }

    @Override
    public TreeNode<A, B> clone() {
        TreeNode<A, B> clonedNode = new TreeNode<>(this.nodeValue, this.carryValue);
        this.children.forEach((a, node) -> {
            clonedNode.addChild(node.clone());
        });
        return clonedNode;
    }
}
