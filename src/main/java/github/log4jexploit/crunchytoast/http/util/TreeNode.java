/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.http.util;

import github.log4jexploit.crunchytoast.general.Pair;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Function;

public class TreeNode<A, B> {
    private final Map<A, TreeNode<A, B>> children;
    private A nodeValue;
    private B carryValue;


    public TreeNode(A nodeValue) {
        this.children = new HashMap<>();
        this.nodeValue =  Objects.requireNonNull(nodeValue);
        this.carryValue = null;
    }

    public TreeNode(A nodeValue, B carryValue) {
        this.children = new HashMap<>();
        this.nodeValue =  Objects.requireNonNull(nodeValue);
        this.carryValue = carryValue;
    }


    public boolean matches(A value) {
        return Objects.requireNonNull(value).equals(this.nodeValue);
    }

    public Optional<TreeNode<A, B>> find(A value) {
        TreeNode<A, B> node = children.get(Objects.requireNonNull(value));
        return node != null ? Optional.of(node) : Optional.empty();
    }

    public void set(TreeNode<A, B> child) {
        this.children.put(child.getNodeValue(), child);
    }

    public void remove(A child) {
        this.children.remove(child);
    }

    public Optional<B> search(Iterator<A> path) {
        if(!Objects.requireNonNull(path).hasNext()) {
            throw new IllegalArgumentException("Path has no elements!");
        }

        Optional<TreeNode<A, B>> node = find(path.next());
        if(node.isEmpty())
            return Optional.empty();

        if(path.hasNext()) {
           return node.get().search(path);
        }

        return node.get().getCarryValue();
    }

    public A getNodeValue() {
        return nodeValue;
    }

    public void setNodeValue(A nodeValue) {
        this.nodeValue = nodeValue;
    }

    public Optional<B> getCarryValue() {
        return carryValue != null ? Optional.of(carryValue) : Optional.empty();
    }

    public void setCarryValue(B carryValue) {
        this.carryValue = carryValue;
    }

    public Map<A, TreeNode<A, B>> getChildren() {
        return children;
    }

    public void forEachChild(BiConsumer<A, Optional<B>> consumer) {
        this.children.forEach((key, value) -> consumer.accept(value.getNodeValue(), value.getCarryValue()));
    }

    public static <A, B> void populate(TreeNode<A, B> root, Function<B, List<Pair<A, B>>> nodeGenerator) {
        if(root.getCarryValue().isEmpty()) {
            throw new IllegalArgumentException("Root node must have a carry value!");
        }

        for(Pair<A, B> result : nodeGenerator.apply(root.getCarryValue().get())) {
            TreeNode<A, B> node = new TreeNode<>(result.getValueA(), result.getValueB());
            populate(node, nodeGenerator);
            root.set(node);
        }
    }
}
