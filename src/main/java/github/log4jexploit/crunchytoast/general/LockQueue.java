/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.general;


import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public final class LockQueue {

    private volatile boolean locked;
    private final List<Thread> observers;


    public LockQueue() {
        this.observers = new CopyOnWriteArrayList<>();
        this.locked = false;
    }


    public void unlock() {
        if(!this.observers.get(0).equals(Thread.currentThread()))
            throw new IllegalMonitorStateException("Unable to release lock: Current thread is not the lock holder!");

        synchronized (this.observers) {
            this.locked = false;
            this.observers.remove(0);
            this.observers.notifyAll();
        }
    }

    public Object getCurrentObserver() {
        return this.observers.isEmpty() ? null : this.observers.get(0);
    }

    /**
     * Wait for the lock to be released and then claim it.<br>
     * @throws RuntimeException if the thread is interrupted while waiting for the lock
     * @apiNote This method can lock indefinitely, if the current lock owner never releases the lock
     */
    public void claimLock() throws RuntimeException {
        final Thread observer = Thread.currentThread();

        synchronized (this.observers) {
            this.observers.add(observer);
            do {
                try {
                    if (observer.equals(getCurrentObserver())) {
                        this.locked = true;
                        return;
                    }

                    this.observers.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            } while (true);
        }
    }

    /**
     * Complete a task with automatic lock claiming and unlocking.
     * @param task the task to complete, while the lock is held
     */
    public void claimAndDo(Runnable task) throws RuntimeException {
        this.claimLock();
        try {
            task.run();
        } finally {
            this.unlock();
        }
    }

    public List<Object> getObservers() {
        return new ArrayList<>(observers);
    }

    public boolean isLocked() {
        return this.locked;
    }
}
