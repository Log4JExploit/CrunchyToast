package github.log4jexploit.crunchytoast.general;


import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public final class LockQueue {

    private volatile boolean locked;
    private final List<Thread> observers;


    public LockQueue() {
        this.observers = new CopyOnWriteArrayList<>();
        this.locked = false;
    }


    public void unlock() {
        synchronized (this.observers) {
            if(!this.observers.get(0).equals(Thread.currentThread()))
                throw new IllegalMonitorStateException("Unable to release lock: Current thread is not the lock holder!");
            this.observers.remove(0);

            this.locked = false;
            this.observers.notifyAll();
        }
    }

    /**
     *
     * @return true if all observers where notified, false otherwise
     */
    public boolean wakeAll() {
        synchronized (this.observers) {
            if(locked)
                return false;

            observers.notifyAll();
        }
        return true;
    }

    public Object getCurrentObserver() {
        synchronized (this.observers) {
            return this.observers.isEmpty() ? null : this.observers.get(0);
        }
    }

    /**
     * Wait for the lock to be released and then claim it.<br>
     * The lock will be given to the thread that is next in the queue.<br>
     * This method will return when this thread is at the first position in the queue.
     * @throws InterruptedException if the thread is interrupted while waiting for the lock
     * @apiNote This method can lock indefinitely, if the current lock owner never releases the lock
     * @return true if the lock has been claimed successfully, false otherwise
     */
    public boolean claimLock(long timeoutMillis) throws InterruptedException {
        final Thread observer = Thread.currentThread();

        synchronized (this.observers) {
            this.observers.add(observer);

            if(!locked && observer.equals(getCurrentObserver())) {
                locked = true;
                return true;
            }

            long startTime = System.currentTimeMillis();

            do {
                if(timeoutMillis > 0) {
                    observers.wait(timeoutMillis);
                    long timeWaited = System.currentTimeMillis() - startTime;
                    timeoutMillis -= timeWaited;

                    if (timeWaited >= timeoutMillis - 1 && observer.equals(getCurrentObserver())) {
                        this.observers.remove(observer);
                        return false;
                    }
                } else
                    observers.wait();

                if (observer.equals(getCurrentObserver())) {
                    this.locked = true;
                    return true;
                }
            } while(!this.observers.isEmpty());
        }
        return false;
    }

    public void claimLock() throws InterruptedException {
        this.claimLock(0);
    }

    public boolean waitForWake(int timeout) throws InterruptedException {
        if(locked)
            return false;

        synchronized (this.observers) {
            if(timeout > 0)
                observers.wait(timeout);
            else
                observers.wait();
            return true;
        }
    }

    public boolean waitForWake() throws InterruptedException {
        return waitForWake(0);
    }

    public List<Object> getObservers() {
        return new ArrayList<>(observers);
    }

    public boolean isLocked() {
        return this.locked;
    }
}
