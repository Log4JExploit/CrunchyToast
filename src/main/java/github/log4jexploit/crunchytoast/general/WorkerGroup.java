/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.general;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicReference;

public class WorkerGroup {
    private final LockNotify somnolentLock;
    private final LockQueue lockTasks;
    private final List<Thread> activeWorkers;
    private final Queue<ScheduledTask> tasks;

    private volatile int threadLimit;
    private volatile boolean alive;


    public WorkerGroup(int threadLimit) {
        this.threadLimit = threadLimit;
        this.tasks = new ConcurrentLinkedDeque<>();
        this.activeWorkers = new CopyOnWriteArrayList<>();
        this.lockTasks = new LockQueue();
        this.somnolentLock = new LockNotify();
        this.launchWorkers();
    }


    public void add(ScheduledTask task) {
        if(!this.alive)
            return;

        this.lockTasks.claimAndDo(() -> tasks.add(Objects.requireNonNull(task)));
        this.wakeSomnolent();
    }

    private void wakeSomnolent() {
        this.activeWorkers.removeIf((e) -> !e.isAlive());
        this.launchWorkers();
        this.somnolentLock.wakeAll();
    }

    private void launchWorkers() {
        this.alive = true;
        while(this.activeWorkers.size() < this.threadLimit) {
            launchWorker();
        }
    }

    private void launchWorker() {
        Thread worker = new Thread(this::onLaunch, "Worker" + this.activeWorkers.size());
        this.activeWorkers.add(worker);
        worker.start();
    }

    private void onLaunch() {
        final AtomicReference<ScheduledTask> ref = new AtomicReference<>();
        try {
            do {
                lockTasks.claimAndDo(() -> ref.set(this.tasks.poll()));

                if(ref.get() == null) {
                    this.somnolentLock.waitForWake(8);
                    continue;
                }

                ref.get().getTask().run();
                ref.get().setDone(true);
                ref.get().getLock().wakeAll();
            } while(this.alive);
        } finally {
            this.activeWorkers.remove(Thread.currentThread());
        }
    }

    public void close() {
        this.alive = false;
        this.lockTasks.claimAndDo(this.tasks::clear);

        for(Thread thread : new ArrayList<>(this.activeWorkers)) {
            thread.interrupt();
        }
    }

    public boolean isAlive() {
        return this.alive;
    }

    public void setThreadLimit(int threadLimit) {
        this.threadLimit = threadLimit;
    }
}
