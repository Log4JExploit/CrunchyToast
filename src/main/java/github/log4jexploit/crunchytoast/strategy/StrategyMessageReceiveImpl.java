/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.strategy;

import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.http.message.body.impl.BodyContentEmpty;
import github.log4jexploit.crunchytoast.http.message.body.impl.BodyContentReaderChunked;
import github.log4jexploit.crunchytoast.http.message.body.impl.BodyContentReaderDirect;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentReader;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import github.log4jexploit.crunchytoast.resource.Resource;
import github.log4jexploit.crunchytoast.server.Client;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class StrategyMessageReceiveImpl implements Strategy.Message {

    // Syntax here: https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages

    private HttpMessage message;
    private UncheckedIOReader reader;
    private IBodyContentReader contentReader;


    @Override
    public void initialize(Client client, HttpMessage message) {
        this.message = message;
        this.reader = new UncheckedIOReader(client.getInputStream());
    }


    @Override
    public void execute() {
        this.receiveHeaders(this.message, this.reader);
        this.message.performChecks();
        this.contentReader = this.createContentHandler(this.message, this::onCallback);
    }

    @Override
    public void executeTrailers() {
        receiveTrailers(message, contentReader, reader);
    }

    public String[] nextHeader(UncheckedIOReader reader, HttpSecurityPolicy securityPolicy) {
        String line = reader.nextLine(
                securityPolicy.getMaxLineLength()
        ).trim();

        if(line.isBlank())
            return null;

        int indexOfColon = line.indexOf(':');

        if(indexOfColon == -1 || indexOfColon == 0 || indexOfColon == line.length() - 1)
            throw new HttpProtocolException("Encountered invalid header!");

        return new String[]{
                line.substring(0, indexOfColon).trim().toLowerCase(),
                line.substring(indexOfColon + 1).trim()
        };
    }

    /**
     * Reads all headers.
     */
    public void receiveHeaders(HttpMessage message, UncheckedIOReader reader) {
        int count = 0;

        while(++count < message.getSecurityPolicy().getMaxHeaderCount()) {
            String[] header = this.nextHeader(reader, message.getSecurityPolicy());

            if(header == null) {
                break;
            }

            Http.HeaderType headerType = Http.HeaderType.TE.byString(header[0]);

            if(headerType == Http.HeaderType.CUSTOM) {
                message.setCustomHeader(header[0], header[1]);
            } else {
                message.setHeader(headerType, header[1]);
            }
        }
    }

    /**
     * Creates a {@link IBodyContentReader} according to the specifications of the message.
     */
    public IBodyContentReader createContentHandler(HttpMessage message, Consumer<Resource> callback) {
        if(message.isChunkedTransfer()) {
            return new BodyContentReaderChunked(
                    callback,
                    message.getContentType(),
                    message.getClient()
            );
        } else if(message.getContentLength() > 0) {
            return new BodyContentReaderDirect(
                    message.getContentLength(),
                    callback,
                    message.getContentType(),
                    message.getClient());
        } else {
            return new BodyContentEmpty();
        }
    }

    private void onCallback(Resource resource) {
        this.message.setContent(resource);
    }

    public void receiveTrailers(HttpMessage message, IBodyContentReader contentReader, UncheckedIOReader reader) {
        int size = message.getTrailers().size() + message.getCustomTrailers().size();

        if(size == 0)
            return;

        ArrayList<Http.HeaderType> expectedTrailers = new ArrayList<>(
                List.of(message.getTrailerFields())
        );

        ArrayList<String> expectedCustomTrailers = new ArrayList<>(
                message.getCustomTrailers().keySet()
        );

        if(contentReader != null)
            contentReader.onFlushRemaining();

        for(int i = 0; i < size; i++) {
            String[] trailer = nextHeader(reader, message.getSecurityPolicy());

            if(trailer == null) {
                throw new HttpProtocolException("Expected header in trailer section, instead found empty line!");
            }

            Http.HeaderType headerType = Http.HeaderType.TE.byString(trailer[0]);

            if(!expectedTrailers.contains(headerType) && !expectedCustomTrailers.contains(trailer[0])) {
                throw new HttpProtocolException("Unexpected header in trailer section!");
            }

            if(headerType == Http.HeaderType.CUSTOM)
                message.setTrailer(headerType, trailer[0]);
            else
                message.setCustomTrailer(trailer[0], trailer[1]);
        }
    }

    @Override
    public IBodyContentReader getContentHandler() {
        return (IBodyContentReader) this.contentReader;
    }
}
