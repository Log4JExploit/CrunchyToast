/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.strategy;

import github.log4jexploit.crunchytoast.general.Client;
import github.log4jexploit.crunchytoast.http.message.body.impl.BodyContentEmpty;
import github.log4jexploit.crunchytoast.http.message.body.impl.BodyContentWriterChunked;
import github.log4jexploit.crunchytoast.http.message.body.impl.BodyContentWriterDirect;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentWriter;
import github.log4jexploit.crunchytoast.http.message.inf.HttpMessage;
import github.log4jexploit.crunchytoast.http.message.inf.Strategy;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOWriter;

import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.Map;

public class StrategyMessageSendImpl implements Strategy.Message {

    // Syntax here: https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages

    private IBodyContentWriter contentWriter;
    private UncheckedIOWriter writer;
    private HttpMessage message;


    /**
     * This initializes this {@link Message} with the given parameters.
     * @param client the target client
     * @param message the message to send
     */
    @Override
    public void initialize(Client client, HttpMessage message) {
        this.message = message;
        this.writer = new UncheckedIOWriter(client.getOutputStream());
    }


    /**
     * Sends the header section of the message.<br>
     * This sends all headers and prepares a {@link IBodyContentWriter} for sending the body, if present.
     */
    @Override
    public void execute() {
        this.message.performChecks();
        this.prepare();
        createContentHandler();
        sendHeaders();
    }

    private void prepare() {
        if(this.message.getHeader(Http.HeaderType.CONNECTION) == null)
            this.message.setKeepAlive(true);

        if(this.message.getContent().length == 0)
            this.message.setContentLength(0);

        if(this.message.getServer() == null)
            this.message.setServer("CrunchyToast");
    }

    /**
     * Sends the trailer section of the message.
     */
    @Override
    public void executeTrailers() {
        sendTrailers();
    }


    /**
     * Sends all headers specified in the message.
     */
    private void sendHeaders() {
        for(Map.Entry<Http.HeaderType, String> header : this.message.getHeaders().entrySet()) {
            this.writer.writeLine(header.getKey().toString()+": "+header.getValue());
        }
        for(Map.Entry<String, String> header : this.message.getCustomHeaders().entrySet()) {
            this.writer.writeLine(header.getKey()+": "+header.getValue());
        }
        this.writer.writeLine("");
        this.writer.flush();
    }

    /**
     * Creates a {@link IBodyContentWriter} according to the specifications of the message.
     */
    private void createContentHandler() {
        if(this.message.isChunkedTransfer()) {
            this.contentWriter = new BodyContentWriterChunked(
                    this,
                    this.message.getClient().getOutputStream(),
                    this.message.getContentEncodings()
            );
        } else if(this.message.getContent().length > 0) {
            this.contentWriter = new BodyContentWriterDirect(
                    this.message,
                    this
            );
            this.contentWriter.encode();
            this.message.setContentLength(this.contentWriter.getContentLength());
        } else {
            this.contentWriter = new BodyContentEmpty(this.message.getClient());
        }
    }

    /**
     * Sends all trailers specified in the message.
     */
    private void sendTrailers() {
        if(this.message.getTrailers().isEmpty() && this.message.getCustomTrailers().isEmpty())
            return;

        for(Map.Entry<Http.HeaderType, String> header : this.message.getHeaders().entrySet()) {
            this.writer.writeLine(header.getKey().toString()+": "+header.getValue());
        }

        for(Map.Entry<String, String> header : this.message.getCustomTrailers().entrySet()) {
            this.writer.writeLine(header.getKey()+": "+header.getValue());
        }

        this.writer.writeLine("");
        this.writer.flush();
    }

    public static void main(String[] args) throws Exception {
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress("localhost", 1024));
        socket.getOutputStream().write("GET / HTTP/1.1\n".getBytes());
        socket.getOutputStream().write("Connection: close\n".getBytes());
        socket.getOutputStream().write("\n".getBytes());
        socket.getOutputStream().flush();

        System.out.println("Sent! Reading...");

        UncheckedIOReader reader = new UncheckedIOReader(socket.getInputStream());
        byte[] data = reader.readNBytes(1024);
        System.out.println(new String(data));
    }

    @Override
    public IBodyContentWriter getContentHandler() {
        return this.contentWriter;
    }
}
