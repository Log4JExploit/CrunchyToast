/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Iterator;

final class WSProtocolImpl implements WSProtocol {

    /*
     * WebSocket protocol documentation
     * https://www.rfc-editor.org/rfc/rfc6455#page-1
     */

    WSProtocolImpl() {

    }

    /**
     *  An implementation of the WebSocket Protocol<br>
     *  The Decoder class is capable of decoding a "message" sent<br>
     *  over the WebSocket Protocol
     */
    public WSPacket decode(InputStream socketIn) throws IOException {
        ValidatingInputStream in = new ValidatingInputStream(socketIn);
        BitStream stream = new BitStream(),
                temp = new BitStream();

        // FIRST BYTE
        stream.add((byte)in.read()); // 8
        Iterator<Boolean> it = stream.iterator();

        // PROTOCOL BITS
        boolean fin = it.next();
        boolean RSV1 = it.next(),
                RSV2 = it.next(),
                RSV3 = it.next();

        // OPCODE
        int opcode = getIntegerValue(it.next(), it.next(), it.next(), it.next());
        stream.add((byte)in.read()); // 16
        boolean mask = it.next();

        // PAYLOAD LENGTH
        for(int i = 0; i < 7; i++) temp.add(it.next());
        int payloadLength = getIntegerValue(temp.getBits());
        temp.clear();

        // CHECK FOR LONGER PAYLOAD LENGTH
        if(payloadLength == 126) {
            for(int i = 0; i < 2; i++)
                stream.add((byte)in.read()); // 32
            for(int i = 0; i < 16; i++)
                temp.add(it.next());
        } else if(payloadLength == 127) {
            for(int i = 0; i < 8; i++)
                stream.add((byte)in.read()); // 80
            for(int i = 0; i < 64; i++)
                temp.add(it.next());
        }

        if(!temp.isEmpty()) {
            payloadLength = getIntegerValue(temp.getBits());
            temp.clear();
        }

        // MASK KEY
        byte[] maskKey = new byte[0];

        if(mask) {
            for(int i = 0; i < 4; i++) temp.add((byte) in.read()); // 112
            maskKey = temp.getByteArray();
            temp.clear();
        }

        // READING PAYLOAD DATA
        ByteArrayOutputStream payloadData = new ByteArrayOutputStream();
        for(int i = 0; i < payloadLength; i++) {
            if(mask) {
                boolean[] bits = BitStream.toBitArray((byte) in.read());
                boolean[] keyBits = BitStream.toBitArray(maskKey[i % 4]);
                boolean[] result = BitStream.XOR(bits, keyBits);
                payloadData.write(BitStream.toSignedByte(result));
            } else {
                payloadData.write(in.read());
            }
        }

        return WSPacket.build()
                .setExtensionBit1(RSV1)
                .setExtensionBit2(RSV2)
                .setExtensionBit3(RSV3)
                .setFinalMessage(fin)
                .setMask(mask)
                .setMaskKey(new BitStream(maskKey))
                .setOpCode(OpCode.select(opcode))
                .setPayload(new BitStream(payloadData.toByteArray()));
    }

    private int getIntegerValue(boolean ...bits) {
        int code = 0;
        for(int i = 0; i < bits.length; i++) {
            if(!bits[i])
                continue;
            code += (int) Math.pow(2, bits.length-1-i);
        }
        return code;
    }

    /**
     *  An implementation of the WebSocket Protocol<br>
     *  The encode method is capable of encoding a "message" so that<br>
     *  it can be sent over the WebSocket Protocol
     */
    @Override
    public byte[] encode(WSPacket packet) {
        BitStream output = new BitStream();
        output.add(packet.isFinalMessage());
        output.add(packet.isExtensionBit1());
        output.add(packet.isExtensionBit2());
        output.add(packet.isExtensionBit3());
        output.add(BitStream.convertUnsignedIntToBits(packet.getOpCode().getCode(), 4).getBits());
        output.add(packet.isMasked());
        byte[] payload = packet.getPayload().getByteArray();

        BitStream lengthBits;
        if(payload.length <= 125) {
            lengthBits = BitStream.convertUnsignedIntToBits(payload.length, 7);
        } else if(payload.length <= 65536) {
            lengthBits = BitStream.convertUnsignedIntToBits(126, 7);
            lengthBits.add(BitStream.convertUnsignedIntToBits(payload.length, 16).getBits());
        } else {
            lengthBits = BitStream.convertUnsignedIntToBits(127, 7);
            lengthBits.add(BitStream.convertUnsignedIntToBits(payload.length, 64).getBits());
        }

        output.add(lengthBits.getBits());
        if(packet.isMasked()) {
            output.add(packet.getMaskKey().getBits());
        }

        if(packet.isMasked()) {
            byte[] maskKey = packet.getMaskKey().getByteArray();
            for (int i = 0; i < payload.length; i++) {
                boolean[] bits = BitStream.toBitArray(payload[i]);
                boolean[] key = BitStream.toBitArray(maskKey[i % 4]);
                output.add(BitStream.XOR(bits, key));
            }
        } else {
            output.add(payload);
        }
        return output.getByteArray();
    }

    protected static class ValidatingInputStream extends InputStreamReader {

        private final InputStream inputStream;

        public ValidatingInputStream(InputStream stream) {
            super(stream);
            this.inputStream = stream;
        }

        @Override
        public int read() throws IOException {
            int read = this.inputStream.read();
            if(read < 0) {
                throw new IOException("Connection input channel has been closed!");
            }
            return read;
        }
    }
}
