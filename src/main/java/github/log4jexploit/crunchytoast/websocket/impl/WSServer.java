/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.http.util.SecurityPolicy;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.server.Client;
import github.log4jexploit.crunchytoast.server.Server;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class WSServer implements Server {

    private final List<WSClient> activeConnections;
    private final int port;

    private HttpSecurityPolicy securityPolicy;
    private WSEventHandler eventHandler;
    private Thread listener;

    ServerSocket serverSocket;
    String bindingIP;
    Logger logger;

    private boolean initialized;
    private boolean masked;
    private boolean alive;


    public WSServer(int port) {
        this(port, "127.0.0.1");
    }

    public WSServer(int port, String bindingIP) {
        this.activeConnections = new CopyOnWriteArrayList<>();
        this.logger = new LoggerTimeImpl(System.out, WSSServerImpl.class);
        this.port = port;

        this.securityPolicy = HttpSecurityPolicy.createDefault();
        this.bindingIP = bindingIP;
        this.initialized = false;
        this.alive = false;
    }


    abstract void createServerSocket() throws IOException;

    private void init() throws IOException {
        this.initialized = false;
        createServerSocket();

        this.listener = new Thread(() -> {
            try {
                this.alive = true;

                while (this.alive && !this.serverSocket.isClosed()) {
                    cleanUp();

                    long max = securityPolicy.getMaxConnections();
                    if(max > 0) {
                        while(this.activeConnections.size() >= max) {
                            Thread.onSpinWait();
                        }
                    }

                    Socket socket = this.serverSocket.accept();
                    WSClient client = new WSClientImpl(socket, WSServer.this);

                    client.setMasked(this.masked);
                    client.start();
                }
            } catch (SocketException ignored) {

            } catch (Exception e) {
                logger.alert("An Error occurred while waiting for connections:");
                logger.alertError(e);
            } finally {
                logger.warn("Shutting down...");
                int closed = cleanUp();

                logger.warn("Closed "+closed+" remaining connections");
            }
        });

        this.initialized = true;
        this.alive = false;
    }

    /**
     * Remove all inactive clients
     * @return The amount of connections closed.
     */
    private int cleanUp() {
        final AtomicInteger count = new AtomicInteger();
        new ArrayList<>(this.activeConnections).forEach((client) -> {
            if(!client.isAlive()) {
                client.close();
                onDisconnect(client);
                count.incrementAndGet();
            }
        });
        return count.get();
    }

    void onDisconnect(WSClient client) {
        this.logger.info(client.getAddress()+" disconnected");
        this.activeConnections.remove(client);
        new Thread(() -> this.eventHandler.onDisconnect(client)).start();
    }

    void onConnect(WSClient client) {
        this.logger.info(client.getAddress()+" connected");
        this.activeConnections.add(client);
        new Thread(() -> this.eventHandler.onConnect(client)).start();
    }

    void onPacketReceive(Client client, byte[] packet) {
        new Thread(() -> WSServer.this.eventHandler.onPacketReceive(client, packet)).start();
    }

    @Override
    public void start() throws UncheckedIOException {
        if(alive) {
            logger.warn("Server already running!");
            return;
        }

        try {
            this.init();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        if(!initialized) {
            this.logger.alert("Initialization failed, start aborted!");
            return;
        }

        logger.info("Starting...");
        this.listener.start();
    }

    @Override
    public void close() throws UncheckedIOException {
        if(!alive)
            return;

        try {
            alive = false;
            this.serverSocket.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }


    public void setEventHandler(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    public boolean isMasked() {
        return this.masked;
    }

    @Override
    public boolean isAlive() {
        return this.alive;
    }

    @Override
    public Logger getLogger() {
        return this.logger;
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public List<WSClient> getActiveConnections() {
        return new ArrayList<>(this.activeConnections);
    }

    @Override
    public void setSecurityPolicy(SecurityPolicy securityPolicy) {
        if(!(securityPolicy instanceof HttpSecurityPolicy))
            throw new RuntimeException("SecurityPolicy must be of type HttpSecurityPolicy!");
        this.securityPolicy = (HttpSecurityPolicy) securityPolicy;
    }

    @Override
    public HttpSecurityPolicy getSecurityPolicy() {
        return this.securityPolicy;
    }

    @Override
    public int getPort() {
        return this.port;
    }

    @Override
    public String getBindingIP() {
        return bindingIP;
    }

    @Override
    public void setBindingIP(String ip) {
        this.bindingIP = bindingIP;
    }
}
