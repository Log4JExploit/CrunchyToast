/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.exceptions.WSProtocolException;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.logger.NotificationLevel;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import github.log4jexploit.crunchytoast.websocket.inf.WSOutboundClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.util.ConnectionState;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import javax.net.ssl.SSLSocketFactory;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Random;

public class WSSOutboundClientImpl implements WSOutboundClient {

    private WSEventHandler eventHandler;
    private final WSProtocol protocol;
    private final Logger logger;
    private Socket socket;

    private ConnectionState connectionState;
    private Thread readerThread;

    private boolean alive;
    private boolean masked;


    public WSSOutboundClientImpl(String address, int port) {
        this.protocol = WSServerBuilder.getDefaultProtocol();
        this.eventHandler = new WSEventHandler() {};
        this.connectionState = ConnectionState.READY_FOR_CONNECT;
        this.logger = new LoggerTimeImpl(this.getClass());
        this.logger.setNotificationLevel(NotificationLevel.DEBUG);

        createSocket(address, port);
    }

    private void createSocket(String address, int port) throws UncheckedIOException {
        try {
            logger.debug("--- SECURITY INFO ---");
            logger.debug("TLS:");
            logger.debug("TLS Version: TLSv1.3");
            logger.debug("Supported Ciphers: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_128_CBC_SHA256");
            logger.debug("Supported Application Protocols: Http/1.1");
            logger.debug("Endpoint Identification Algorithm: HTTPS");
            logger.debug("");
            logger.debug("Certificates: ");
            logger.debug("The 'certificates' folder has to contain two files: 'cert.pem' and 'key.pem'");
            logger.debug("The 'key.pem' file has to be formatted as PKCS8, unencrypted, containing the private key");
            logger.debug("The 'cert.pem' file has to be a X509 certificate and needs to be formatted as PEM");
            logger.debug("");
            logger.debug("Credit:");
            logger.debug("Author: Log4JExploit");
            logger.debug("Github Repository: https://github.com/Log4JExploit/CrunchyToast/");
            logger.debug("");
            logger.debug("--- SECURITY INFO ---");

            this.socket = SSLSocketFactory.getDefault().createSocket(address, port);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private void initReaderThread() {
        this.readerThread = new Thread(() -> {
            try {
                this.alive = true;
                this.connectionState = ConnectionState.OPENING_HANDSHAKE;
                this.eventHandler.onConnect(WSSOutboundClientImpl.this);

                Random r = new SecureRandom();
                byte[] randomBytes = new byte[16];
                r.nextBytes(randomBytes);

                String encoded = Base64.getEncoder().encodeToString(randomBytes).trim();
                String computedResponse = Base64.getEncoder().encodeToString(
                                            MessageDigest.getInstance("SHA-1").digest((encoded + WSClient.GUID).getBytes())
                );

                HttpRequest request = HttpRequest.createDefault();
                request.setRequestType(Http.RequestType.GET);
                request.getCustomHeaders().put("Sec-WebSocket-Key", encoded);
                request.setHeader(Http.HeaderType.CONNECTION, "upgrade");
                request.setHeader(Http.HeaderType.UPGRADE, "websocket");

                IBodyContentHandler bodyContentHandler = request.send(WSSOutboundClientImpl.this);
                bodyContentHandler.onFlushRemaining();

                // Switching from Http/1.1 to websocket protocol
                this.connectionState = ConnectionState.CLOSING_HANDSHAKE;

                HttpResponse response = HttpResponse.createDefault();
                bodyContentHandler = response.receive(WSSOutboundClientImpl.this);
                bodyContentHandler.onFlushRemaining();

                if(response.getResponseCode() != Http.ResponseCode.SWITCHING_PROTOCOLS) {
                    throw new WSProtocolException("Server has no intention of switching protocols: "+response.getResponseCode().toString());
                }

                if(!response.getCustomHeaders().containsKey("Sec-WebSocket-Accept")) {
                    throw new WSProtocolException("Server didn't include the Sec-WebSocket-Accept header!");
                }

                if(!response.getCustomHeader("Sec-WebSocket-Accept").equals(computedResponse)) {
                    throw new WSProtocolException("Server produced an invalid Sec-WebSocket-Accept hash value!");
                }

                this.connectionState = ConnectionState.HANDSHAKE_SUCCESS;

                // Connection actively exchanging packets
                while (alive && !socket.isClosed()) {
                    WSPacket packet = protocol.decode(this.socket.getInputStream());
                    if (packet.getOpCode() == OpCode.CLOSE) {
                        this.alive = false;
                        break;
                    }
                    this.eventHandler.onPacketReceive(WSSOutboundClientImpl.this, packet.getPayload().getByteArray());
                }

                if (!alive && !socket.isClosed()) {
                    WSPacket packet = WSPacket.build()
                            .setPayload(new BitStream())
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setOpCode(OpCode.CLOSE)
                            .setMask(WSSOutboundClientImpl.this.masked);

                    socket.getOutputStream().write(protocol.encode(packet));
                    socket.getOutputStream().flush();
                }
            } catch (IOException e) {
                this.logger.alert("Connection IO/Error:" + this.getIP() + ": Connection closed without fin packet!");
                this.logger.alertError(e);
            } catch (WSProtocolException e) {
                this.logger.alert("WS protocol violation " + this.getIP() + ": "+e.getMessage());
                this.logger.alertError(e);
            } catch (HttpProtocolException e) {
                this.logger.alert("HTTP protocol violation: " + this.getIP() + ": "+e.getMessage());
                this.logger.alertError(e);
            } catch (Exception e) {
                this.connectionState = ConnectionState.CONNECTION_ERROR;
                this.logger.debugError(e);
            } finally {
                try {
                    this.socket.close();
                    this.alive = false;
                    if(this.connectionState == ConnectionState.HANDSHAKE_SUCCESS) {
                        this.connectionState = ConnectionState.CONNECTION_CLOSED;
                    } else {
                        this.connectionState = ConnectionState.CONNECTION_ERROR;
                    }
                    this.eventHandler.onClose(WSSOutboundClientImpl.this);
                } catch (IOException e) {
                    this.logger.alertError(e);
                }
            }
        });
    }

    @Override
    public void start() {
        if(this.alive)
            return;

        initReaderThread();
        this.readerThread.start();
    }

    @Override
    public void close() {
        try {
            this.alive = false;
            this.socket.close();
            this.readerThread.interrupt();
        } catch (IOException e) {
            this.logger.alertError(e);
        }
    }

    @Override
    public void send(byte[] data) throws IOException {
        byte[] encoded = protocol.encode(
                WSPacket.build()
                        .setPacket(new BitStream())
                        .setPayload(new BitStream(data))
                        .setMask(this.masked)
                        .setOpCode(OpCode.TEXT)
                        .setFinalMessage(true)
                        .createMaskKey()
        );
        this.socket.getOutputStream().write(encoded);
        this.socket.getOutputStream().flush();
    }

    @Override
    public void setEventHandler(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public ConnectionState getConnectionState() {
        return this.connectionState;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public String getIP() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public OutputStream getOutputStream() {
        try {
            return this.socket.getOutputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public InputStream getInputStream() {
        try {
            return this.socket.getInputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}
