/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.exceptions.ProtocolException;
import github.log4jexploit.crunchytoast.exceptions.WSProtocolException;
import github.log4jexploit.crunchytoast.http.inbound.impl.HttpClientImpl;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOReader;
import github.log4jexploit.crunchytoast.http.util.UncheckedIOWriter;
import github.log4jexploit.crunchytoast.http.util.WSSecurityPolicy;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.util.ConnectionState;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public final class WSClientImpl extends HttpClientImpl implements WSClient {

    private static final String SEC_WEBSOCKET_KEY = "Sec-WebSocket-Key";
    private static final String SEC_WEBSOCKET_ACCEPT = "Sec-WebSocket-Accept";

    private UncheckedIOReader reader;
    private UncheckedIOWriter writer;

    private final WSServer webSocketServer;
    private final WSProtocol protocol;

    private WSSecurityPolicy wsSecurityPolicy;
    private ConnectionState state;

    private boolean masked;


    public WSClientImpl(Socket socket, WSServer server) {
        super(socket, server);

        this.webSocketServer = server;

        this.protocol = WSServerBuilder.getDefaultProtocol();
        this.state = ConnectionState.OPENING_HANDSHAKE;

        this.wsSecurityPolicy = WSSecurityPolicy.createDefault();

        this.reader = new UncheckedIOReader(this.in);
        this.writer = new UncheckedIOWriter(this.out);
    }

    @Override
    protected void onError(Exception e) {
        super.onError(e);

        if(e instanceof IOException || e instanceof UncheckedIOException) {
            this.state = ConnectionState.CONNECTION_CLOSED;
        } else {
            this.state = ConnectionState.CONNECTION_ERROR;
        }
    }

    protected void onStart() {
        try {
            this.alive = true;
            this.performHandshake();
            this.server.getClientConnectHook().accept(WSClientImpl.this);

            // Connection actively exchanging packets
            while (alive && !socket.isClosed()) {
                this.spin();
            }

            if (!alive && !socket.isOutputShutdown()) {
                this.sendFinalPacket();
            }
        } catch (Exception e) {
           this.onError(e);
        } finally {
            this.close();
        }
    }

    @Override
    protected void spin() {
        WSPacket packet = protocol.decode(this.in);
        if (packet.getOpCode() == OpCode.CLOSE) {
            this.close();
            return;
        }
        this.webSocketServer.getPacketConsumer().accept(this, packet.getPayload().getByteArray());
    }

    private void performHandshake() throws ProtocolException {
        this.state = ConnectionState.OPENING_HANDSHAKE;

        HttpRequest request = HttpRequest.createDefault();
        request.receive(this);

        if (!request.hasCustomHeader(SEC_WEBSOCKET_KEY.toLowerCase()))
            throw new WSProtocolException("The incoming request is missing the 'Sec-WebSocket-Key' header!");

        String webSocketHash = this.generateWebSocketHash(request);

        // Switching from Http/1.1 to websocket protocol
        this.state = ConnectionState.CLOSING_HANDSHAKE;

        HttpResponse response = HttpResponse.createDefault();
        response.setResponseCode(Http.ResponseCode.SWITCHING_PROTOCOLS);
        response.setHeader(Http.HeaderType.CONNECTION, "upgrade");
        response.setHeader(Http.HeaderType.UPGRADE, "websocket");
        response.setCustomHeader(SEC_WEBSOCKET_ACCEPT, webSocketHash);

        IBodyContentHandler bodyContentHandler = response.send(this);
        bodyContentHandler.onFlushRemaining();

        this.state = ConnectionState.HANDSHAKE_SUCCESS;
    }

    private String generateWebSocketHash(HttpRequest request) {
        try {
            String webSocketKey = request.getCustomHeader(SEC_WEBSOCKET_KEY.toLowerCase()).trim() + GUID;
            byte[] sha1 = MessageDigest.getInstance("SHA-1").digest(webSocketKey.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(sha1);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("VM appears not to be implementing the SHA-1 MessageDigest!", e);
        }
    }

    private void sendFinalPacket() throws IOException {
        WSPacket packet = WSPacket.build()
                .setPayload(new BitStream())
                .setExtensionBit1(false)
                .setExtensionBit2(false)
                .setExtensionBit3(false)
                .setOpCode(OpCode.CLOSE)
                .setMask(WSClientImpl.this.masked);

        socket.getOutputStream().write(protocol.encode(packet));
        socket.getOutputStream().flush();
    }

    @Override
    public void close() {
        super.close();

        if(this.state != ConnectionState.CONNECTION_ERROR) {
            this.state = this.state == ConnectionState.HANDSHAKE_SUCCESS ?
                    ConnectionState.CONNECTION_CLOSED : ConnectionState.CONNECTION_ERROR;
        }
    }

    @Override
    public void send(String data) throws UncheckedIOException {
        this.send(data.getBytes(StandardCharsets.UTF_8));
    }

    @Override
    public void send(byte[] data) throws UncheckedIOException {
        byte[] encoded = protocol.encode(
                WSPacket.build()
                        .setPacket(new BitStream())
                        .setPayload(new BitStream(data))
                        .setMask(this.masked)
                        .setOpCode(OpCode.TEXT)
                        .setFinalMessage(true)
                        .createMaskKey()
        );
        this.writer.write(encoded);
        this.writer.flush();
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public ConnectionState getConnectionState() {
        return state;
    }

    public WSSecurityPolicy getWebSocketSecurityPolicy() {
        return this.wsSecurityPolicy;
    }
}
