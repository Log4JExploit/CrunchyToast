/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.exceptions.WSProtocolException;
import github.log4jexploit.crunchytoast.http.message.body.ContentCoder;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.websocket.util.ConnectionState;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.inf.WSServer;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import java.io.*;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;

public final class WSClientImpl implements WSClient {

    private final WSProtocol protocol;
    private final ArrayList<WSPacket> packets;
    private final WSEventHandler eventHandler;
    private final HashMap<Http.HeaderType, String> headers;
    private final WSServer server;
    private final Socket socket;

    private InputStream in;
    private OutputStream out;

    private ConnectionState state;
    private Thread readerThread;
    private String header;

    private boolean alive;
    private boolean masked;


    public WSClientImpl(Socket socket, WSServer server, WSEventHandler eventHandler) {
        this.protocol = WSServerBuilder.getDefaultProtocol();
        this.socket = socket;
        this.eventHandler = eventHandler;
        this.state = ConnectionState.OPENING_HANDSHAKE;
        this.headers = new HashMap<>();
        this.server = server;
        this.packets = new ArrayList<>();

        try {
            this.in = socket.getInputStream();
            this.out = socket.getOutputStream();
        } catch (Exception ignored) {}
    }

    private void initReaderThread() {
        this.readerThread = new Thread(() -> {
            try {
                this.alive = true;
                this.state = ConnectionState.OPENING_HANDSHAKE;

                HttpRequest request = HttpRequest.createDefault();
                request.receive(this, this.in);
                this.headers.putAll(request.getHeaders());

                this.eventHandler.onConnect(WSClientImpl.this);

                if (!request.getCustomHeaders().containsKey("Sec-WebSocket-Key"))
                    throw new WSProtocolException("The incoming connection does not support the websocket protocol!");

                String webSocketKey = request.getCustomHeader("Sec-WebSocket-Key").trim() + GUID;
                byte[] sha1 = MessageDigest.getInstance("SHA1").digest(webSocketKey.getBytes(StandardCharsets.UTF_8));
                String encoded = Base64.getEncoder().encodeToString(sha1);

                // Switching from Http/1.1 to websocket protocol
                this.state = ConnectionState.CLOSING_HANDSHAKE;

                HttpResponse response = HttpResponse.createDefault();
                response.setResponseCode(Http.ResponseCode.SWITCHING_PROTOCOLS);
                response.setHeader(Http.HeaderType.CONNECTION, "Upgrade");
                response.setHeader(Http.HeaderType.UPGRADE, "websocket");
                response.setCustomHeader("Sec-WebSocket-Accept", encoded);

                ContentCoder contentCoder = response.send(this);
                contentCoder.writeAll();

                this.state = ConnectionState.HANDSHAKE_SUCCESS;

                // Connection actively exchanging packets
                while (alive && !socket.isClosed()) {
                    WSPacket packet = protocol.decode(this.socket.getInputStream());
                    if (packet.getOpCode() == OpCode.CLOSE) {
                        this.alive = false;
                        break;
                    }
                    this.packets.add(packet);
                    this.eventHandler.onPacketReceive(WSClientImpl.this, packet.getPayload().getByteArray());
                }

                if (!alive && !socket.isClosed()) {
                    WSPacket packet = WSPacket.build()
                            .setPayload(new BitStream())
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setOpCode(OpCode.CLOSE)
                            .setMask(WSClientImpl.this.masked);

                    socket.getOutputStream().write(protocol.encode(packet));
                    socket.getOutputStream().flush();
                }
            } catch (IOException e) {
                this.server.getLogger().info("WS protocol violation "+this.getIP()+": Connection closed without FIN packet!");
                this.server.getLogger().debugError(e);
            } catch (HttpProtocolException e) {
                this.server.getLogger().info("HTTP protocol violation: "+this.getIP()+": "+e.getMessage());
            } catch (Exception e) {
                this.state = ConnectionState.CONNECTION_ERROR;
                this.server.getLogger().debugError(e);
            } finally {
                try {
                    this.socket.close();
                    this.alive = false;
                    this.state = this.state == ConnectionState.HANDSHAKE_SUCCESS ?
                            ConnectionState.CONNECTION_CLOSED : ConnectionState.CONNECTION_ERROR;

                    this.packets.clear();
                    this.headers.clear();
                    this.header = null;
                    this.eventHandler.onClose(WSClientImpl.this);
                } catch (IOException e) {
                    this.server.getLogger().debugError(e);
                }
            }
        });
    }

    @Override
    public void start() {
        initReaderThread();
        this.readerThread.start();
    }

    @Override
    public void close() {
        try {
            this.alive = false;
            this.readerThread.interrupt();
            this.readerThread.join();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void send(String data) throws IOException {
        byte[] encoded = protocol.encode(
                WSPacket.build()
                        .setPacket(new BitStream())
                        .setPayload(new BitStream(data.getBytes()))
                        .setMask(this.masked)
                        .setOpCode(OpCode.TEXT)
                        .setFinalMessage(true)
                        .createMaskKey()
        );
        this.socket.getOutputStream().write(encoded);
        this.socket.getOutputStream().flush();
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public HashMap<Http.HeaderType, String> getHeaders() {
        return headers;
    }

    @Override
    public String getIP() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public ConnectionState getConnectionState() {
        return state;
    }

    @Override
    public String getHeader() {
        return header;
    }

    @Override
    public ArrayList<WSPacket> getPackets() {
        return new ArrayList<>(packets);
    }

    @Override
    public WSServer getServer() {
        return server;
    }

    @Override
    public InputStream getInputStream() {
        return this.in;
    }

    @Override
    public OutputStream getOutputStream() {
        return out;
    }
}
