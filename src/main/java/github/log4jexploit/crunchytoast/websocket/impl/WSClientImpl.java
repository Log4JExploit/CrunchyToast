/*
 * Copyright (c) 2022-2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.exceptions.WSProtocolException;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.HttpSecurityPolicy;
import github.log4jexploit.crunchytoast.http.util.WSSecurityPolicy;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.util.ConnectionState;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.*;

public final class WSClientImpl implements WSClient {

    private static final String SEC_WEBSOCKET_KEY = "Sec-WebSocket-Key";
    private static final String SEC_WEBSOCKET_ACCEPT = "Sec-WebSocket-Accept";

    private final WSProtocol protocol;
    private final List<WSPacket> packets;
    private final Map<Http.HeaderType, String> headers;
    private final WSServer server;
    private final Socket socket;

    private HttpSecurityPolicy httpSecurityPolicy;
    private WSSecurityPolicy wsSecurityPolicy;
    private ConnectionState state;
    private Thread readerThread;
    private String header;

    private boolean alive;
    private boolean masked;


    public WSClientImpl(Socket socket, WSServer server) {
        this.protocol = WSServerBuilder.getDefaultProtocol();
        this.socket = socket;
        this.state = ConnectionState.OPENING_HANDSHAKE;
        this.headers = new HashMap<>();
        this.packets = new ArrayList<>();
        this.server = server;
        this.wsSecurityPolicy = WSSecurityPolicy.createDefault();
        this.httpSecurityPolicy = HttpSecurityPolicy.createDefault();
    }

    private void initReaderThread() {
        this.readerThread = new Thread(() -> {
            try {
                this.alive = true;
                this.state = ConnectionState.OPENING_HANDSHAKE;

                HttpRequest request = HttpRequest.createDefault();
                request.receive(this);
                this.headers.putAll(request.getHeaders());

                this.server.onConnect(WSClientImpl.this);

                if (!request.hasCustomHeader(SEC_WEBSOCKET_KEY.toLowerCase()))
                    throw new WSProtocolException("The incoming connection does not support the websocket protocol!");

                String webSocketKey = request.getCustomHeader(SEC_WEBSOCKET_KEY.toLowerCase()).trim() + GUID;
                byte[] sha1 = MessageDigest.getInstance("SHA-1").digest(webSocketKey.getBytes(StandardCharsets.UTF_8));
                String encoded = Base64.getEncoder().encodeToString(sha1);

                // Switching from Http/1.1 to websocket protocol
                this.state = ConnectionState.CLOSING_HANDSHAKE;

                HttpResponse response = HttpResponse.createDefault();
                response.setResponseCode(Http.ResponseCode.SWITCHING_PROTOCOLS);
                response.setHeader(Http.HeaderType.CONNECTION, "upgrade");
                response.setHeader(Http.HeaderType.UPGRADE, "websocket");
                response.setCustomHeader(SEC_WEBSOCKET_ACCEPT, encoded);

                IBodyContentHandler bodyContentHandler = response.send(this);
                bodyContentHandler.onFlushRemaining();

                this.state = ConnectionState.HANDSHAKE_SUCCESS;

                // Connection actively exchanging packets
                while (alive && !socket.isClosed()) {
                    WSPacket packet = protocol.decode(this.socket.getInputStream());
                    if (packet.getOpCode() == OpCode.CLOSE) {
                        this.alive = false;
                        break;
                    }
                    this.packets.add(packet);
                    this.server.onPacketReceive(WSClientImpl.this, packet.getPayload().getByteArray());
                }

                if (!alive && !socket.isClosed()) {
                    WSPacket packet = WSPacket.build()
                            .setPayload(new BitStream())
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setOpCode(OpCode.CLOSE)
                            .setMask(WSClientImpl.this.masked);

                    socket.getOutputStream().write(protocol.encode(packet));
                    socket.getOutputStream().flush();
                }
            } catch (IOException e) {
                this.server.getLogger().info("Connection IO/Error: " + this.getAddress() + ": Connection closed without FIN packet!");
                this.server.getLogger().debugError(e);
            } catch (WSProtocolException e) {
                this.server.getLogger().info("WS protocol violation " + this.getAddress() + ": "+e.getMessage());
                this.server.getLogger().debugError(e);
                this.state = ConnectionState.CONNECTION_ERROR;
            } catch (HttpProtocolException e) {
                this.server.getLogger().info("HTTP protocol violation: " + this.getAddress() + ": "+e.getMessage());
                this.state = ConnectionState.CONNECTION_ERROR;
            } catch (Exception e) {
                this.state = ConnectionState.CONNECTION_ERROR;
                this.server.getLogger().debugError(e);
            } finally {
                try {
                    this.socket.close();
                    this.alive = false;
                    this.state = this.state == ConnectionState.HANDSHAKE_SUCCESS ?
                            ConnectionState.CONNECTION_CLOSED : ConnectionState.CONNECTION_ERROR;

                    this.packets.clear();
                    this.headers.clear();
                    this.header = null;
                    this.server.onDisconnect(WSClientImpl.this);
                } catch (IOException e) {
                    this.server.getLogger().debugError(e);
                }
            }
        });
    }

    @Override
    public void start() {
        initReaderThread();
        this.readerThread.start();
    }

    @Override
    public void close() {
        try {
            this.alive = false;
            this.socket.close();
            this.readerThread.interrupt();
        } catch (IOException e) {
            this.server.getLogger().alertError(e);
        }
    }

    @Override
    public void send(String data) throws IOException {
        byte[] encoded = protocol.encode(
                WSPacket.build()
                        .setPacket(new BitStream())
                        .setPayload(new BitStream(data.getBytes()))
                        .setMask(this.masked)
                        .setOpCode(OpCode.TEXT)
                        .setFinalMessage(true)
                        .createMaskKey()
        );
        this.socket.getOutputStream().write(encoded);
        this.socket.getOutputStream().flush();
    }

    @Override
    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public Map<Http.HeaderType, String> getHeaders() {
        return headers;
    }

    @Override
    public String getAddress() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public String getAddressResolved() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public ConnectionState getConnectionState() {
        return state;
    }

    @Override
    public String getHeader() {
        return header;
    }

    @Override
    public ArrayList<WSPacket> getPackets() {
        return new ArrayList<>(packets);
    }

    @Override
    public WSServer getServer() {
        return server;
    }

    @Override
    public OutputStream getOutputStream() {
        try {
            return this.socket.getOutputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public InputStream getInputStream() {
        try {
            return this.socket.getInputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public WSSecurityPolicy getSecurityPolicy() {
        return null;
    }
}
