/*
 * Copyright (c) 2024 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.exceptions.WSProtocolException;
import github.log4jexploit.crunchytoast.http.message.body.ContentCoder;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.logger.NotificationLevel;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.websocket.util.ConnectionState;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import github.log4jexploit.crunchytoast.websocket.inf.WSOutboundClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Random;

// Coded by Zadex at 18/05/2023
public class WSOutboundClientImpl implements WSOutboundClient {

    private WSEventHandler eventHandler;
    private final WSProtocol protocol;
    private final Logger logger;

    private OutputStream out;
    private InputStream in;
    private Socket socket;

    private ConnectionState connectionState;
    private Thread readerThread;

    private boolean alive;
    private boolean masked;


    public WSOutboundClientImpl(String address, int port) {
        this.protocol = WSServerBuilder.getDefaultProtocol();
        this.eventHandler = new WSEventHandler() {};
        this.connectionState = ConnectionState.READY_FOR_CONNECT;
        this.logger = new LoggerTimeImpl(this.getClass());
        this.logger.setNotificationLevel(NotificationLevel.DEBUG);
        throw new RuntimeException("Not implemented: WSOutboundClientImpl");
    }

    private void createSocket(String address, int port) throws Exception {
        this.in = socket.getInputStream();
        this.out = socket.getOutputStream();
    }

    private void initReaderThread() {
        this.readerThread = new Thread(() -> {
            try {
                this.alive = true;
                this.connectionState = ConnectionState.OPENING_HANDSHAKE;
                this.eventHandler.onConnect(WSOutboundClientImpl.this);

                Random r = new SecureRandom();
                byte[] randomBytes = new byte[16];
                r.nextBytes(randomBytes);

                String encoded = Base64.getEncoder().encodeToString(randomBytes).trim();
                String computedResponse = Base64.getEncoder().encodeToString(
                                            MessageDigest.getInstance("SHA-1").digest((encoded + WSClient.GUID).getBytes())
                );

                HttpRequest request = HttpRequest.createDefault();
                request.setRequestType(Http.RequestType.GET);
                request.getCustomHeaders().put("Sec-WebSocket-Key", encoded);
                request.setHeader(Http.HeaderType.CONNECTION, "upgrade");
                request.setHeader(Http.HeaderType.UPGRADE, "websocket");

                ContentCoder contentCoder = request.send(WSOutboundClientImpl.this, this.out);
                contentCoder.writeAll();

                // Switching from Http/1.1 to websocket protocol
                this.connectionState = ConnectionState.CLOSING_HANDSHAKE;

                HttpResponse response = HttpResponse.createDefault();
                contentCoder = response.receive(WSOutboundClientImpl.this, this.in);
                contentCoder.readAll();
                contentCoder.decodeAll();

                if(response.getResponseCode() != Http.ResponseCode.SWITCHING_PROTOCOLS) {
                    throw new WSProtocolException("Server has no intention of switching protocols: "+response.getResponseCode().toString());
                }

                if(!response.getCustomHeaders().containsKey("Sec-WebSocket-Accept")) {
                    throw new WSProtocolException("Server didn't include the Sec-WebSocket-Accept header!");
                }

                if(!response.getCustomHeader("Sec-WebSocket-Accept").equals(computedResponse)) {
                    throw new WSProtocolException("Server produced an invalid Sec-WebSocket-Accept hash value!");
                }

                this.connectionState = ConnectionState.HANDSHAKE_SUCCESS;

                // Connection actively exchanging packets
                while (alive && !socket.isClosed()) {
                    WSPacket packet = protocol.decode(this.socket.getInputStream());
                    if (packet.getOpCode() == OpCode.CLOSE) {
                        this.alive = false;
                        break;
                    }
                    this.eventHandler.onPacketReceive(WSOutboundClientImpl.this, packet.getPayload().getByteArray());
                }

                if (!alive && !socket.isClosed()) {
                    WSPacket packet = WSPacket.build()
                            .setPayload(new BitStream())
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setOpCode(OpCode.CLOSE)
                            .setMask(WSOutboundClientImpl.this.masked);

                    socket.getOutputStream().write(protocol.encode(packet));
                    socket.getOutputStream().flush();
                }
            } catch (IOException e) {
                this.logger.info("WS protocol violation " + this.getIP() + ": Connection closed without fin packet!");
            } catch (WSProtocolException | HttpProtocolException e) {
                this.logger.info("HTTP protocol violation: "+this.getIP()+": "+e.getMessage());
            } catch (Exception e) {
                this.connectionState = ConnectionState.CONNECTION_ERROR;
                this.logger.debugError(e);
            } finally {
                try {
                    this.socket.close();
                    this.alive = false;
                    if(this.connectionState == ConnectionState.HANDSHAKE_SUCCESS) {
                        this.connectionState = ConnectionState.CONNECTION_CLOSED;
                    } else {
                        this.connectionState = ConnectionState.CONNECTION_ERROR;
                    }
                    this.eventHandler.onClose(WSOutboundClientImpl.this);
                } catch (IOException e) {
                    this.logger.debugError(e);
                }
            }
        });
    }

    @Override
    public void start() {
        initReaderThread();
        this.readerThread.start();
    }

    @Override
    public void close() {
        try {
            this.alive = false;
            this.readerThread.interrupt();
            this.readerThread.join();
        } catch (Exception e) {
            this.logger.debugError(e);
        }
    }

    @Override
    public void send(byte[] data) throws IOException {
        byte[] encoded = protocol.encode(
                WSPacket.build()
                        .setPacket(new BitStream())
                        .setPayload(new BitStream(data))
                        .setMask(this.masked)
                        .setOpCode(OpCode.TEXT)
                        .setFinalMessage(true)
                        .createMaskKey()
        );
        this.socket.getOutputStream().write(encoded);
        this.socket.getOutputStream().flush();
    }

    @Override
    public void setEventHandler(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public ConnectionState getConnectionState() {
        return this.connectionState;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public String getIP() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public OutputStream getOutputStream() {
        return null;
    }

    @Override
    public InputStream getInputStream() {
        return null;
    }
}
