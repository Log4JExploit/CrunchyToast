/*
 * Copyright (c) 2022-2025 CrunchyToast by Log4JExploit
 * Do you keep my non-compiled source code?
 * Then keep this comment.  (View the license)
 */

package github.log4jexploit.crunchytoast.websocket.impl;

import en.zadex.BitStream;
import github.log4jexploit.crunchytoast.exceptions.HttpProtocolException;
import github.log4jexploit.crunchytoast.exceptions.WSProtocolException;
import github.log4jexploit.crunchytoast.http.message.body.inf.IBodyContentHandler;
import github.log4jexploit.crunchytoast.http.message.inf.HttpRequest;
import github.log4jexploit.crunchytoast.http.message.inf.HttpResponse;
import github.log4jexploit.crunchytoast.http.util.Http;
import github.log4jexploit.crunchytoast.http.util.SecurityPolicy;
import github.log4jexploit.crunchytoast.logger.NotificationLevel;
import github.log4jexploit.crunchytoast.logger.impl.LoggerTimeImpl;
import github.log4jexploit.crunchytoast.logger.inf.Logger;
import github.log4jexploit.crunchytoast.websocket.inf.WSClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSEventHandler;
import github.log4jexploit.crunchytoast.websocket.inf.WSOutboundClient;
import github.log4jexploit.crunchytoast.websocket.inf.WSProtocol;
import github.log4jexploit.crunchytoast.websocket.util.ConnectionState;
import github.log4jexploit.crunchytoast.websocket.util.OpCode;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Random;

public class WSOutboundClientImpl implements WSOutboundClient {

    private WSEventHandler eventHandler;
    private final WSProtocol protocol;
    private final Logger logger;
    private Socket socket;

    private ConnectionState connectionState;
    private Thread readerThread;

    private boolean alive;
    private boolean masked;


    public WSOutboundClientImpl(String address, int port) {
        this.protocol = WSServerBuilder.getDefaultProtocol();
        this.eventHandler = new WSEventHandler() {};
        this.connectionState = ConnectionState.READY_TO_CONNECT;
        this.logger = new LoggerTimeImpl(this.getClass());
        this.logger.setNotificationLevel(NotificationLevel.DEBUG);
        createSocket(address, port);
    }

    private void createSocket(String address, int port) throws UncheckedIOException {
        try {
            this.socket = new Socket(address, port);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private void initReaderThread() {
        this.readerThread = new Thread(() -> {
            try {
                this.alive = true;
                this.eventHandler.onConnect(WSOutboundClientImpl.this);

                doHandshake();
                this.connectionState = ConnectionState.HANDSHAKE_SUCCESS;

                // Connection actively exchanging packets
                while (alive && !socket.isClosed()) {
                    WSPacket packet = protocol.decode(this.socket.getInputStream());
                    if (packet.getOpCode() == OpCode.CLOSE) {
                        this.alive = false;
                        break;
                    }
                    this.eventHandler.onPacketReceive(WSOutboundClientImpl.this, packet.getPayload().getByteArray());
                }

                if (!alive && !socket.isClosed()) {
                    WSPacket packet = WSPacket.build()
                            .setPayload(new BitStream())
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setExtensionBit1(false)
                            .setOpCode(OpCode.CLOSE)
                            .setMask(WSOutboundClientImpl.this.masked);

                    socket.getOutputStream().write(protocol.encode(packet));
                    socket.getOutputStream().flush();
                }
            } catch (IOException e) {
                this.logger.alert("Connection IO/Error:" + this.getAddress() + ": Connection closed without fin packet!");
                this.logger.alertError(e);
            } catch (WSProtocolException e) {
                this.logger.alert("WS protocol violation " + this.getAddress() + ": "+e.getMessage());
                this.logger.alertError(e);
            } catch (HttpProtocolException e) {
                this.logger.alert("HTTP protocol violation: " + this.getAddress() + ": "+e.getMessage());
                this.logger.alertError(e);
            } catch (Exception e) {
                this.connectionState = ConnectionState.CONNECTION_ERROR;
                this.logger.debugError(e);
            } finally {
                try {
                    this.socket.close();
                    this.alive = false;
                    if(this.connectionState == ConnectionState.HANDSHAKE_SUCCESS) {
                        this.connectionState = ConnectionState.CONNECTION_CLOSED;
                    } else {
                        this.connectionState = ConnectionState.CONNECTION_ERROR;
                    }
                    this.eventHandler.onDisconnect(WSOutboundClientImpl.this);
                } catch (IOException e) {
                    this.logger.alertError(e);
                }
            }
        });
    }

    private void doHandshake() throws WSProtocolException, NoSuchAlgorithmException {
        this.connectionState = ConnectionState.OPENING_HANDSHAKE;
        Random r = new SecureRandom();
        byte[] randomBytes = new byte[16];
        r.nextBytes(randomBytes);

        String encoded = Base64.getEncoder().encodeToString(randomBytes).trim();
        String computedResponse = Base64.getEncoder().encodeToString(
                MessageDigest.getInstance("SHA-1").digest((encoded + WSClient.GUID).getBytes())
        );

        HttpRequest request = HttpRequest.createDefault();
        request.setRequestType(Http.RequestType.GET);
        request.getCustomHeaders().put("Sec-WebSocket-Key", encoded);
        request.setHeader(Http.HeaderType.CONNECTION, "upgrade");
        request.setHeader(Http.HeaderType.UPGRADE, "websocket");

        IBodyContentHandler bodyContentHandler = request.send(WSOutboundClientImpl.this);
        bodyContentHandler.onFlushRemaining();

        // Switching from Http/1.1 to websocket protocol
        this.connectionState = ConnectionState.CLOSING_HANDSHAKE;

        HttpResponse response = HttpResponse.createDefault();
        bodyContentHandler = response.receive(WSOutboundClientImpl.this);
        bodyContentHandler.onFlushRemaining();

        if(response.getResponseCode() != Http.ResponseCode.SWITCHING_PROTOCOLS) {
            throw new WSProtocolException("Server has no intention of switching protocols: "+response.getResponseCode().toString());
        }

        if(!response.hasCustomHeader("Sec-WebSocket-Accept")) {
            throw new WSProtocolException("Server didn't include the Sec-WebSocket-Accept header!");
        }

        if(!response.getCustomHeader("Sec-WebSocket-Accept").equals(computedResponse)) {
            throw new WSProtocolException("Server produced an invalid Sec-WebSocket-Accept hash value!");
        }
    }

    @Override
    public void start() {
        if(this.alive)
            return;

        initReaderThread();
        this.readerThread.start();
    }

    @Override
    public void close() {
        try {
            this.alive = false;
            this.socket.close();
            this.readerThread.interrupt();
        } catch (IOException e) {
            this.logger.alertError(e);
        }
    }

    @Override
    public void send(byte[] data) throws IOException {
        byte[] encoded = protocol.encode(
                WSPacket.build()
                        .setPacket(new BitStream())
                        .setPayload(new BitStream(data))
                        .setMask(this.masked)
                        .setOpCode(OpCode.TEXT)
                        .setFinalMessage(true)
                        .createMaskKey()
        );
        this.socket.getOutputStream().write(encoded);
        this.socket.getOutputStream().flush();
    }

    @Override
    public void setEventHandler(WSEventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    public void setMasked(boolean masked) {
        this.masked = masked;
    }

    @Override
    public boolean isAlive() {
        return alive;
    }

    @Override
    public ConnectionState getConnectionState() {
        return this.connectionState;
    }

    @Override
    public WSEventHandler getEventHandler() {
        return this.eventHandler;
    }

    @Override
    public String getAddress() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public String getAddressResolved() {
        return this.socket.getInetAddress().getHostAddress();
    }

    @Override
    public OutputStream getOutputStream() {
        try {
            return this.socket.getOutputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public InputStream getInputStream() {
        try {
            return this.socket.getInputStream();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    @Override
    public SecurityPolicy getSecurityPolicy() {
        throw new RuntimeException("WSOutboundClientImpl has not yet implemented a SecurityPolicy!");
    }
}
